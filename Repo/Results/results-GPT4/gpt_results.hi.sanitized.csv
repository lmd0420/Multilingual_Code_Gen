source_file,task_id,prompt,code,test_imports,test_list,gpt_result
Benchmark Questions Verification V2.ipynb,11,स्ट्रिंग से किसी दिए गए कैरेक्टर की पहली और आखिरी घटना को हटाने के लिए एक पायथन फ़ंक्शन लिखें।,"def remove_Occ(s,ch): 
    for i in range(len(s)): 
        if (s[i] == ch): 
            s = s[0 : i] + s[i + 1:] 
            break
    for i in range(len(s) - 1,-1,-1):  
        if (s[i] == ch): 
            s = s[0 : i] + s[i + 1:] 
            break
    return s ",[],"['assert remove_Occ(""hello"",""l"") == ""heo""', 'assert remove_Occ(""abcda"",""a"") == ""bcd""', 'assert remove_Occ(""PHP"",""P"") == ""H""']","यहां एक फ़ंक्शन है जो दिए गए स्ट्रिंग से दिए गए कैरेक्टर की पहली और आखिरी घटना को हटाता है:

```python
def remove_first_and_last_occurrence(string, char):
    first_occurrence = string.find(char)
    last_occurrence = string.rfind(char)
    if first_occurrence != -1 and last_occurrence != -1:
        string = string[:first_occurrence] + string[first_occurrence+1:]
        last_occurrence = string.rfind(char)
        string = string[:last_occurrence] + string[last_occurrence+1:]
    return string
```

इस फ़ंक्शन का उपयोग निम्नलिखित तरीके से किया जा सकता है:

```python
print(remove_first_and_last_occurrence(""hello world"", ""l""))  # ""helo word""
```

यह फ़ंक्शन `find` और `rfind` फ़ंक्शन का उपयोग करके कैरेक्टर की पहली और आखिरी घटना का इंडेक्स प्राप्त करता है, और फिर स्लाइसिंग का उपयोग करके उन घटनाओं को हटा देता है. यदि कैरेक्टर स्ट्रिंग में नहीं होता है, तो यह फ़ंक्शन स्ट्रिंग को बिना किसी परिवर्तन के वापस करता है."
Benchmark Questions Verification V2.ipynb,12,किसी दिए गए मैट्रिक्स को उसकी पंक्तियों के योग के अनुसार आरोही क्रम में क्रमबद्ध करने के लिए एक फ़ंक्शन लिखें।,"def sort_matrix(M):
    result = sorted(M, key=sum)
    return result",[],"['assert sort_matrix([[1, 2, 3], [2, 4, 5], [1, 1, 1]])==[[1, 1, 1], [1, 2, 3], [2, 4, 5]]', 'assert sort_matrix([[1, 2, 3], [-2, 4, -5], [1, -1, 1]])==[[-2, 4, -5], [1, -1, 1], [1, 2, 3]]', 'assert sort_matrix([[5,8,9],[6,4,3],[2,1,4]])==[[2, 1, 4], [6, 4, 3], [5, 8, 9]]']","आप निम्नलिखित फ़ंक्शन का उपयोग कर सकते हैं:

```python
import numpy as np

def sort_matrix_by_row_sum(matrix):
    # पंक्तियों का योग निकालें
    row_sums = np.sum(matrix, axis=1)
    
    # पंक्तियों के योग के आधार पर इंडेक्स का आरोही क्रम प्राप्त करें
    sorted_indices = np.argsort(row_sums)
    
    # इंडेक्स के आधार पर मैट्रिक्स को क्रमबद्ध करें
    sorted_matrix = matrix[sorted_indices]
    
    return sorted_matrix
```

इस फ़ंक्शन का उपयोग निम्नलिखित प्रकार से किया जा सकता है:

```python
matrix = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
print(sort_matrix_by_row_sum(matrix))
```

यह मैट्रिक्स को पंक्तियों के योग के आधार पर आरोही क्रम में क्रमबद्ध करेगा।"
Benchmark Questions Verification V2.ipynb,14,त्रिकोणीय प्रिज्म का आयतन ज्ञात करने के लिए एक पायथन फ़ंक्शन लिखें।,"def find_Volume(l,b,h) : 
    return ((l * b * h) / 2) ",[],"['assert find_Volume(10,8,6) == 240', 'assert find_Volume(3,2,2) == 6', 'assert find_Volume(1,2,1) == 1']","आप त्रिकोणीय प्रिज्म का आयतन निम्नलिखित पायथन फ़ंक्शन का उपयोग करके ज्ञात कर सकते हैं:

```python
def volume_of_triangular_prism(base_area, height):
    return base_area * height
```

इस फ़ंक्शन का उपयोग करने के लिए, आपको त्रिकोणीय प्रिज्म के आधार क्षेत्रफल और ऊंचाई की जानकारी होनी चाहिए। फ़ंक्शन को निम्नलिखित तरीके से कॉल करें:

```python
print(volume_of_triangular_prism(10, 5))
```

इस उदाहरण में, आधार क्षेत्रफल 10 और ऊंचाई 5 है, और फ़ंक्शन का परिणाम 50 होगा।"
Benchmark Questions Verification V2.ipynb,16,एक ऐसा फ़ंक्शन लिखें जो सत्य लौटाता है यदि इनपुट स्ट्रिंग में अंडरस्कोर के साथ जुड़े हुए लोअरकेस अक्षरों का अनुक्रम होता है और अन्यथा गलत होता है।,"import re
def text_lowercase_underscore(text):
        patterns = '^[a-z]+_[a-z]+$'
        if re.search(patterns,  text):
                return True
        else:
                return False",[],"['assert text_lowercase_underscore(""aab_cbbbc"")==(True)', 'assert text_lowercase_underscore(""aab_Abbbc"")==(False)', 'assert text_lowercase_underscore(""Aaab_abbbc"")==(False)']","आप निम्नलिखित फ़ंक्शन का उपयोग कर सकते हैं:

```python
def is_underscore_separated_lowercase(s):
    words = s.split('_')
    for word in words:
        if not word.islower():
            return False
    return True
```

यह फ़ंक्शन इनपुट स्ट्रिंग को अंडरस्कोर ('_') के आधार पर विभाजित करता है और फिर प्रत्येक शब्द के लिए जांचता है कि क्या यह लोअरकेस में है। यदि कोई भी शब्द लोअरकेस में नहीं है, तो यह फ़ंक्शन False लौटाता है। यदि सभी शब्द लोअरकेस में हैं, तो यह True लौटाता है।"
Benchmark Questions Verification V2.ipynb,17,एक फ़ंक्शन लिखें जो इनपुट के रूप में एक वर्ग की भुजा की लंबाई दी गई परिधि लौटाता है।,"def square_perimeter(a):
  perimeter=4*a
  return perimeter",[],"['assert square_perimeter(10)==40', 'assert square_perimeter(5)==20', 'assert square_perimeter(4)==16']","वर्ग की परिधि (परिमाप) की गणना करने के लिए, हमें भुजा की लंबाई को 4 से गुणा करना होता है। यहां एक फ़ंक्शन है जो यह करता है:

```python
def calculate_perimeter(length):
    return 4 * length
```

इस फ़ंक्शन का उपयोग करने के लिए, आप बस वर्ग की भुजा की लंबाई के साथ इसे कॉल करें, जैसे कि `calculate_perimeter(5)`। यह 20 लौटाएगा, क्योंकि एक वर्ग जिसकी भुजा की लंबाई 5 है, उसकी परिधि 20 होगी।"
Benchmark Questions Verification V2.ipynb,18,पहली स्ट्रिंग से उन वर्णों को हटाने के लिए एक फ़ंक्शन लिखें जो दूसरी स्ट्रिंग में मौजूद हैं।,"NO_OF_CHARS = 256
def str_to_list(string): 
	temp = [] 
	for x in string: 
		temp.append(x) 
	return temp 
def lst_to_string(List): 
	return ''.join(List) 
def get_char_count_array(string): 
	count = [0] * NO_OF_CHARS 
	for i in string: 
		count[ord(i)] += 1
	return count 
def remove_dirty_chars(string, second_string): 
	count = get_char_count_array(second_string) 
	ip_ind = 0
	res_ind = 0
	temp = '' 
	str_list = str_to_list(string) 
	while ip_ind != len(str_list): 
		temp = str_list[ip_ind] 
		if count[ord(temp)] == 0: 
			str_list[res_ind] = str_list[ip_ind] 
			res_ind += 1
		ip_ind+=1
	return lst_to_string(str_list[0:res_ind]) ",[],"['assert remove_dirty_chars(""probasscurve"", ""pros"") == \'bacuve\'', 'assert remove_dirty_chars(""digitalindia"", ""talent"") == \'digiidi\'', 'assert remove_dirty_chars(""exoticmiles"", ""toxic"") == \'emles\'']","आप निम्नलिखित फ़ंक्शन का उपयोग कर सकते हैं:

```python
def remove_chars(s1, s2):
    return """".join(c for c in s1 if c not in s2)
```

इस फ़ंक्शन का उपयोग करने के लिए, आप दो स्ट्रिंग्स पास करेंगे और यह फ़ंक्शन पहली स्ट्रिंग से उन सभी वर्णों को हटा देगा जो दूसरी स्ट्रिंग में मौजूद हैं।

उदाहरण के लिए:

```python
print(remove_chars(""hello world"", ""world""))  # Output: ""he ""
```"
Benchmark Questions Verification V2.ipynb,19,यह पता लगाने के लिए एक फ़ंक्शन लिखें कि पूर्णांकों की दी गई सरणी में कोई डुप्लिकेट तत्व है या नहीं।,"def test_duplicate(arraynums):
    nums_set = set(arraynums)    
    return len(arraynums) != len(nums_set)     ",[],"['assert test_duplicate(([1,2,3,4,5]))==False', 'assert test_duplicate(([1,2,3,4, 4]))==True', 'assert test_duplicate([1,1,2,2,3,3,4,4,5])==True']","आप निम्नलिखित फ़ंक्शन का उपयोग कर सकते हैं:

```python
def check_duplicates(lst):
    return len(lst) != len(set(lst))
```

यह फ़ंक्शन एक सूची `lst` को इनपुट के रूप में लेता है और यदि सूची में कोई डुप्लिकेट तत्व होते हैं, तो यह `True` लौटाता है, अन्यथा `False` लौटाता है। यह फ़ंक्शन `set` डेटा संरचना का उपयोग करता है, जो डुप्लिकेट तत्वों को हटा देता है, और फिर इसकी लंबाई की तुलना सूची की मूल लंबाई से करता है। यदि ये दोनों लंबाई एक समान नहीं हैं, तो इसका मतलब है कि सूची में कुछ डुप्लिकेट तत्व थे।"
Benchmark Questions Verification V2.ipynb,20,यह जांचने के लिए एक फ़ंक्शन लिखें कि दी गई संख्या वुडबॉल है या नहीं।,"def is_woodall(x): 
	if (x % 2 == 0): 
		return False
	if (x == 1): 
		return True
	x = x + 1 
	p = 0
	while (x % 2 == 0): 
		x = x/2
		p = p + 1
		if (p == x): 
			return True
	return False",[],"['assert is_woodall(383) == True', 'assert is_woodall(254) == False', 'assert is_woodall(200) == False']","वुडबॉल संख्या वह होती है जिसका वर्गमूल पूर्णांक होता है। इसे जांचने के लिए, हम वर्गमूल का उपयोग कर सकते हैं और फिर जांच सकते हैं कि क्या वह पूर्णांक है। यहां एक फ़ंक्शन है जो यह करता है:

```python
import math

def is_whole_number(n):
    return n >= 0 and math.sqrt(n) % 1 == 0

print(is_whole_number(25))  # True
print(is_whole_number(24))  # False
```

इस फ़ंक्शन में, हम पहले जांचते हैं कि क्या संख्या शून्य या उससे अधिक है, क्योंकि ऋणात्मक संख्याओं का वर्गमूल वास्तविक नहीं होता है। फिर हम वर्गमूल लेते हैं और उसे 1 से मॉडुलस करते हैं। यदि परिणाम शून्य है, तो यह संख्या वुडबॉल है।"
Mike's Copy of Benchmark Questions Verification V2.ipynb,56,यह जांचने के लिए एक पायथन फ़ंक्शन लिखें कि क्या कोई दी गई संख्या इसके विपरीत के दोगुने से एक कम है।,"def rev(num):    
    rev_num = 0
    while (num > 0):  
        rev_num = (rev_num * 10 + num % 10) 
        num = num // 10  
    return rev_num  
def check(n):    
    return (2 * rev(n) == n + 1)  ",[],"['assert check(70) == False', 'assert check(23) == False', 'assert check(73) == True']","आप निम्नलिखित पायथन फ़ंक्शन का उपयोग कर सकते हैं:

```python
def check_number(n):
    return n == 2 / n - 1
```

यह फ़ंक्शन एक संख्या `n` को इनपुट के रूप में लेता है और यदि `n` अपने विपरीत के दोगुने से एक कम है, तो यह `True` लौटाता है, अन्यथा `False` लौटाता है."
Mike's Copy of Benchmark Questions Verification V2.ipynb,57,अंकों की दी गई सूची के साथ बनाई जा सकने वाली सबसे बड़ी संख्या खोजने के लिए एक पायथन फ़ंक्शन लिखें।,"def find_Max_Num(arr) : 
    n = len(arr)
    arr.sort(reverse = True) 
    num = arr[0] 
    for i in range(1,n) : 
        num = num * 10 + arr[i] 
    return num ",[],"['assert find_Max_Num([1,2,3]) == 321', 'assert find_Max_Num([4,5,6,1]) == 6541', 'assert find_Max_Num([1,2,3,9]) == 9321']","आप निम्नलिखित पायथन फ़ंक्शन का उपयोग कर सकते हैं:

```python
def largest_number(nums):
    if not nums:
        return ""सूची खाली है""
    nums = [str(num) for num in nums]
    nums.sort(reverse=True, key=lambda x: x*3)
    return int(''.join(nums))
```

यह फ़ंक्शन एक सूची को इनपुट के रूप में लेता है और सबसे बड़ी संख्या वापस लौटाता है जो उस सूची के अंकों से बनाई जा सकती है। यह फ़ंक्शन अंकों को स्ट्रिंग्स में परिवर्तित करता है, ताकि वे आपस में जोड़े जा सकें, और फिर उन्हें तीन बार दोहराकर क्रमबद्ध करता है, ताकि उच्चतम संख्या सबसे पहले आए। अंत में, यह फ़ंक्शन सभी स्ट्रिंग्स को एक साथ जोड़ता है और इसे एक पूर्णांक में परिवर्तित करता है।"
Mike's Copy of Benchmark Questions Verification V2.ipynb,58,यह जांचने के लिए एक पायथन फ़ंक्शन लिखें कि दिए गए दो पूर्णांकों में विपरीत चिह्न हैं या नहीं।,"def opposite_Signs(x,y): 
    return ((x ^ y) < 0); ",[],"['assert opposite_Signs(1,-2) == True', 'assert opposite_Signs(3,2) == False', 'assert opposite_Signs(-10,-10) == False', 'assert opposite_Signs(-2,2) == True']","आप निम्नलिखित पायथन फ़ंक्शन का उपयोग कर सकते हैं:

```python
def opposite_signs(a, b):
    return (a < 0 and b > 0) or (a > 0 and b < 0)
```

यह फ़ंक्शन दो पूर्णांकों को इनपुट के रूप में लेता है और यदि वे विपरीत चिह्न हैं, तो यह सत्य लौटाता है, अन्यथा झूठ. यह इसे जांचने के लिए कि क्या एक संख्या शून्य से बड़ी है और दूसरी शून्य से छोटी है, या उल्टा, इसका उपयोग करता है."
Mike's Copy of Benchmark Questions Verification V2.ipynb,59,nवीं अष्टकोणीय संख्या ज्ञात करने के लिए एक फ़ंक्शन लिखें।,"def is_octagonal(n): 
	return 3 * n * n - 2 * n ",[],"['assert is_octagonal(5) == 65', 'assert is_octagonal(10) == 280', 'assert is_octagonal(15) == 645']","आप निम्नलिखित तरीके से एक फ़ंक्शन लिख सकते हैं जो एक दशमलव संख्या को अष्टकोणीय (ऑक्टल) में परिवर्तित करता है:

```python
def decimal_to_octal(n):
    return oct(n)[2:]
```

इस फ़ंक्शन का उपयोग करने के लिए, आप बस इसे निम्नलिखित तरीके से कॉल करें:

```python
print(decimal_to_octal(10))  # Output: 12
```

यह फ़ंक्शन `oct` बिल्ट-इन फ़ंक्शन का उपयोग करता है जो दशमलव संख्या को अष्टकोणीय में परिवर्तित करता है, और फिर `[2:]` का उपयोग करके पहले दो वर्णों ('0o') को हटा देता है जो अष्टकोणीय संख्या की पहचान के लिए होते हैं।"
Mike's Copy of Benchmark Questions Verification V2.ipynb,61,उनकी लंबाई के बराबर अंकों के योग के साथ सबस्ट्रिंग की संख्या गिनने के लिए एक पायथन फ़ंक्शन लिखें।,"from collections import defaultdict
def count_Substrings(s):
    n = len(s)
    count,sum = 0,0
    mp = defaultdict(lambda : 0)
    mp[0] += 1
    for i in range(n):
        sum += ord(s[i]) - ord('0')
        count += mp[sum - (i + 1)]
        mp[sum - (i + 1)] += 1
    return count",[],"[""assert count_Substrings('112112') == 6"", ""assert count_Substrings('111') == 6"", ""assert count_Substrings('1101112') == 12""]","यहां एक पायथन फ़ंक्शन है जो एक स्ट्रिंग को इनपुट के रूप में लेता है और उसकी लंबाई के बराबर अंकों के योग के साथ सबस्ट्रिंग की संख्या गिनती है।

```python
def count_substrings(s):
    count = 0
    for i in range(len(s)):
        for j in range(i + 1, len(s) + 1):
            if sum(int(digit) for digit in s[i:j]) == len(s):
                count += 1
    return count
```

इस फ़ंक्शन का उपयोग निम्नलिखित प्रकार से किया जा सकता है:

```python
print(count_substrings('1234'))  # Output: 1
```

इस उदाहरण में, '1234' स्ट्रिंग की लंबाई 4 है और एकमात्र सबस्ट्रिंग '1234' है जिसके अंकों का योग 10 है, जो स्ट्रिंग की लंबाई से अधिक है, इसलिए उत्तर 1 है।"
Mike's Copy of Benchmark Questions Verification V2.ipynb,62,किसी सूची में सबसे छोटी संख्या खोजने के लिए एक पायथन फ़ंक्शन लिखें।,"def smallest_num(xs):
  return min(xs)
",[],"['assert smallest_num([10, 20, 1, 45, 99]) == 1', 'assert smallest_num([1, 2, 3]) == 1', 'assert smallest_num([45, 46, 50, 60]) == 45']","आप निम्नलिखित तरीके से एक पायथन फ़ंक्शन लिख सकते हैं जो किसी सूची में सबसे छोटी संख्या खोजता है:

```python
def find_smallest_number(lst):
    return min(lst)
```

इस फ़ंक्शन का उपयोग करने के लिए, आपको बस एक सूची पास करनी होगी। उदाहरण के लिए:

```python
numbers = [4, 2, 9, 3, 5, 1, 8, 7, 6]
print(find_smallest_number(numbers))
```

यह 1 प्रिंट करेगा, जो कि सूची में सबसे छोटी संख्या है।"
Mike's Copy of Benchmark Questions Verification V2.ipynb,63,दी गई टपल सूची में उपलब्ध जोड़ियों के बीच अधिकतम अंतर ज्ञात करने के लिए एक फ़ंक्शन लिखें।,"def max_difference(test_list):
  temp = [abs(b - a) for a, b in test_list]
  res = max(temp)
  return (res) ",[],"['assert max_difference([(3, 5), (1, 7), (10, 3), (1, 2)]) == 7', 'assert max_difference([(4, 6), (2, 17), (9, 13), (11, 12)]) == 15', 'assert max_difference([(12, 35), (21, 27), (13, 23), (41, 22)]) == 23']","यहां एक संभावित समाधान है:

```python
def max_difference(tuples_list):
    return max(b - a for a, b in tuples_list)
```

इस फ़ंक्शन का उपयोग करने के लिए, आप इसे निम्नलिखित तरीके से कॉल कर सकते हैं:

```python
print(max_difference([(1, 2), (3, 5), (7, 9)]))  # Output: 2
```

यह फ़ंक्शन एक टपल की सूची लेता है और प्रत्येक टपल में दूसरे और पहले तत्व के बीच का अंतर निकालता है। फिर यह इन अंतरों में से सबसे बड़े को लौटाता है।"
Mike's Copy of Benchmark Questions Verification V2.ipynb,64,प्रत्येक टुपल के दूसरे मान का उपयोग करके टुपल्स की सूची को क्रमबद्ध करने के लिए एक फ़ंक्शन लिखें।,"def subject_marks(subjectmarks):
#subject_marks = [('English', 88), ('Science', 90), ('Maths', 97), ('Social sciences', 82)])
 subjectmarks.sort(key = lambda x: x[1])
 return subjectmarks",[],"[""assert subject_marks([('English', 88), ('Science', 90), ('Maths', 97), ('Social sciences', 82)])==[('Social sciences', 82), ('English', 88), ('Science', 90), ('Maths', 97)]"", ""assert subject_marks([('Telugu',49),('Hindhi',54),('Social',33)])==([('Social',33),('Telugu',49),('Hindhi',54)])"", ""assert subject_marks([('Physics',96),('Chemistry',97),('Biology',45)])==([('Biology',45),('Physics',96),('Chemistry',97)])""]","आप निम्नलिखित फ़ंक्शन का उपयोग कर सकते हैं:

```python
def sort_tuples(tuples):
    return sorted(tuples, key=lambda x: x[1])
```

इस फ़ंक्शन में, `sorted` फ़ंक्शन का उपयोग किया गया है जो एक इतरेबल को क्रमबद्ध करता है। `key` पैरामीटर एक फ़ंक्शन होता है जिसका उपयोग क्रमबद्ध करने के लिए किया जाता है। यहां, हम एक लैम्बडा फ़ंक्शन का उपयोग कर रहे हैं जो दूसरे मान को लौटाता है, जिसका अर्थ है कि टुपल्स को उनके दूसरे मान के आधार पर क्रमबद्ध किया जाएगा।"
Mike's Copy of Benchmark Questions Verification V2.ipynb,65,किसी सूची को समतल करने और उसके सभी तत्वों का योग करने के लिए एक फ़ंक्शन लिखें।,"def recursive_list_sum(data_list):
	total = 0
	for element in data_list:
		if type(element) == type([]):
			total = total + recursive_list_sum(element)
		else:
			total = total + element
	return total",[],"['assert recursive_list_sum(([1, 2, [3,4],[5,6]]))==21', 'assert recursive_list_sum(([7, 10, [15,14],[19,41]]))==106', 'assert recursive_list_sum(([10, 20, [30,40],[50,60]]))==210']","आप निम्नलिखित तरीके से इसे कर सकते हैं:

```python
def flatten_and_sum(lst):
    # एक समतल सूची बनाने के लिए एक रिकर्सिव फ़ंक्शन
    def flatten(lst):
        for i in lst:
            if isinstance(i, list):
                yield from flatten(i)
            else:
                yield i

    # समतल सूची के सभी तत्वों का योग करें
    return sum(flatten(lst))
```

इस फ़ंक्शन का उपयोग करके, आप एक नेस्टेड सूची को समतल कर सकते हैं और सभी तत्वों का योग कर सकते हैं:

```python
lst = [[1, 2, [3, 4]], [5, 6], 7]
print(flatten_and_sum(lst))  # आउटपुट: 28
```"
Mike's Copy of Benchmark Questions Verification V2.ipynb,66,किसी सूची में धनात्मक संख्याओं की संख्या गिनने के लिए एक पायथन फ़ंक्शन लिखें।,"def pos_count(list):
  pos_count= 0
  for num in list: 
    if num >= 0: 
      pos_count += 1
  return pos_count ",[],"['assert pos_count([1,-2,3,-4]) == 2', 'assert pos_count([3,4,5,-1]) == 3', 'assert pos_count([1,2,3,4]) == 4']","आप निम्नलिखित पायथन फ़ंक्शन का उपयोग कर सकते हैं:

```python
def count_positive_numbers(lst):
    return len([num for num in lst if num > 0])
```

इस फ़ंक्शन का उपयोग करने के लिए, आपको बस एक सूची पास करनी होगी जैसे कि:

```python
print(count_positive_numbers([1, -2, 3, -4, 5]))
```

यह उदाहरण 3 प्रिंट करेगा, क्योंकि सूची में तीन धनात्मक संख्याएं हैं: 1, 3, और 5."
Mike's Copy of Benchmark Questions Verification V2.ipynb,67,बेल नंबरों के एक सेट को विभाजित करने के तरीकों की संख्या जानने के लिए एक फ़ंक्शन लिखें।,"def bell_number(n):   
    bell = [[0 for i in range(n+1)] for j in range(n+1)] 
    bell[0][0] = 1
    for i in range(1, n+1): 
        bell[i][0] = bell[i-1][i-1]  
        for j in range(1, i+1): 
            bell[i][j] = bell[i-1][j-1] + bell[i][j-1]   
    return bell[n][0] ",[],"['assert bell_number(2)==2', 'assert bell_number(10)==115975', 'assert bell_number(56)==6775685320645824322581483068371419745979053216268760300']","बेल नंबर एक गणितीय संख्या होती है जिसे एक सेट के विभाजन की संख्या के लिए उपयोग किया जाता है। यहां एक फ़ंक्शन है जो बेल नंबर की गणना करता है:

```python
def bell_number(n):
    bell = [[0 for i in range(n+1)] for j in range(n+1)]
    bell[0][0] = 1
    for i in range(1, n+1):
        bell[i][0] = bell[i-1][i-1]
        for j in range(1, i+1):
            bell[i][j] = bell[i-1][j-1] + bell[i][j-1]
    return bell[n][0]

# उदाहरण के लिए:
print(bell_number(5))  # आउटपुट: 52
```

इस फ़ंक्शन में, `bell[i][j]` बेल नंबर की गणना करता है, जहां `i` सेट के विभाजन की संख्या है और `j` सेट के तत्वों की संख्या है। फ़ंक्शन बेल नंबर की गणना करता है और इसे वापस लौटाता है।"
Mike's Copy of Benchmark Questions Verification V2.ipynb,68,यह जांचने के लिए एक पायथन फ़ंक्शन लिखें कि दिया गया ऐरे मोनोटोनिक है या नहीं।,"def is_Monotonic(A): 
    return (all(A[i] <= A[i + 1] for i in range(len(A) - 1)) or
            all(A[i] >= A[i + 1] for i in range(len(A) - 1))) ",[],"['assert is_Monotonic([6, 5, 4, 4]) == True', 'assert is_Monotonic([1, 2, 2, 3]) == True', 'assert is_Monotonic([1, 3, 2]) == False']","मोनोटोनिक ऐरे वह होता है जो या तो पूरी तरह से बढ़ता हो या पूरी तरह से घटता हो। यहां एक पायथन फ़ंक्शन है जो जांचता है कि क्या दिया गया ऐरे मोनोटोनिक है या नहीं:

```python
def isMonotonic(array):
    if len(array) < 2:
        return True

    direction = array[1] - array[0]
    for i in range(2, len(array)):
        if direction == 0:
            direction = array[i] - array[i - 1]
            continue
        if breaksDirection(direction, array[i - 1], array[i]):
            return False

    return True

def breaksDirection(direction, previousInt, currentInt):
    difference = currentInt - previousInt
    if direction > 0:
        return difference < 0
    return difference > 0
```

इस फ़ंक्शन का उपयोग निम्नलिखित तरीके से किया जा सकता है:

```python
print(isMonotonic([1, 2, 3, 4]))  # यह True प्रिंट करेगा
print(isMonotonic([4, 3, 2, 1]))  # यह भी True प्रिंट करेगा
print(isMonotonic([1, 2, 3, 2]))  # यह False प्रिंट करेगा
```"
Mike's Copy of Benchmark Questions Verification V2.ipynb,69,यह जांचने के लिए एक फ़ंक्शन लिखें कि किसी सूची में दी गई उपसूची शामिल है या नहीं।,"def is_sublist(l, s):
	sub_set = False
	if s == []:
		sub_set = True
	elif s == l:
		sub_set = True
	elif len(s) > len(l):
		sub_set = False
	else:
		for i in range(len(l)):
			if l[i] == s[0]:
				n = 1
				while (n < len(s)) and (l[i+n] == s[n]):
					n += 1				
				if n == len(s):
					sub_set = True
	return sub_set",[],"['assert is_sublist([2,4,3,5,7],[3,7])==False', 'assert is_sublist([2,4,3,5,7],[4,3])==True', 'assert is_sublist([2,4,3,5,7],[1,6])==False']","आप निम्नलिखित फ़ंक्शन का उपयोग कर सकते हैं:

```python
def is_sublist(list1, sublist):
    length = len(sublist)
    for i in range(len(list1)):
        if list1[i:i+length] == sublist:
            return True
    return False
```

इस फ़ंक्शन का उपयोग करने के लिए, आप बड़ी सूची और उपसूची दोनों को इसके पैरामीटर के रूप में पास करें। यदि उपसूची बड़ी सूची में मौजूद है, तो यह True लौटाएगा, अन्यथा False।"
Mike's Copy of Benchmark Questions Verification V2.ipynb,70,यह पता लगाने के लिए एक फ़ंक्शन लिखें कि दिए गए सभी टुपल्स की लंबाई समान है या नहीं।,"def find_equal_tuple(Input):
  k = 0 if not Input else len(Input[0])
  flag = 1
  for tuple in Input:
    if len(tuple) != k:
      flag = 0
      break
  return flag
def get_equal(Input):
  return find_equal_tuple(Input) == 1",[],"['assert get_equal([(11, 22, 33), (44, 55, 66)]) == True', 'assert get_equal([(1, 2, 3), (4, 5, 6, 7)]) == False', 'assert get_equal([(1, 2), (3, 4)]) == True']","आप निम्नलिखित फ़ंक्शन का उपयोग कर सकते हैं:

```python
def check_equal_length(tuples):
    if len(set(len(t) for t in tuples)) <= 1:
        return True
    else:
        return False
```

यह फ़ंक्शन एक टुपल की सूची को इनपुट के रूप में लेता है और सभी टुपल्स की लंबाई की जांच करता है। यदि सभी टुपल्स की लंबाई समान है, तो यह True लौटाता है, अन्यथा False लौटाता है।"
Mike's Copy of Benchmark Questions Verification V2.ipynb,71,तत्वों की सूची को क्रमबद्ध करने के लिए एक फ़ंक्शन लिखें।,"def comb_sort(nums):
    shrink_fact = 1.3
    gaps = len(nums)
    swapped = True
    i = 0
    while gaps > 1 or swapped:
        gaps = int(float(gaps) / shrink_fact)
        swapped = False
        i = 0
        while gaps + i < len(nums):
            if nums[i] > nums[i+gaps]:
                nums[i], nums[i+gaps] = nums[i+gaps], nums[i]
                swapped = True
            i += 1
    return nums",[],"['assert comb_sort([5, 15, 37, 25, 79]) == [5, 15, 25, 37, 79]', 'assert comb_sort([41, 32, 15, 19, 22]) == [15, 19, 22, 32, 41]', 'assert comb_sort([99, 15, 13, 47]) == [13, 15, 47, 99]']","आप निम्नलिखित तरीके से एक फ़ंक्शन लिख सकते हैं जो एक सूची के तत्वों को क्रमबद्ध करता है:

```python
def sort_elements(list):
    return sorted(list)
```

इस फ़ंक्शन का उपयोग करने के लिए, आप निम्नलिखित तरीके से कॉल कर सकते हैं:

```python
print(sort_elements([5, 2, 3, 1, 4]))
```

यह `[1, 2, 3, 4, 5]` प्रिंट करेगा, जो सूची के तत्वों को आरोही क्रम में है।"
Mike's Copy of Benchmark Questions Verification V2.ipynb,72,यह जांचने के लिए एक पायथन फ़ंक्शन लिखें कि दी गई संख्या को दो वर्गों के अंतर के रूप में दर्शाया जा सकता है या नहीं।,"def dif_Square(n): 
    if (n % 4 != 2): 
        return True
    return False",[],"['assert dif_Square(5) == True', 'assert dif_Square(10) == False', 'assert dif_Square(15) == True']","यहां एक संभावित समाधान है:

```python
def is_difference_of_squares(n):
    i = 0
    while i * i <= n:
        j = int((n - i * i) ** 0.5)
        if i * i + j * j == n:
            return True
        i += 1
    return False
```

यह फ़ंक्शन `is_difference_of_squares(n)` एक पूर्णांक `n` लेता है और यह जांचता है कि क्या इसे दो वर्गों के अंतर के रूप में दर्शाया जा सकता है। यदि हां, तो यह `True` लौटाता है, अन्यथा `False`।

यह फ़ंक्शन एक लूप का उपयोग करता है जो `i` के वर्ग को `n` से घटाता है, और फिर यह जांचता है कि क्या बची हुई संख्या एक पूर्ण वर्ग है। यदि हां, तो `n` दो वर्गों के अंतर के रूप में दर्शाया जा सकता है, और फ़ंक्शन `True` लौटाता है। यदि लूप का अंत हो जाता है और कोई भी पूर्ण वर्ग मिलने के बाद भी `n` दो वर्गों के अंतर के रूप में नहीं दर्शाया जा सकता, तो फ़ंक्शन `False` लौटाता है।"
Mike's Copy of Benchmark Questions Verification V2.ipynb,74,यह जांचने के लिए एक फ़ंक्शन लिखें कि क्या यह पैटर्न सरणी में दिए गए अनुक्रम का पालन करता है।,"def is_samepatterns(colors, patterns):    
    if len(colors) != len(patterns):
        return False    
    sdict = {}
    pset = set()
    sset = set()    
    for i in range(len(patterns)):
        pset.add(patterns[i])
        sset.add(colors[i])
        if patterns[i] not in sdict.keys():
            sdict[patterns[i]] = []

        keys = sdict[patterns[i]]
        keys.append(colors[i])
        sdict[patterns[i]] = keys

    if len(pset) != len(sset):
        return False   

    for values in sdict.values():

        for i in range(len(values) - 1):
            if values[i] != values[i+1]:
                return False

    return True",[],"['assert is_samepatterns([""red"",""green"",""green""], [""a"", ""b"", ""b""])==True', 'assert is_samepatterns([""red"",""green"",""greenn""], [""a"",""b"",""b""])==False', 'assert is_samepatterns([""red"",""green"",""greenn""], [""a"",""b""])==False']","यहां एक फ़ंक्शन है जो एक पैटर्न और एक सरणी को इनपुट के रूप में लेता है और जांचता है कि क्या सरणी उस पैटर्न का पालन करती है या नहीं।

```python
def is_pattern(sequence, pattern):
    if len(sequence) != len(pattern):
        return False

    pattern_dict = {}
    for i in range(len(pattern)):
        if pattern[i] in pattern_dict:
            if pattern_dict[pattern[i]] != sequence[i]:
                return False
        else:
            pattern_dict[pattern[i]] = sequence[i]

    return True
```

इस फ़ंक्शन का उपयोग निम्नलिखित तरीके से किया जा सकता है:

```python
sequence = ['a', 'b', 'b', 'a']
pattern = [1, 2, 2, 1]
print(is_pattern(sequence, pattern))  # यह True प्रिंट करेगा
```

इस उदाहरण में, 'a' को 1 के साथ मैप किया जाता है और 'b' को 2 के साथ, जो पैटर्न का पालन करती है। यदि सरणी पैटर्न का पालन नहीं करती है, तो फ़ंक्शन False लौटाएगा।"
Mike's Copy of Benchmark Questions Verification V2.ipynb,75,टुपल्स को खोजने के लिए एक फ़ंक्शन लिखें जिसमें टुपल्स की दी गई सूची से सभी तत्व k से विभाज्य हों।,"def find_tuples(test_list, K):
  res = [sub for sub in test_list if all(ele % K == 0 for ele in sub)]
  return res",[],"['assert find_tuples([(6, 24, 12), (7, 9, 6), (12, 18, 21)], 6) == [(6, 24, 12)]', 'assert find_tuples([(5, 25, 30), (4, 2, 3), (7, 8, 9)], 5) == [(5, 25, 30)]', 'assert find_tuples([(7, 9, 16), (8, 16, 4), (19, 17, 18)], 4) == [(8, 16, 4)]']","आप निम्नलिखित फ़ंक्शन का उपयोग कर सकते हैं:

```python
def find_divisible_by_k(tuples_list, k):
    return [t for t in tuples_list if t[0] % k == 0 and t[1] % k == 0]
```

यह फ़ंक्शन एक सूची का परीक्षण करता है और केवल वे टुपल लौटाता है जिनके सभी तत्व k से विभाज्य हैं। यह मानता है कि सभी टुपल्स में दो तत्व हैं। यदि आपके टुपल्स में अधिक तत्व हैं, तो आपको इस फ़ंक्शन को अनुकूलित करने की आवश्यकता हो सकती है।"
Mike's Copy of Benchmark Questions Verification V2.ipynb,77,कोई संख्या 11 से विभाज्य है या नहीं यह जानने के लिए एक पायथन फ़ंक्शन लिखें।,"def is_Diff(n): 
    return (n % 11 == 0) ",[],"['assert is_Diff (12345) == False', 'assert is_Diff(1212112) == True', 'assert is_Diff(1212) == False']","आप निम्नलिखित पायथन फ़ंक्शन का उपयोग कर सकते हैं:

```python
def is_divisible_by_11(n):
    if n % 11 == 0:
        return True
    else:
        return False
```

इस फ़ंक्शन का उपयोग करने के लिए, आपको बस जांचने के लिए संख्या पास करनी होगी। यदि संख्या 11 से विभाज्य है, तो यह True लौटेगा, अन्यथा False।

उदाहरण:

```python
print(is_divisible_by_11(22))  # यह True प्रिंट करेगा
print(is_divisible_by_11(23))  # यह False प्रिंट करेगा
```"
Mike's Copy of Benchmark Questions Verification V2.ipynb,79,यह जांचने के लिए एक पायथन फ़ंक्शन लिखें कि शब्द की लंबाई विषम है या नहीं।,"def word_len(s): 
    s = s.split(' ')   
    for word in s:    
        if len(word)%2!=0: 
            return True  
        else:
          return False",[],"['assert word_len(""Hadoop"") == False', 'assert word_len(""great"") == True', 'assert word_len(""structure"") == True']","आप निम्नलिखित पायथन फ़ंक्शन का उपयोग कर सकते हैं:

```python
def is_length_odd(word):
    return len(word) % 2 != 0
```

यह फ़ंक्शन एक शब्द को इनपुट के रूप में लेता है और शब्द की लंबाई को 2 से विभाजित करता है। यदि शेषफल 0 नहीं है, तो यह शब्द की लंबाई विषम है, और फ़ंक्शन True लौटाता है। यदि शेषफल 0 है, तो शब्द की लंबाई सम है, और फ़ंक्शन False लौटाता है।"
Mike's Copy of Benchmark Questions Verification V2.ipynb,80,nवीं चतुष्फलकीय संख्या ज्ञात करने के लिए एक फ़ंक्शन लिखें।,"def tetrahedral_number(n): 
	return (n * (n + 1) * (n + 2)) / 6",[],"['assert tetrahedral_number(5) == 35', 'assert tetrahedral_number(6) == 56', 'assert tetrahedral_number(7) == 84']","चतुष्फलकीय संख्या एक संख्या का चौथा घात होता है। इसे निम्नलिखित तरीके से ज्ञात किया जा सकता है:

```python
def chatushphalakiya(n):
    return n**4
```

इस फ़ंक्शन का उपयोग करके, आप किसी भी संख्या की चतुष्फलकीय संख्या ज्ञात कर सकते हैं। उदाहरण के लिए, `chatushphalakiya(2)` का परिणाम `16` होगा, क्योंकि 2 का चौथा घात 16 होता है।"
Mike's Copy of Benchmark Questions Verification V2.ipynb,82,किसी गोले का आयतन ज्ञात करने के लिए एक फ़ंक्शन लिखें।,"import math
def volume_sphere(r):
  volume=(4/3)*math.pi*r*r*r
  return volume",['import math'],"['assert math.isclose(volume_sphere(10), 4188.790204786391, rel_tol=0.001)', 'assert math.isclose(volume_sphere(25), 65449.84694978735, rel_tol=0.001)', 'assert math.isclose(volume_sphere(20), 33510.32163829113, rel_tol=0.001)']","आप निम्नलिखित फ़ंक्शन का उपयोग कर सकते हैं:

```python
import math

def volume_of_sphere(radius):
    return (4/3) * math.pi * (radius**3)
```

इस फ़ंक्शन का उपयोग करने के लिए, आपको केवल गोले का त्रिज्या (रेडियस) पास करना होगा। उदाहरण के लिए:

```python
print(volume_of_sphere(5))
```

यह आउटपुट देगा:

```python
523.5987755982989
```

जो 5 इकाई त्रिज्या वाले गोले का आयतन है।"
Mike's Copy of Benchmark Questions Verification V2.ipynb,83,दिए गए स्ट्रिंग मॉड्यूलो 26 के सभी वर्णों के ASCII मान को जोड़कर बनाए गए वर्ण को खोजने के लिए एक पायथन फ़ंक्शन लिखें।,"def get_Char(strr):  
    summ = 0
    for i in range(len(strr)): 
        summ += (ord(strr[i]) - ord('a') + 1)  
    if (summ % 26 == 0): 
        return ord('z') 
    else: 
        summ = summ % 26
        return chr(ord('a') + summ - 1)",[],"['assert get_Char(""abc"") == ""f""', 'assert get_Char(""gfg"") == ""t""', 'assert get_Char(""ab"") == ""c""']","आप निम्नलिखित तरीके से एक पायथन फ़ंक्शन लिख सकते हैं:

```python
def find_char(string):
    sum_ascii = sum(ord(c) for c in string)
    return chr(sum_ascii % 26 + ord('A'))

# उदाहरण के लिए:
print(find_char('ABC'))  # यह 'C' प्रिंट करेगा
```

इस फ़ंक्शन में, हम पहले इनपुट स्ट्रिंग के सभी वर्णों के ASCII मानों का योग करते हैं। फिर, हम इस योग को 26 से मॉड्यूलो करते हैं, और फिर 'A' के ASCII मान को जोड़ते हैं। इससे हमें एक नया ASCII मान मिलता है, जिसे हम फिर एक वर्ण में परिवर्तित करते हैं।

कृपया ध्यान दें कि यह फ़ंक्शन केवल बड़े अक्षरों के लिए काम करेगा, और यह मानता है कि इनपुट स्ट्रिंग में केवल अक्षर हैं। यदि आपको छोटे अक्षरों या अन्य वर्णों के साथ काम करना है, तो आपको इस फ़ंक्शन को अनुकूलित करना होगा।"
Mike's Copy of Benchmark Questions Verification V2.ipynb,84,न्यूमैन कॉनवे अनुक्रम में nवाँ नंबर खोजने के लिए एक फ़ंक्शन लिखें।,"def sequence(n): 
	if n == 1 or n == 2: 
		return 1
	else: 
		return sequence(sequence(n-1)) + sequence(n-sequence(n-1))",[],"['assert sequence(10) == 6', 'assert sequence(2) == 1', 'assert sequence(3) == 2']","न्यूमैन कॉनवे अनुक्रम एक अनुक्रम है जिसमें प्रत्येक संख्या को उसके अंकों की संख्या से गुणा किया जाता है। यह अनुक्रम 1 से शुरू होता है और हर बार अगली संख्या को उसके अंकों की संख्या से गुणा करके प्राप्त किया जाता है।

यहां एक पायथन फ़ंक्शन है जो न्यूमैन कॉनवे अनुक्रम में nवाँ नंबर खोजता है:

```python
def newman_conway(n):
    if n == 1:
        return 1
    elif n == 2:
        return 1
    else:
        p = [0, 1, 1]
        for i in range(3, n + 1):
            p.append(p[p[i - 1]] + p[i - p[i - 1]])
        return p[n]
```

इस फ़ंक्शन का उपयोग करने के लिए, आपको बस न्यूमैन कॉनवे अनुक्रम में जिस नंबर को खोजना है, उसे फ़ंक्शन के आर्गुमेंट के रूप में पास करना होगा। उदाहरण के लिए, `newman_conway(5)` का आउटपुट `3` होगा, क्योंकि 5वाँ नंबर न्यूमैन कॉनवे अनुक्रम में `3` है।"
Mike's Copy of Benchmark Questions Verification V2.ipynb,85,किसी गोले का पृष्ठीय क्षेत्रफल ज्ञात करने के लिए एक फ़ंक्शन लिखें।,"import math
def surfacearea_sphere(r):
  surfacearea=4*math.pi*r*r
  return surfacearea",['import math'],"['assert math.isclose(surfacearea_sphere(10), 1256.6370614359173, rel_tol=0.001)', 'assert math.isclose(surfacearea_sphere(15), 2827.4333882308138, rel_tol=0.001)', 'assert math.isclose(surfacearea_sphere(20), 5026.548245743669, rel_tol=0.001)']","गोले का पृष्ठीय क्षेत्रफल निम्न सूत्र से ज्ञात किया जा सकता है:

A = 4πr^2

जहां r गोले का त्रिज्या है। इसे पायथन में फ़ंक्शन के रूप में लिखा जा सकता है:

```python
import math

def sphere_surface_area(radius):
    return 4 * math.pi * radius ** 2
```

इस फ़ंक्शन का उपयोग करके, आप किसी भी गोले के त्रिज्या के आधार पर उसका पृष्ठीय क्षेत्रफल ज्ञात कर सकते हैं। उदाहरण के लिए:

```python
print(sphere_surface_area(5))  # Outputs: 314.1592653589793
```"
Mike's Copy of Benchmark Questions Verification V2.ipynb,86,nवें केन्द्रित षट्कोणीय संख्या ज्ञात करने के लिए एक फ़ंक्शन लिखें।,"def centered_hexagonal_number(n):
  return 3 * n * (n - 1) + 1",[],"['assert centered_hexagonal_number(10) == 271', 'assert centered_hexagonal_number(2) == 7', 'assert centered_hexagonal_number(9) == 217']","षट्कोणीय संख्याएं एक श्रृंखला होती हैं जिसमें प्रत्येक संख्या उसके पूर्ववर्ती संख्या से 6 अधिक होती है। यह श्रृंखला 1 से शुरू होती है। इसलिए, nवें केन्द्रित षट्कोणीय संख्या का सूत्र होता है 1 + n * (n - 1) * 3।

यहां एक पायथन फ़ंक्शन है जो इसे गणना करता है:

```python
def centered_hexagonal(n):
    return 1 + n * (n - 1) * 3
```

उदाहरण के लिए, centered_hexagonal(3) का परिणाम 19 होगा, क्योंकि 1 + 3 * (3 - 1) * 3 = 19।"
Mike's Copy of Benchmark Questions Verification V2.ipynb,87,तीन शब्दकोशों को एक शब्दकोश में मिलाने के लिए एक फ़ंक्शन लिखें।,"import collections as ct
def merge_dictionaries_three(dict1,dict2, dict3):
    merged_dict = dict(ct.ChainMap({},dict1,dict2,dict3))
    return merged_dict",[],"['assert merge_dictionaries_three({ ""R"": ""Red"", ""B"": ""Black"", ""P"": ""Pink"" }, { ""G"": ""Green"", ""W"": ""White"" },{ ""O"": ""Orange"", ""W"": ""White"", ""B"": ""Black"" })=={\'B\': \'Black\', \'R\': \'Red\', \'P\': \'Pink\', \'G\': \'Green\', \'W\': \'White\', \'O\': \'Orange\'}', 'assert merge_dictionaries_three({ ""R"": ""Red"", ""B"": ""Black"", ""P"": ""Pink"" }, { ""G"": ""Green"", ""W"": ""White"" },{""L"":""lavender"",""B"":""Blue""})=={\'W\': \'White\', \'P\': \'Pink\', \'B\': \'Black\', \'R\': \'Red\', \'G\': \'Green\', \'L\': \'lavender\'}', 'assert merge_dictionaries_three({ ""R"": ""Red"", ""B"": ""Black"", ""P"": ""Pink"" },{""L"":""lavender"",""B"":""Blue""},{ ""G"": ""Green"", ""W"": ""White"" })=={\'B\': \'Black\', \'P\': \'Pink\', \'R\': \'Red\', \'G\': \'Green\', \'L\': \'lavender\', \'W\': \'White\'}']","आप निम्नलिखित फ़ंक्शन का उपयोग कर सकते हैं:

```python
def merge_dictionaries(dict1, dict2, dict3):
    merged_dict = {**dict1, **dict2, **dict3}
    return merged_dict
```

इस फ़ंक्शन का उपयोग करने के लिए, आपको बस तीन शब्दकोशों को इसके आर्गुमेंट के रूप में पास करना होगा। यह फ़ंक्शन तीनों शब्दकोशों को मिलाकर एक नया शब्दकोश लौटाएगा।

उदाहरण के लिए:

```python
dict1 = {""a"": 1, ""b"": 2}
dict2 = {""c"": 3, ""d"": 4}
dict3 = {""e"": 5, ""f"": 6}

merged_dict = merge_dictionaries(dict1, dict2, dict3)
print(merged_dict)  # Output: {'a': 1, 'b': 2, 'c': 3, 'd': 4, 'e': 5, 'f': 6}
```"
Mike's Copy of Benchmark Questions Verification V2.ipynb,88,"किसी सूची में सभी तत्वों की आवृत्ति प्राप्त करने के लिए एक फ़ंक्शन लिखें, जो एक शब्दकोश के रूप में लौटाया गया है।","import collections
def freq_count(list1):
  freq_count= collections.Counter(list1)
  return freq_count",[],"['assert freq_count([10,10,10,10,20,20,20,20,40,40,50,50,30])==({10: 4, 20: 4, 40: 2, 50: 2, 30: 1})', 'assert freq_count([1,2,3,4,3,2,4,1,3,1,4])==({1:3, 2:2,3:3,4:3})', 'assert freq_count([5,6,7,4,9,10,4,5,6,7,9,5])==({10:1,5:3,6:2,7:2,4:2,9:2})']","आप collections मॉड्यूल का उपयोग करके इसे कर सकते हैं। यहां एक उदाहरण है:

```python
from collections import Counter

def count_elements(lst):
    return dict(Counter(lst))
```

इस फ़ंक्शन का उपयोग करने के लिए, आप बस इसे एक सूची के साथ कॉल करें:

```python
print(count_elements(['apple', 'banana', 'apple', 'orange', 'banana', 'banana']))
```

यह आउटपुट देगा:

```python
{'apple': 2, 'banana': 3, 'orange': 1}
```

जो दर्शाता है कि 'apple' 2 बार, 'banana' 3 बार, और 'orange' 1 बार सूची में है।"
Mike's Copy of Benchmark Questions Verification V2.ipynb,89,n से निकटतम छोटी संख्या ज्ञात करने के लिए एक फ़ंक्शन लिखें।,"def closest_num(N):
  return (N - 1)",[],"['assert closest_num(11) == 10', 'assert closest_num(7) == 6', 'assert closest_num(12) == 11']","आप निम्नलिखित फ़ंक्शन का उपयोग कर सकते हैं:

```python
def nearest_smaller(n):
    return n - 1
```

यह फ़ंक्शन दिए गए नंबर `n` से एक कम नंबर देगा, जो `n` से निकटतम छोटी संख्या होगी।"
Mike's Copy of Benchmark Questions Verification V2.ipynb,90,सबसे लंबे शब्द की लंबाई ज्ञात करने के लिए एक पायथन फ़ंक्शन लिखें।,"def len_log(list1):
    max=len(list1[0])
    for i in list1:
        if len(i)>max:
            max=len(i)
    return max",[],"['assert len_log([""python"",""PHP"",""bigdata""]) == 7', 'assert len_log([""a"",""ab"",""abc""]) == 3', 'assert len_log([""small"",""big"",""tall""]) == 5']","यहां एक सरल पायथन फ़ंक्शन है जो एक शब्दों की सूची लेता है और सबसे लंबे शब्द की लंबाई देता है:

```python
def longest_word_length(word_list):
    return max(len(word) for word in word_list)
```

इस फ़ंक्शन का उपयोग करने के लिए, आप एक शब्दों की सूची पास करें:

```python
words = [""apple"", ""banana"", ""cherry"", ""date""]
print(longest_word_length(words))  # Outputs: 6
```

यह उदाहरण ""banana"" शब्द की लंबाई 6 को प्रिंट करेगा, जो कि सूची में सबसे लंबा है।"
Mike's Copy of Benchmark Questions Verification V2.ipynb,91,यह जांचने के लिए एक फ़ंक्शन लिखें कि स्ट्रिंग मानों की दी गई सूची में एक स्ट्रिंग सबस्ट्रिंग के रूप में मौजूद है या नहीं।,"def find_substring(str1, sub_str):
   if any(sub_str in s for s in str1):
       return True
   return False",[],"['assert find_substring([""red"", ""black"", ""white"", ""green"", ""orange""],""ack"")==True', 'assert find_substring([""red"", ""black"", ""white"", ""green"", ""orange""],""abc"")==False', 'assert find_substring([""red"", ""black"", ""white"", ""green"", ""orange""],""ange"")==True']","आप निम्नलिखित फ़ंक्शन का उपयोग कर सकते हैं:

```python
def check_substring(string_list, substring):
    for string in string_list:
        if substring in string:
            return True
    return False
```

इस फ़ंक्शन का उपयोग करने के लिए, आपको एक स्ट्रिंग की सूची और एक सबस्ट्रिंग पास करना होगा। यदि सबस्ट्रिंग किसी भी स्ट्रिंग में मौजूद होती है, तो यह True लौटाएगा, अन्यथा False।"
Mike's Copy of Benchmark Questions Verification V2.ipynb,92,यह जांचने के लिए एक फ़ंक्शन लिखें कि दी गई संख्या लहरदार है या नहीं।,"def is_undulating(n): 
	n = str(n)
	if (len(n) <= 2): 
		return False
	for i in range(2, len(n)): 
		if (n[i - 2] != n[i]): 
			return False
	return True",[],"['assert is_undulating(1212121) == True', 'assert is_undulating(1991) == False', 'assert is_undulating(121) == True']","लहरदार संख्या वह होती है जिसमें अंक बढ़ते और घटते क्रम में होते हैं। उदाहरण के लिए, 1232 और 131 लहरदार संख्याएं हैं, जबकि 122 और 133 ऐसी नहीं हैं।

यहां एक फ़ंक्शन है जो यह जांचता है कि क्या एक संख्या लहरदार है या नहीं:

```python
def is_wave(n):
    n = str(n)
    return all((int(n[i]) < int(n[i+1]) if i%2 == 0 else int(n[i]) > int(n[i+1])) for i in range(len(n)-1))
```

इस फ़ंक्शन का उपयोग करने के लिए, आप बस इसे एक संख्या के साथ कॉल करें:

```python
print(is_wave(1232))  # यह True प्रिंट करेगा
print(is_wave(122))   # यह False प्रिंट करेगा
```"
Mike's Copy of Benchmark Questions Verification V2.ipynb,93,&#39;ए&#39; की घात &#39;बी&#39; के मान की गणना करने के लिए एक फ़ंक्शन लिखें।,"def power(a,b):
	if b==0:
		return 1
	elif a==0:
		return 0
	elif b==1:
		return a
	else:
		return a*power(a,b-1)",[],"['assert power(3,4) == 81', 'assert power(2,3) == 8', 'assert power(5,5) == 3125']","आप निम्नलिखित तरीके से एक फ़ंक्शन लिख सकते हैं:

```python
def calculate_power(a, b):
    return a ** b
```

इस फ़ंक्शन का उपयोग करके, आप 'ए' की 'बी' घात की गणना कर सकते हैं। उदाहरण के लिए, `calculate_power(2, 3)` वापस देगा `8` क्योंकि 2 की घात 3 होती है 8।"
Mike's Copy of Benchmark Questions Verification V2.ipynb,94,"टुपल्स की सूची को देखते हुए, एक फ़ंक्शन लिखें जो टुपल का पहला मान सबसे छोटे दूसरे मान के साथ लौटाता है।","from operator import itemgetter 
def index_minimum(test_list):
  res = min(test_list, key = itemgetter(1))[0]
  return (res) ",[],"[""assert index_minimum([('Rash', 143), ('Manjeet', 200), ('Varsha', 100)]) == 'Varsha'"", ""assert index_minimum([('Yash', 185), ('Dawood', 125), ('Sanya', 175)]) == 'Dawood'"", ""assert index_minimum([('Sai', 345), ('Salman', 145), ('Ayesha', 96)]) == 'Ayesha'""]","आप निम्नलिखित फ़ंक्शन का उपयोग कर सकते हैं:

```python
def smallest_second(tuple_list):
    tuple_list.sort(key = lambda x: x[1])
    return tuple_list[0]
```

यह फ़ंक्शन एक सूची का इनपुट लेता है जिसमें टुपल होते हैं, और उन्हें दूसरे मान के आधार पर सॉर्ट करता है। फिर यह फ़ंक्शन सबसे छोटे दूसरे मान वाले टुपल को वापस करता है।

उदाहरण के लिए, यदि आपके पास निम्नलिखित सूची होती:

```python
tuples = [(4, 9), (1, 3), (5, 1), (3, 2)]
```

और आप फ़ंक्शन को इस तरह कॉल करते:

```python
print(smallest_second(tuples))
```

यह `(5, 1)` आउटपुट देगा, क्योंकि `1` इस सूची में सबसे छोटा दूसरा मान है।"
Mike's Copy of Benchmark Questions Verification V2.ipynb,95,सूचियों की सूची में सबसे छोटी सूची की लंबाई ज्ञात करने के लिए एक पायथन फ़ंक्शन लिखें।,"def Find_Min_Length(lst):  
    minLength = min(len(x) for x in lst )
    return minLength ",[],"['assert Find_Min_Length([[1],[1,2]]) == 1', 'assert Find_Min_Length([[1,2],[1,2,3],[1,2,3,4]]) == 2', 'assert Find_Min_Length([[3,3,3],[4,4,4,4]]) == 3']","आप निम्नलिखित पायथन फ़ंक्शन का उपयोग कर सकते हैं:

```python
def smallest_list_length(list_of_lists):
    return min(len(lst) for lst in list_of_lists)
```

इस फ़ंक्शन का उपयोग करने के लिए, आपको बस एक सूची की सूची पास करनी होगी, और यह सबसे छोटी सूची की लंबाई लौटाएगा। उदाहरण के लिए:

```python
print(smallest_list_length([[1, 2, 3], [4, 5], [6], [7, 8, 9, 10]]))  # Output: 1
```

इस उदाहरण में, सबसे छोटी सूची `[6]` है, जिसकी लंबाई 1 है, इसलिए फ़ंक्शन 1 लौटाता है।"
Mike's Copy of Benchmark Questions Verification V2.ipynb,96,किसी दिए गए पूर्णांक के विभाजकों की संख्या ज्ञात करने के लिए एक पायथन फ़ंक्शन लिखें।,"def divisor(n):
  for i in range(n):
    x = len([i for i in range(1,n+1) if not n % i])
  return x",[],"['assert divisor(15) == 4', 'assert divisor(12) == 6', 'assert divisor(9) == 3']","यहां एक सरल पायथन फ़ंक्शन है जो किसी दिए गए पूर्णांक के विभाजकों की संख्या ज्ञात करता है:

```python
def count_divisors(n):
    count = 0
    for i in range(1, n+1):
        if n % i == 0:
            count += 1
    return count
```

इस फ़ंक्शन का उपयोग करने के लिए, आपको बस विभाजकों की संख्या ज्ञात करने के लिए पूर्णांक पास करना होगा। उदाहरण के लिए:

```python
print(count_divisors(10))  # Output: 4
print(count_divisors(12))  # Output: 6
```

यह फ़ंक्शन 1 से शुरू होता है और दिए गए पूर्णांक तक चलता है, हर बार जब वह पूर्णांक को विभाज्य होता है, तो वह गिनती बढ़ाता है। फ़ंक्शन के अंत में, यह विभाजकों की कुल संख्या लौटाता है।"
Mike's Copy of Benchmark Questions Verification V2.ipynb,97,शब्दकोश में लौटाई गई सूचियों की एक चपटी सूची में प्रत्येक तत्व की आवृत्ति खोजने के लिए एक फ़ंक्शन लिखें।,"def frequency_lists(list1):
    list1 = [item for sublist in list1 for item in sublist]
    dic_data = {}
    for num in list1:
        if num in dic_data.keys():
            dic_data[num] += 1
        else:
            key = num
            value = 1
            dic_data[key] = value
    return dic_data
",[],"['assert frequency_lists([[1, 2, 3, 2], [4, 5, 6, 2], [7, 8, 9, 5]])=={1: 1, 2: 3, 3: 1, 4: 1, 5: 2, 6: 1, 7: 1, 8: 1, 9: 1}', 'assert frequency_lists([[1,2,3,4],[5,6,7,8],[9,10,11,12]])=={1: 1, 2: 1, 3: 1, 4: 1, 5: 1, 6: 1, 7: 1, 8: 1, 9: 1,10:1,11:1,12:1}', 'assert frequency_lists([[20,30,40,17],[18,16,14,13],[10,20,30,40]])=={20:2,30:2,40:2,17: 1,18:1, 16: 1,14: 1,13: 1, 10: 1}']","आप निम्नलिखित तरीके से एक फ़ंक्शन लिख सकते हैं:

```python
def count_elements_in_list(dict_list):
    flat_list = [item for sublist in dict_list.values() for item in sublist]
    element_count = {i: flat_list.count(i) for i in flat_list}
    return element_count
```

इस फ़ंक्शन का उपयोग निम्नलिखित तरीके से किया जा सकता है:

```python
dict_list = {'list1': ['apple', 'banana', 'cherry'], 'list2': ['banana', 'cherry', 'apple', 'apple']}
print(count_elements_in_list(dict_list))
```

यह आउटपुट देगा:

```python
{'apple': 3, 'banana': 2, 'cherry': 2}
```

यह फ़ंक्शन पहले शब्दकोश में सभी सूचियों को एक साथ मिलाता है, फिर प्रत्येक तत्व की गणना करता है और उसकी गणना का परिणाम देता है।"
Mike's Copy of Benchmark Questions Verification V2.ipynb,98,किसी सूची की सभी संख्याओं को गुणा करने और सूची की लंबाई से विभाजित करने के लिए एक फ़ंक्शन लिखें।,"def multiply_num(numbers):  
    total = 1
    for x in numbers:
        total *= x  
    return total/len(numbers) ",['import math'],"['assert math.isclose(multiply_num((8, 2, 3, -1, 7)), -67.2, rel_tol=0.001)', 'assert math.isclose(multiply_num((-10,-20,-30)), -2000.0, rel_tol=0.001)', 'assert math.isclose(multiply_num((19,15,18)), 1710.0, rel_tol=0.001)']","आप नीचे दिए गए कोड का उपयोग कर सकते हैं:

```python
from functools import reduce

def multiply_and_divide(numbers):
    product = reduce((lambda x, y: x * y), numbers)
    return product / len(numbers)
```

इस फ़ंक्शन का उपयोग करने के लिए, आप एक सूची के रूप में संख्याओं को पास कर सकते हैं:

```python
numbers = [1, 2, 3, 4, 5]
result = multiply_and_divide(numbers)
print(result)
```

यह सभी संख्याओं को गुणा करेगा और फिर सूची की लंबाई से विभाजित करेगा।"
Mike's Copy of Benchmark Questions Verification V2.ipynb,99,"दी गई दशमलव संख्या को उसके बाइनरी समकक्ष में बदलने के लिए एक फ़ंक्शन लिखें, जिसे बिना किसी अग्रणी शून्य वाली स्ट्रिंग के रूप में दर्शाया जाए।","def decimal_to_binary(n): 
    return bin(n).replace(""0b"","""") ",[],"[""assert decimal_to_binary(8) == '1000'"", ""assert decimal_to_binary(18) == '10010'"", ""assert decimal_to_binary(7) == '111'""]","आप निम्नलिखित फ़ंक्शन का उपयोग कर सकते हैं:

```python
def decimal_to_binary(n):
    return bin(n).replace(""0b"", """")
```

इस फ़ंक्शन का उपयोग करने के लिए, आपको केवल दशमलव संख्या पास करनी होगी। उदाहरण के लिए:

```python
print(decimal_to_binary(10))  # Output: 1010
```

यह फ़ंक्शन `bin` फ़ंक्शन का उपयोग करता है जो दशमलव संख्या को बाइनरी में बदलता है, और फिर ""0b"" को हटा देता है जो बाइनरी संख्या की पहचान है।"
Mike's Copy of Benchmark Questions Verification V2.ipynb,100,"किसी निर्दिष्ट पूर्णांक के अगले सबसे छोटे पैलिंड्रोम को खोजने के लिए एक फ़ंक्शन लिखें, जो पूर्णांक के रूप में लौटाया गया हो।","import sys
def next_smallest_palindrome(num):
    numstr = str(num)
    for i in range(num+1,sys.maxsize):
        if str(i) == str(i)[::-1]:
            return i",[],"['assert next_smallest_palindrome(99)==101', 'assert next_smallest_palindrome(1221)==1331', 'assert next_smallest_palindrome(120)==121']","पैलिंड्रोम एक ऐसी संख्या होती है जो उल्टी और सीधी दोनों ओर से एक समान होती है। निम्नलिखित फ़ंक्शन एक पूर्णांक को इनपुट के रूप में लेता है और उसके बाद का सबसे छोटा पैलिंड्रोम पूर्णांक लौटाता है।

```python
def next_palindrome(n):
    while True:
        n += 1
        if str(n) == str(n)[::-1]:  # Check if the number is a palindrome
            return n

print(next_palindrome(123))
```

इस फ़ंक्शन का उपयोग करके, आप किसी भी पूर्णांक के लिए अगला पैलिंड्रोम पूर्णांक प्राप्त कर सकते हैं। उदाहरण के लिए, `next_palindrome(123)` का परिणाम `131` होगा, जो 123 के बाद का पहला पैलिंड्रोम पूर्णांक है।"
Mike's Copy of Benchmark Questions Verification V2.ipynb,101,1-आधारित अनुक्रमणिका का उपयोग करके दिए गए सरणी में kवें तत्व को खोजने के लिए एक फ़ंक्शन लिखें।,"def kth_element(arr, k):
  n = len(arr)
  for i in range(n):
    for j in range(0, n-i-1):
      if arr[j] > arr[j+1]:
        arr[j], arr[j+1] == arr[j+1], arr[j]
  return arr[k-1]",[],"['assert kth_element([12,3,5,7,19], 2) == 3', 'assert kth_element([17,24,8,23], 3) == 8', 'assert kth_element([16,21,25,36,4], 4) == 36']","आप निम्नलिखित तरीके से एक फ़ंक्शन लिख सकते हैं:

```python
def find_kth_element(arr, k):
    if k <= len(arr):
        return arr[k-1]
    else:
        return ""Index out of range""

# उदाहरण के लिए
arr = [1, 2, 3, 4, 5]
k = 3
print(find_kth_element(arr, k))  # यह 3 प्रिंट करेगा
```

इस फ़ंक्शन में, हम यह सुनिश्चित कर रहे हैं कि k तत्व सूची की लंबाई से कम या बराबर है। यदि ऐसा है, तो हम सूची के k-1 तत्व को लौटा रहे हैं (क्योंकि सूचियाँ 0 से शुरू होती हैं)। यदि k सूची की लंबाई से अधिक है, तो हम ""Index out of range"" संदेश लौटा रहे हैं।"
Mike's Copy of Benchmark Questions Verification V2.ipynb,102,साँप केस स्ट्रिंग को ऊँट केस स्ट्रिंग में बदलने के लिए एक फ़ंक्शन लिखें।,"def snake_to_camel(word):
        import re
        return ''.join(x.capitalize() or '_' for x in word.split('_'))",[],"[""assert snake_to_camel('python_program')=='PythonProgram'"", ""assert snake_to_camel('python_language')==('PythonLanguage')"", ""assert snake_to_camel('programming_language')==('ProgrammingLanguage')""]","आप निम्नलिखित तरीके से साँप केस स्ट्रिंग को ऊँट केस स्ट्रिंग में बदल सकते हैं:

```python
def snake_to_camel(snake_str):
    components = snake_str.split('_')
    return components[0] + ''.join(x.title() for x in components[1:])
```

इस फ़ंक्शन का उपयोग करने के लिए, आप निम्नलिखित तरीके से कर सकते हैं:

```python
print(snake_to_camel('hello_world'))  # Output: helloWorld
```

यह फ़ंक्शन '_' से विभाजित सभी शब्दों को खोजता है, पहले शब्द को छोड़कर बाकी सभी शब्दों का पहला अक्षर बड़ा करता है, और फिर उन सभी को एक साथ जोड़ता है।"
Mike's Copy of Benchmark Questions Verification V2.ipynb,103,"यूलेरियन संख्या a(n, m) ज्ञात करने के लिए एक फ़ंक्शन लिखें।","def eulerian_num(n, m): 
	if (m >= n or n == 0): 
		return 0 
	if (m == 0): 
		return 1 
	return ((n - m) * eulerian_num(n - 1, m - 1) +(m + 1) * eulerian_num(n - 1, m))",[],"['assert eulerian_num(3, 1) == 4', 'assert eulerian_num(4, 1) == 11', 'assert eulerian_num(5, 3) == 26']","यूलेरियन संख्या की गणना करने के लिए, हमें एक दोहराव वाले फ़ंक्शन की आवश्यकता होती है। यह फ़ंक्शन निम्नलिखित तरीके से परिभाषित किया जा सकता है:

a(n, m) = (n-m) * a(n-1, m-1) + (m+1) * a(n-1, m)

जहां a(0, 0) = 1 और a(n, m) = 0 अगर n < m या n < 0 या m < 0 हो।

यहां एक संभावित पायथन फ़ंक्शन है जो यूलेरियन संख्या की गणना करता है:

```python
def eulerian(n, m):
    if n == 0 and m == 0:
        return 1
    elif n <= 0 or m < 0 or n < m:
        return 0
    else:
        return (n-m) * eulerian(n-1, m-1) + (m+1) * eulerian(n-1, m)
```

इस फ़ंक्शन का उपयोग करके, हम निम्नलिखित तरीके से यूलेरियन संख्या की गणना कर सकते हैं:

```python
print(eulerian(4, 2))  # Output: 11
```"
Mike's Copy of Benchmark Questions Verification V2.ipynb,104,सूचियों की दी गई सूची में स्ट्रिंग्स की प्रत्येक उपसूची को क्रमबद्ध करने के लिए एक फ़ंक्शन लिखें।,"def sort_sublists(input_list):
    result = [sorted(x, key = lambda x:x[0]) for x in input_list] 
    return result
",[],"['assert sort_sublists(([""green"", ""orange""], [""black"", ""white""], [""white"", ""black"", ""orange""]))==[[\'green\', \'orange\'], [\'black\', \'white\'], [\'black\', \'orange\', \'white\']]', 'assert sort_sublists((["" red "",""green"" ],[""blue "","" black""],["" orange"",""brown""]))==[[\' red \', \'green\'], [\' black\', \'blue \'], [\' orange\', \'brown\']]', 'assert sort_sublists(([""zilver"",""gold""], [""magnesium"",""aluminium""], [""steel"", ""bronze""]))==[[\'gold\', \'zilver\'],[\'aluminium\', \'magnesium\'], [\'bronze\', \'steel\']]']","आप निम्नलिखित फ़ंक्शन का उपयोग कर सकते हैं:

```python
def sort_sublists(lst):
    return [sorted(sublist) for sublist in lst]
```

यह फ़ंक्शन `lst` में प्रत्येक उपसूची को क्रमबद्ध करता है। यह एक नई सूची लौटाता है जिसमें प्रत्येक उपसूची क्रमबद्ध होती है।

उदाहरण के लिए:

```python
lst = [['b', 'a', 'c'], ['d', 'f', 'e'], ['h', 'g', 'i']]
print(sort_sublists(lst))
```

आउटपुट:

```python
[['a', 'b', 'c'], ['d', 'e', 'f'], ['g', 'h', 'i']]
```"
Mike's Copy of Benchmark Questions Verification V2.ipynb,105,दी गई सूची में सच्चे बूलियन की गणना करने के लिए एक पायथन फ़ंक्शन लिखें।,"def count(lst):   
    return sum(lst) ",[],"['assert count([True,False,True]) == 2', 'assert count([False,False]) == 0', 'assert count([True,True,True]) == 3']","आप निम्नलिखित तरीके से एक पायथन फ़ंक्शन लिख सकते हैं जो एक सूची में सच्चे बूलियन की गणना करता है:

```python
def count_true_booleans(lst):
    return sum(1 for item in lst if item is True)
```

इस फ़ंक्शन का उपयोग करने के लिए, आप एक सूची पास करेंगे जिसमें बूलियन मान हों:

```python
print(count_true_booleans([True, False, True, True, False]))  # यह 3 प्रिंट करेगा
```

यह फ़ंक्शन `sum` फ़ंक्शन का उपयोग करता है जो एक इटरेबल के सभी मानों का योग करता है। यह फ़ंक्शन एक जनरेटर अभिव्यक्ति का उपयोग करता है जो सूची के प्रत्येक आइटम के लिए चलता है और यदि वह आइटम सच्चा है, तो 1 जोड़ता है।"
Mike's Copy of Benchmark Questions Verification V2.ipynb,106,दी गई सूची को दिए गए टुपल्स में जोड़ने के लिए एक फ़ंक्शन लिखें।,"def add_lists(test_list, test_tup):
  res = tuple(list(test_tup) + test_list)
  return (res) ",[],"['assert add_lists([5, 6, 7], (9, 10)) == (9, 10, 5, 6, 7)', 'assert add_lists([6, 7, 8], (10, 11)) == (10, 11, 6, 7, 8)', 'assert add_lists([7, 8, 9], (11, 12)) == (11, 12, 7, 8, 9)']","आप निम्नलिखित फ़ंक्शन का उपयोग कर सकते हैं:

```python
def add_to_tuple(list, tuple):
    return tuple + tuple(list)
```

इस फ़ंक्शन का उपयोग करने के लिए, आप निम्नलिखित तरीके से कर सकते हैं:

```python
list = [1, 2, 3]
tuple = (4, 5, 6)
new_tuple = add_to_tuple(list, tuple)
print(new_tuple)  # Output: (4, 5, 6, 1, 2, 3)
```

यह फ़ंक्शन सूची को टुपल में परिवर्तित करता है और फिर इसे मूल टुपल से जोड़ता है।"
Mike's Copy of Benchmark Questions Verification V2.ipynb,108,तीन सूचियों को एक एकल क्रमबद्ध सूची में मर्ज करने के लिए एक फ़ंक्शन लिखें।,"import heapq
def merge_sorted_list(num1,num2,num3):
  num1=sorted(num1)
  num2=sorted(num2)
  num3=sorted(num3)
  result = heapq.merge(num1,num2,num3)
  return list(result)",[],"['assert merge_sorted_list([25, 24, 15, 4, 5, 29, 110],[19, 20, 11, 56, 25, 233, 154],[24, 26, 54, 48])==[4, 5, 11, 15, 19, 20, 24, 24, 25, 25, 26, 29, 48, 54, 56, 110, 154, 233]', 'assert merge_sorted_list([1, 3, 5, 6, 8, 9], [2, 5, 7, 11], [1, 4, 7, 8, 12])==[1, 1, 2, 3, 4, 5, 5, 6, 7, 7, 8, 8, 9, 11, 12]', 'assert merge_sorted_list([18, 14, 10, 9, 8, 7, 9, 3, 2, 4, 1],[25, 35, 22, 85, 14, 65, 75, 25, 58],[12, 74, 9, 50, 61, 41])==[1, 2, 3, 4, 7, 8, 9, 9, 9, 10, 12, 14, 14, 18, 22, 25, 25, 35, 41, 50, 58, 61, 65, 74, 75, 85]']","आप निम्नलिखित फ़ंक्शन का उपयोग कर सकते हैं:

```python
def merge_lists(list1, list2, list3):
    return sorted(list1 + list2 + list3)

# उदाहरण के लिए:
list1 = [1, 2, 3]
list2 = [4, 5, 6]
list3 = [7, 8, 9]

print(merge_lists(list1, list2, list3))  # यह [1, 2, 3, 4, 5, 6, 7, 8, 9] प्रिंट करेगा
```

यह फ़ंक्शन `list1`, `list2`, और `list3` को एक साथ जोड़ता है और फिर उन्हें क्रमबद्ध करता है। इसका परिणाम एक एकल क्रमबद्ध सूची होता है जिसमें सभी तीन सूचियों के तत्व होते हैं।"
Mike's Copy of Benchmark Questions Verification V2.ipynb,109,किसी बाइनरी स्ट्रिंग को दी गई संख्या में घुमाते समय विषम मान वाली संख्याओं की संख्या ज्ञात करने के लिए एक पायथन फ़ंक्शन लिखें।,"def odd_Equivalent(s,n): 
    count=0
    for i in range(0,n): 
        if (s[i] == '1'): 
            count = count + 1
    return count ",[],"['assert odd_Equivalent(""011001"",6) == 3', 'assert odd_Equivalent(""11011"",5) == 4', 'assert odd_Equivalent(""1010"",4) == 2']","यहां एक संभावित पायथन फ़ंक्शन है जो आपकी आवश्यकताओं को पूरा कर सकता है। इस फ़ंक्शन का नाम ""count_odd_rotations"" है और यह दो आवश्यक पैरामीटर लेता है: एक बाइनरी स्ट्रिंग (""binary_string"") और एक संख्या (""num_rotations"") जिसमें स्ट्रिंग को घुमाया जाना है।

```python
def count_odd_rotations(binary_string, num_rotations):
    count = 0
    for i in range(num_rotations):
        binary_string = binary_string[-1] + binary_string[:-1]
        if int(binary_string, 2) % 2 != 0:
            count += 1
    return count
```

इस फ़ंक्शन का उपयोग करने के लिए, आपको बस बाइनरी स्ट्रिंग और घुमाने की संख्या पास करनी होगी। उदाहरण के लिए:

```python
print(count_odd_rotations('1011', 5))  # Output: 3
```

इस उदाहरण में, '1011' बाइनरी स्ट्रिंग को 5 बार घुमाया जाता है, और इसके परिणामस्वरूप 3 बार विषम संख्या प्राप्त होती है।"
Mike's Copy of Benchmark Questions Verification V2.ipynb,111,दी गई नेस्टेड सूचियों में सामान्य तत्वों को खोजने के लिए एक फ़ंक्शन लिखें।,"def common_in_nested_lists(nestedlist):
    result = list(set.intersection(*map(set, nestedlist)))
    return result",[],"['assert set(common_in_nested_lists([[12, 18, 23, 25, 45], [7, 12, 18, 24, 28], [1, 5, 8, 12, 15, 16, 18]]))==set([18, 12])', 'assert set(common_in_nested_lists([[12, 5, 23, 25, 45], [7, 11, 5, 23, 28], [1, 5, 8, 18, 23, 16]]))==set([5,23])', 'assert set(common_in_nested_lists([[2, 3,4, 1], [4, 5], [6,4, 8],[4, 5], [6, 8,4]]))==set([4])']","यहां एक फ़ंक्शन है जो नेस्टेड सूचियों में सामान्य तत्वों को खोजता है:

```python
def common_elements(list1, list2):
    result = []
    for list in list1:
        if isinstance(list, list):
            for item in list:
                if item in list2:
                    result.append(item)
        else:
            if list in list2:
                result.append(list)
    return result
```

इस फ़ंक्शन का उपयोग करने के लिए, आप दो सूचियों को इसे पास कर सकते हैं:

```python
list1 = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
list2 = [1, 2, 3, 4, 5, 6, 7, 8, 9]
print(common_elements(list1, list2))
```

यह उन सभी तत्वों की सूची देगा जो दोनों सूचियों में सामान्य हैं।"
Mike's Copy of Benchmark Questions Verification V2.ipynb,113,यह जांचने के लिए एक फ़ंक्शन लिखें कि कोई स्ट्रिंग पूर्णांक का प्रतिनिधित्व करती है या नहीं।,"def check_integer(text):
 text = text.strip()
 if len(text) < 1:
    return None
 else:
     if all(text[i] in ""0123456789"" for i in range(len(text))):
          return True
     elif (text[0] in ""+-"") and \
         all(text[i] in ""0123456789"" for i in range(1,len(text))):
         return True
     else:
        return False",[],"['assert check_integer(""python"")==False', 'assert check_integer(""1"")==True', 'assert check_integer(""12345"")==True']","आप इसे निम्नलिखित तरीके से कर सकते हैं:

```python
def is_integer(n):
    try:
        float(n)
    except ValueError:
        return False
    else:
        return float(n).is_integer()
```

इस फ़ंक्शन का उपयोग करके, आप किसी स्ट्रिंग को एक फ्लोट में परिवर्तित करने का प्रयास करते हैं। यदि यह संभव नहीं है (जैसे कि स्ट्रिंग ""hello""), तो फ़ंक्शन False लौटता है। यदि यह संभव है, तो यह जांचता है कि क्या फ्लोट पूर्णांक है (जैसे, 7.0) या नहीं (जैसे, 7.5). यदि यह पूर्णांक है, तो फ़ंक्शन True लौटता है, अन्यथा False लौटता है।"
Mike's Copy of Benchmark Questions Verification V2.ipynb,115,यह जांचने के लिए एक फ़ंक्शन लिखें कि किसी सूची में सभी शब्दकोश खाली हैं या नहीं।,"def empty_dit(list1):
 empty_dit=all(not d for d in list1)
 return empty_dit",[],"['assert empty_dit([{},{},{}])==True', 'assert empty_dit([{1,2},{},{}])==False', 'assert empty_dit({})==True']","आप निम्नलिखित फ़ंक्शन का उपयोग कर सकते हैं:

```python
def check_empty_dicts(lst):
    return all(not bool(d) for d in lst)
```

यह फ़ंक्शन `all` फ़ंक्शन का उपयोग करके सूची में सभी शब्दकोशों की जांच करता है। `not bool(d)` एक्सप्रेशन तब `True` होता है जब `d` खाली होता है, इसलिए यदि सभी शब्दकोश खाली होते हैं, तो `all` फ़ंक्शन `True` लौटाता है। यदि कम से कम एक शब्दकोश खाली नहीं होता है, तो यह `False` लौटाता है।"
Mike's Copy of Benchmark Questions Verification V2.ipynb,116,धनात्मक पूर्णांकों के दिए गए टुपल को एक पूर्णांक में बदलने के लिए एक फ़ंक्शन लिखें।,"def tuple_to_int(nums):
    result = int(''.join(map(str,nums)))
    return result",[],"['assert tuple_to_int((1,2,3))==123', 'assert tuple_to_int((4,5,6))==456', 'assert tuple_to_int((5,6,7))==567']","आप निम्नलिखित फ़ंक्शन का उपयोग कर सकते हैं:

```python
def tuple_to_int(tup):
    str_num = ''.join(map(str, tup))
    return int(str_num)
```

इस फ़ंक्शन का उपयोग करने के लिए, आप एक टुपल पास करेंगे और यह उसे एक पूर्णांक में बदल देगा। उदाहरण के लिए:

```python
print(tuple_to_int((1, 2, 3, 4, 5)))  # Output: 12345
```"
Mike's Copy of Benchmark Questions Verification V2.ipynb,117,सूचियों की सूची में सभी संभावित परिवर्तनीय तत्वों को फ़्लोट में बदलने के लिए एक फ़ंक्शन लिखें।,"def list_to_float(test_list):
  res = []
  for tup in test_list:
    temp = []
    for ele in tup:
      if ele.isalpha():
        temp.append(ele)
      else:
        temp.append(float(ele))
    res.append((temp[0],temp[1])) 
  return res",[],"['assert list_to_float( [(""3"", ""4""), (""1"", ""26.45""), (""7.32"", ""8""), (""4"", ""8"")] ) == [(3.0, 4.0), (1.0, 26.45), (7.32, 8.0), (4.0, 8.0)]', 'assert list_to_float( [(""4"", ""4""), (""2"", ""27""), (""4.12"", ""9""), (""7"", ""11"")] ) == [(4.0, 4.0), (2.0, 27.0), (4.12, 9.0), (7.0, 11.0)]', 'assert list_to_float( [(""6"", ""78""), (""5"", ""26.45""), (""1.33"", ""4""), (""82"", ""13"")] ) == [(6.0, 78.0), (5.0, 26.45), (1.33, 4.0), (82.0, 13.0)]']","यहां एक फ़ंक्शन है जो एक सूची की सूची को लेता है और सभी संभावित परिवर्तनीय तत्वों को फ़्लोट में बदलता है:

```python
def convert_to_float(list_of_lists):
    for i in range(len(list_of_lists)):
        for j in range(len(list_of_lists[i])):
            try:
                list_of_lists[i][j] = float(list_of_lists[i][j])
            except ValueError:
                pass
    return list_of_lists
```

इस फ़ंक्शन का उपयोग करने के लिए, आपको बस इसे अपनी सूची की सूची के साथ कॉल करना होगा, जैसे कि:

```python
list_of_lists = [['1', '2', '3'], ['4', '5', '6'], ['7', '8', '9']]
converted_list = convert_to_float(list_of_lists)
print(converted_list)
```

यह आउटपुट देगा:

```python
[[1.0, 2.0, 3.0], [4.0, 5.0, 6.0], [7.0, 8.0, 9.0]]
```

यह फ़ंक्शन `ValueError` को ध्यान में रखता है, जो तब उत्पन्न होता है जब एक मूल्य को फ़्लोट में बदलने का प्रयास किया जाता है जो फ़्लोट में बदला नहीं जा सकता (जैसे कि एक स्ट्रिंग)."
Mike's Copy of Benchmark Questions Verification V2.ipynb,118,किसी स्ट्रिंग को स्पेस कैरेक्टर पर विभाजित स्ट्रिंग्स की सूची में बदलने के लिए एक फ़ंक्शन लिखें।,"def string_to_list(string): 
    lst = list(string.split("" "")) 
    return lst",[],"['assert string_to_list(""python programming"")==[\'python\',\'programming\']', 'assert string_to_list(""lists tuples strings"")==[\'lists\',\'tuples\',\'strings\']', 'assert string_to_list(""write a program"")==[\'write\',\'a\',\'program\']']","आप इसे Python के built-in `split()` फ़ंक्शन का उपयोग करके कर सकते हैं। यहां एक उदाहरण है:

```python
def split_string_on_space(s):
    return s.split(' ')

# उदाहरण के लिए
print(split_string_on_space('Hello World'))
```

इस फ़ंक्शन को चलाने पर, यह 'Hello World' स्ट्रिंग को एक सूची में विभाजित करेगा: `['Hello', 'World']`."
Mike's Copy of Benchmark Questions Verification V2.ipynb,119,उस तत्व को ढूंढने के लिए एक पायथन फ़ंक्शन लिखें जो क्रमबद्ध सरणी में केवल एक बार दिखाई देता है।,"def search(arr):
    n = len(arr)
    XOR = 0
    for i in range(n) :
        XOR = XOR ^ arr[i]
    return (XOR)",[],"['assert search([1,1,2,2,3]) == 3', 'assert search([1,1,3,3,4,4,5,5,7,7,8]) == 8', 'assert search([1,2,2,3,3,4,4]) == 1']","आप निम्नलिखित तरीके से एक पायथन फ़ंक्शन लिख सकते हैं जो क्रमबद्ध सरणी में केवल एक बार दिखाई देने वाले तत्व को ढूंढता है:

```python
def find_unique_element(arr):
    # एक खाली डिक्शनरी बनाएं
    count_dict = {}

    # सरणी के हर तत्व के लिए
    for element in arr:
        # यदि तत्व पहले से ही डिक्शनरी में है, तो उसकी गणना बढ़ाएं
        if element in count_dict:
            count_dict[element] += 1
        # अन्यथा, डिक्शनरी में नया तत्व जोड़ें
        else:
            count_dict[element] = 1

    # डिक्शनरी के हर तत्व के लिए
    for element, count in count_dict.items():
        # यदि तत्व की गणना 1 है, तो उसे वापस लौटाएं
        if count == 1:
            return element

    # यदि कोई एकल तत्व नहीं मिला, तो None वापस करें
    return None
```

इस फ़ंक्शन का उपयोग निम्नलिखित तरीके से किया जा सकता है:

```python
arr = [1, 1, 2, 2, 3, 4, 4, 5, 5]
print(find_unique_element(arr))  # आउटपुट: 3
```"
Mike's Copy of Benchmark Questions Verification V2.ipynb,120,किसी दी गई सूची में टुपल्स के जोड़े में संख्याओं के बीच अधिकतम निरपेक्ष उत्पाद खोजने के लिए एक फ़ंक्शन लिखें।,"def max_product_tuple(list1):
    result_max = max([abs(x * y) for x, y in list1] )
    return result_max",[],"['assert max_product_tuple([(2, 7), (2, 6), (1, 8), (4, 9)] )==36', 'assert max_product_tuple([(10,20), (15,2), (5,10)] )==200', 'assert max_product_tuple([(11,44), (10,15), (20,5), (12, 9)] )==484']","यहां एक फ़ंक्शन है जो दी गई सूची में टुपल्स के जोड़े में संख्याओं के बीच अधिकतम निरपेक्ष उत्पाद खोजता है।

```python
def max_product(lst):
    max_product = 0
    for i in range(len(lst)):
        for j in range(i+1, len(lst)):
            product = abs(lst[i][0]*lst[j][1] - lst[i][1]*lst[j][0])
            if product > max_product:
                max_product = product
    return max_product
```

इस फ़ंक्शन का उपयोग करने के लिए, आप इसे निम्नलिखित तरीके से कॉल कर सकते हैं:

```python
print(max_product([(1, 2), (3, 4), (5, 6), (7, 8)]))
```

यह उत्पादन करेगा:

```python
20
```

यह फ़ंक्शन दी गई सूची में हर टुपल के जोड़े के बीच के उत्पाद की गणना करता है और अधिकतम उत्पाद को ट्रैक करता है। यह फ़ंक्शन अधिकतम उत्पाद को वापस करता है।"
Mike's Copy of Benchmark Questions Verification V2.ipynb,123,सभी सौहार्दपूर्ण संख्याओं को 1 से एक निर्दिष्ट संख्या तक जोड़ने के लिए एक फ़ंक्शन लिखें।,"def amicable_numbers_sum(limit):
    if not isinstance(limit, int):
        return ""Input is not an integer!""
    if limit < 1:
        return ""Input must be bigger than 0!""
    amicables = set()
    for num in range(2, limit+1):
        if num in amicables:
            continue
        sum_fact = sum([fact for fact in range(1, num) if num % fact == 0])
        sum_fact2 = sum([fact for fact in range(1, sum_fact) if sum_fact % fact == 0])
        if num == sum_fact2 and num != sum_fact:
            amicables.add(num)
            amicables.add(sum_fact2)
    return sum(amicables)",[],"['assert amicable_numbers_sum(999)==504', 'assert amicable_numbers_sum(9999)==31626', 'assert amicable_numbers_sum(99)==0']","सौहार्दपूर्ण संख्या वह होती है जिसके उपयोगकर्ता के गुणनखंडों का योग उसी संख्या के बराबर होता है। निम्नलिखित फ़ंक्शन एक निर्दिष्ट संख्या तक सभी सौहार्दपूर्ण संख्याओं का योग करेगा।

```python
def sum_of_amicable_numbers(n):
    def divisors(n):
        result = [1]
        for i in range(2, int(n**0.5) + 1):
            if n % i == 0:
                if n // i == i:
                    result.append(i)
                else:
                    result.extend([i, n // i])
        return result

    amicable_numbers = []
    for i in range(2, n+1):
        div_sum = sum(divisors(i))
        if div_sum != i and sum(divisors(div_sum)) == i:
            amicable_numbers.append(i)

    return sum(amicable_numbers)
```

यह फ़ंक्शन `divisors` नामक एक अंतर्निहित फ़ंक्शन का उपयोग करता है जो एक संख्या के सभी गुणनखंडों की सूची लौटाता है। फिर यह फ़ंक्शन 2 से निर्दिष्ट संख्या तक की सभी संख्याओं के लिए चलता है, और यदि वह संख्या सौहार्दपूर्ण है, तो यह उसे `amicable_numbers` सूची में जोड़ता है। अंत में, यह सभी सौहार्दपूर्ण संख्याओं का योग लौटाता है।"
Mike's Copy of Benchmark Questions Verification V2.ipynb,124,किसी सम्मिश्र संख्या का कोण प्राप्त करने के लिए एक फ़ंक्शन लिखें।,"import cmath
def angle_complex(a,b):
  cn=complex(a,b)
  angle=cmath.phase(a+b)
  return angle",['import math'],"['assert math.isclose(angle_complex(0,1j), 1.5707963267948966, rel_tol=0.001)', 'assert math.isclose(angle_complex(2,1j), 0.4636476090008061, rel_tol=0.001)', 'assert math.isclose(angle_complex(0,2j), 1.5707963267948966, rel_tol=0.001)']","सम्मिश्र संख्या का कोण प्राप्त करने के लिए, हमें इसके वास्तविक और काल्पनिक भागों का अनुपात लेना होगा। यह अनुपात तनज्ञात (tan) के रूप में दिया जाता है, जिसे हम निम्नलिखित फ़ंक्शन का उपयोग करके गणना कर सकते हैं:

```python
import cmath

def get_angle(complex_num):
    return cmath.phase(complex_num)

# उदाहरण के लिए:
complex_num = 1 + 1j
angle = get_angle(complex_num)
print(angle)
```

इस फ़ंक्शन का उपयोग करके, हम किसी भी सम्मिश्र संख्या का कोण प्राप्त कर सकते हैं। ध्यान दें कि यह कोण रेडियन में होता है, और यदि आप इसे डिग्री में चाहते हैं, तो आपको इसे रेडियन से डिग्री में परिवर्तित करना होगा, जो `math.degrees()` फ़ंक्शन का उपयोग करके किया जा सकता है।"
Mike's Copy of Benchmark Questions Verification V2.ipynb,125,दी गई बाइनरी स्ट्रिंग के किसी उप-स्ट्रिंग में 0s की संख्या और 1s की संख्या के बीच अधिकतम अंतर जानने के लिए एक फ़ंक्शन लिखें।,"def find_length(string): 
	n = len(string)
	current_sum = 0
	max_sum = 0
	for i in range(n): 
		current_sum += (1 if string[i] == '0' else -1) 
		if current_sum < 0: 
			current_sum = 0
		max_sum = max(current_sum, max_sum) 
	return max_sum if max_sum else 0",[],"['assert find_length(""11000010001"") == 6', 'assert find_length(""10111"") == 1', 'assert find_length(""11011101100101"") == 2']","आप निम्नलिखित तरीके से इसे कर सकते हैं:

```python
def max_diff_binary(bin_str):
    max_diff = 0
    for i in range(len(bin_str)):
        for j in range(i, len(bin_str)):
            sub_str = bin_str[i:j+1]
            count_0 = sub_str.count('0')
            count_1 = sub_str.count('1')
            diff = abs(count_0 - count_1)
            if diff > max_diff:
                max_diff = diff
    return max_diff
```

इस फ़ंक्शन का उपयोग करके, आप एक बाइनरी स्ट्रिंग में 0s और 1s की संख्या के बीच अधिकतम अंतर जान सकते हैं। यह फ़ंक्शन सभी संभव उप-स्ट्रिंग्स के लिए 0s और 1s की संख्या की गणना करता है और उनके बीच के अंतर की गणना करता है, और फिर यह अधिकतम अंतर लौटाता है।"
Mike's Copy of Benchmark Questions Verification V2.ipynb,126,दो दी गई संख्याओं के उभयनिष्ठ भाजक का योग ज्ञात करने के लिए एक पायथन फ़ंक्शन लिखें।,"def sum(a,b): 
    sum = 0
    for i in range (1,min(a,b)): 
        if (a % i == 0 and b % i == 0): 
            sum += i 
    return sum",[],"['assert sum(10,15) == 6', 'assert sum(100,150) == 93', 'assert sum(4,6) == 3']","यहां एक पायथन फ़ंक्शन है जो दो संख्याओं के उभयनिष्ठ भाजकों का योग ज्ञात करता है:

```python
def sum_common_divisors(num1, num2):
    # उभयनिष्ठ भाजकों की सूची को खाली सेट से शुरू करें
    common_divisors = set()

    # पहली संख्या के लिए सभी भाजकों की जांच करें
    for i in range(1, num1 + 1):
        if num1 % i == 0:
            common_divisors.add(i)

    # दूसरी संख्या के लिए सभी भाजकों की जांच करें
    for i in range(1, num2 + 1):
        if num2 % i == 0:
            common_divisors.add(i)

    # उभयनिष्ठ भाजकों का योग लौटाएं
    return sum(common_divisors)
```

इस फ़ंक्शन का उपयोग करने के लिए, आप बस दो संख्याएँ पास करें:

```python
print(sum_common_divisors(12, 18))  # उदाहरण के लिए
```"
Mike's Copy of Benchmark Questions Verification V2.ipynb,127,दो पूर्णांकों को गुणा करने के लिए एक फ़ंक्शन लिखें।,"def multiply_int(x, y):
    if y < 0:
        return -multiply_int(x, -y)
    elif y == 0:
        return 0
    elif y == 1:
        return x
    else:
        return x + multiply_int(x, y - 1)",[],"['assert multiply_int(10,20)==200', 'assert multiply_int(5,10)==50', 'assert multiply_int(4,8)==32']","यहां एक सरल पायथन फ़ंक्शन है जो दो पूर्णांकों को गुणा करता है:

```python
def multiply_numbers(num1, num2):
    return num1 * num2
```

इस फ़ंक्शन का उपयोग करने के लिए, आप बस दो पूर्णांक पास करें जैसे कि:

```python
result = multiply_numbers(4, 5)
print(result)  # यह 20 प्रिंट करेगा
```"
Mike's Copy of Benchmark Questions Verification V2.ipynb,128,शब्दों की दी गई सूची से n वर्णों से अधिक लंबे शब्दों को खोजने के लिए एक फ़ंक्शन लिखें।,"def long_words(n, str):
    word_len = []
    txt = str.split("" "")
    for x in txt:
        if len(x) > n:
            word_len.append(x)
    return word_len	",[],"['assert long_words(3,""python is a programming language"")==[\'python\',\'programming\',\'language\']', 'assert long_words(2,""writing a program"")==[\'writing\',\'program\']', 'assert long_words(5,""sorting list"")==[\'sorting\']']","आप निम्नलिखित तरीके से एक फ़ंक्शन लिख सकते हैं:

```python
def long_words(n, word_list):
    return [word for word in word_list if len(word) > n]
```

इस फ़ंक्शन का उपयोग करने के लिए, आप एक संख्या (n) और एक शब्दों की सूची पास करेंगे। फ़ंक्शन n से अधिक वर्णों वाले सभी शब्दों की सूची लौटाएगा।

उदाहरण के लिए:

```python
print(long_words(4, ['cat', 'window', 'defenestrate']))
```

यह 'window' और 'defenestrate' लौटाएगा, क्योंकि ये दोनों शब्द 4 अक्षरों से अधिक हैं।"
Mike's Copy of Benchmark Questions Verification V2.ipynb,129,यह गणना करने के लिए एक फ़ंक्शन लिखें कि मैट्रिक्स एक जादुई वर्ग है या नहीं।,"def magic_square_test(my_matrix):
    iSize = len(my_matrix[0])
    sum_list = []
    sum_list.extend([sum (lines) for lines in my_matrix])   
    for col in range(iSize):
        sum_list.append(sum(row[col] for row in my_matrix))
    result1 = 0
    for i in range(0,iSize):
        result1 +=my_matrix[i][i]
    sum_list.append(result1)      
    result2 = 0
    for i in range(iSize-1,-1,-1):
        result2 +=my_matrix[i][i]
    sum_list.append(result2)
    if len(set(sum_list))>1:
        return False
    return True",[],"['assert magic_square_test([[7, 12, 1, 14], [2, 13, 8, 11], [16, 3, 10, 5], [9, 6, 15, 4]])==True', 'assert magic_square_test([[2, 7, 6], [9, 5, 1], [4, 3, 8]])==True', 'assert magic_square_test([[2, 7, 6], [9, 5, 1], [4, 3, 7]])==False']","एक जादुई वर्ग एक ऐसा वर्ग होता है जिसमें सभी पंक्तियों, स्तंभों और विकर्णों का योग समान होता है। निम्नलिखित फ़ंक्शन एक मैट्रिक्स को इनपुट के रूप में लेता है और यदि यह एक जादुई वर्ग है तो सच्चाई मान लौटाता है, अन्यथा झूठे मान लौटाता है।

```python
def is_magic_square(matrix):
    # एक वर्ग मैट्रिक्स होने की जांच करें
    if len(matrix) != len(matrix[0]):
        return False

    # पहली पंक्ति का योग निर्धारित करें
    magic_constant = sum(matrix[0])

    # सभी पंक्तियों और स्तंभों का योग जांचें
    for i in range(len(matrix)):
        if sum(matrix[i]) != magic_constant or sum([row[i] for row in matrix]) != magic_constant:
            return False

    # विकर्णों का योग जांचें
    if sum(matrix[i][i] for i in range(len(matrix))) != magic_constant or sum(matrix[i][len(matrix)-i-1] for i in range(len(matrix))) != magic_constant:
        return False

    # यदि सभी जांच पास हो जाती हैं, तो यह एक जादुई वर्ग है
    return True
```

उदाहरण के लिए, यदि हम इसे निम्नलिखित मैट्रिक्स के साथ बुलाते हैं:

```python
matrix = [[2, 7, 6], [9, 5, 1], [4, 3, 8]]
print(is_magic_square(matrix))
```

यह `True` लौटाएगा, क्योंकि यह एक जादुई वर्ग है।"
Mike's Copy of Benchmark Questions Verification V2.ipynb,130,किसी दी गई सूची में अधिकतम आवृत्ति वाले आइटम को खोजने के लिए एक फ़ंक्शन लिखें।,"from collections import defaultdict
def max_occurrences(nums):
    dict = defaultdict(int)
    for i in nums:
        dict[i] += 1
    result = max(dict.items(), key=lambda x: x[1]) 
    return result[0]",[],"['assert max_occurrences([2,3,8,4,7,9,8,2,6,5,1,6,1,2,3,2,4,6,9,1,2])==2', 'assert max_occurrences([2,3,8,4,7,9,8,7,9,15,14,10,12,13,16,18])==8', 'assert max_occurrences([10,20,20,30,40,90,80,50,30,20,50,10])==20']","आप collections मॉड्यूल का उपयोग करके इसे कर सकते हैं। यहां एक उदाहरण है:

```python
from collections import Counter

def most_common(lst):
    data = Counter(lst)
    return data.most_common(1)[0][0]

# उदाहरण के लिए
print(most_common([1, 2, 2, 3, 3, 3]))
```

इस फ़ंक्शन का उपयोग करके, आप सूची में सबसे अधिक बार दोहराए गए आइटम को प्राप्त कर सकते हैं। यदि दो या दो से अधिक आइटम समान रूप से अधिकतम बार दोहराए जाते हैं, तो यह फ़ंक्शन पहले दिखाए गए आइटम को लौटाएगा।"
Mike's Copy of Benchmark Questions Verification V2.ipynb,131,किसी दिए गए स्ट्रिंग के केवल स्वरों को उलटने के लिए एक पायथन फ़ंक्शन लिखें (जहां y स्वर नहीं है)।,"def reverse_vowels(str1):
	vowels = """"
	for char in str1:
		if char in ""aeiouAEIOU"":
			vowels += char
	result_string = """"
	for char in str1:
		if char in ""aeiouAEIOU"":
			result_string += vowels[-1]
			vowels = vowels[:-1]
		else:
			result_string += char
	return result_string",[],"['assert reverse_vowels(""Python"") == ""Python""', 'assert reverse_vowels(""USA"") == ""ASU""', 'assert reverse_vowels(""ab"") == ""ab""']","यहां एक संभावित समाधान है:

```python
def reverse_vowels(s):
    vowels = 'aeiouAEIOU'
    string = list(s)
    i, j = 0, len(s) - 1
    while i < j:
        if string[i] not in vowels:
            i += 1
        elif string[j] not in vowels:
            j -= 1
        else:
            string[i], string[j] = string[j], string[i]
            i += 1
            j -= 1
    return ''.join(string)
```

इस फ़ंक्शन का उपयोग करने के लिए, आप बस इसे निम्नलिखित तरीके से कॉल करें:

```python
print(reverse_vowels(""hello world""))  # Output: ""hollo werld""
```

यह फ़ंक्शन केवल स्वरों को उलटता है, बाकी सभी वर्णों को उनकी मूल स्थिति में छोड़ देता है."
Mike's Copy of Benchmark Questions Verification V2.ipynb,132,टुपल को स्ट्रिंग में बदलने के लिए एक फ़ंक्शन लिखें।,"def tup_string(tup1):
  str =  ''.join(tup1)
  return str",[],"['assert tup_string((\'e\', \'x\', \'e\', \'r\', \'c\', \'i\', \'s\', \'e\', \'s\'))==(""exercises"")', 'assert tup_string((\'p\',\'y\',\'t\',\'h\',\'o\',\'n\'))==(""python"")', 'assert tup_string((\'p\',\'r\',\'o\',\'g\',\'r\',\'a\',\'m\'))==(""program"")']","आप निम्नलिखित फ़ंक्शन का उपयोग कर सकते हैं:

```python
def tuple_to_string(tup):
    return ''.join(tup)
```

इस फ़ंक्शन का उपयोग करने के लिए, आप एक टुपल पास करेंगे और यह उसे एक स्ट्रिंग में बदल देगा। उदाहरण के लिए:

```python
print(tuple_to_string(('H', 'e', 'l', 'l', 'o')))
```

यह ""Hello"" प्रिंट करेगा।"
Mike's Copy of Benchmark Questions Verification V2.ipynb,133,संख्याओं की दी गई सूची की ऋणात्मक संख्याओं के योग की गणना करने के लिए एक फ़ंक्शन लिखें।,"def sum_negativenum(nums):
  sum_negativenum = list(filter(lambda nums:nums<0,nums))
  return sum(sum_negativenum)",[],"['assert sum_negativenum([2, 4, -6, -9, 11, -12, 14, -5, 17])==-32', 'assert sum_negativenum([10,15,-14,13,-18,12,-20])==-52', 'assert sum_negativenum([19, -65, 57, 39, 152,-639, 121, 44, 90, -190])==-894']","आप निम्नलिखित फ़ंक्शन का उपयोग कर सकते हैं:

```python
def sum_of_negative_numbers(lst):
    return sum(i for i in lst if i < 0)
```

इस फ़ंक्शन का उपयोग करके, आप एक सूची में ऋणात्मक संख्याओं का योग जोड़ सकते हैं। यह फ़ंक्शन सूची के प्रत्येक तत्व के लिए चेक करता है कि क्या वह ऋणात्मक है, और यदि हाँ, तो इसे योग में जोड़ता है।"
Mike's Copy of Benchmark Questions Verification V2.ipynb,135,nवीं षट्कोणीय संख्या ज्ञात करने के लिए एक फ़ंक्शन लिखें।,"def hexagonal_num(n): 
	return n*(2*n - 1) ",[],"['assert hexagonal_num(10) == 190', 'assert hexagonal_num(5) == 45', 'assert hexagonal_num(7) == 91']","षट्कोणीय संख्या (हेक्सागोनल नंबर) का सूत्र n(2n - 1) होता है, जहां n एक पूर्णांक है। इसे निम्नलिखित तरीके से पायथन में कोड कर सकते हैं:

```python
def hexagonal_number(n):
    return n * (2 * n - 1)
```

इस फ़ंक्शन का उपयोग करके, आप किसी भी पूर्णांक के लिए षट्कोणीय संख्या ज्ञात कर सकते हैं। उदाहरण के लिए, `hexagonal_number(3)` का परिणाम `15` होगा, क्योंकि 3(2*3 - 1) = 15 होता है।"
Mike's Copy of Benchmark Questions Verification V2.ipynb,137,पूर्णांकों की किसी सारणी में शून्य से गैर-शून्य का अनुपात ज्ञात करने के लिए एक फ़ंक्शन लिखें।,"from array import array
def zero_count(nums):
    n = len(nums)
    n1 = 0
    for x in nums:
        if x == 0:
            n1 += 1
        else:
          None
    return n1/(n-n1)",['import math'],"['assert math.isclose(zero_count([0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]), 0.181818, rel_tol=0.001)', 'assert math.isclose(zero_count([2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8]), 0.00, rel_tol=0.001)', 'assert math.isclose(zero_count([2, 4, -6, -9, 11, -12, 14, -5, 17]), 0.00, rel_tol=0.001)']","आप निम्नलिखित फ़ंक्शन का उपयोग कर सकते हैं:

```python
def zero_to_non_zero_ratio(numbers):
    zero_count = numbers.count(0)
    non_zero_count = len(numbers) - zero_count
    if non_zero_count == 0:
        return ""Undefined""
    else:
        return zero_count / non_zero_count
```

इस फ़ंक्शन का उपयोग एक सूची के भीतर शून्यों और गैर-शून्य संख्याओं के बीच का अनुपात ज्ञात करने के लिए किया जा सकता है। यदि सूची में कोई गैर-शून्य संख्या नहीं होती है, तो यह ""Undefined"" लौटाता है, क्योंकि शून्य से भागना गणितीय रूप से अनिर्धारित होता है।"
Mike's Copy of Benchmark Questions Verification V2.ipynb,138,यह जांचने के लिए एक पायथन फ़ंक्शन लिखें कि क्या दी गई संख्या को 2 की गैर-शून्य शक्तियों के योग के रूप में दर्शाया जा सकता है या नहीं।,"def is_Sum_Of_Powers_Of_Two(n): 
    if (n % 2 == 1): 
        return False
    else: 
        return True",[],"['assert is_Sum_Of_Powers_Of_Two(10) == True', 'assert is_Sum_Of_Powers_Of_Two(7) == False', 'assert is_Sum_Of_Powers_Of_Two(14) == True']","यहां एक पायथन फ़ंक्शन है जो यह जांचता है कि क्या दी गई संख्या को 2 की गैर-शून्य शक्तियों के योग के रूप में दर्शाया जा सकता है या नहीं।

```python
def check_power_of_two(n):
    if n <= 0:
        return False
    else:
        return (n & (n - 1)) == 0

# उदाहरण
print(check_power_of_two(8))  # True
print(check_power_of_two(10))  # False
```

यह फ़ंक्शन बाइनरी ऑपरेशन का उपयोग करता है। यदि एक संख्या 2 की शक्ति है, तो उसका बाइनरी प्रतिनिधित्व में केवल एक बिट होगा जो 1 है। जब हम 1 को उस संख्या से घटाते हैं, तो हमें एक संख्या मिलती है जिसमें सभी बिट 1 होते हैं जो पहले संख्या में 0 थे। इसलिए, यदि हम इन दोनों संख्याओं का बाइनरी 'और' ऑपरेशन करते हैं, हमें 0 मिलना चाहिए।"
Mike's Copy of Benchmark Questions Verification V2.ipynb,139,वृत्त की परिधि ज्ञात करने के लिए एक फ़ंक्शन लिखें।,"def circle_circumference(r):
  perimeter=2*3.1415*r
  return perimeter",['import math'],"['assert math.isclose(circle_circumference(10), 62.830000000000005, rel_tol=0.001)', 'assert math.isclose(circle_circumference(5), 31.415000000000003, rel_tol=0.001)', 'assert math.isclose(circle_circumference(4), 25.132, rel_tol=0.001)']","वृत्त की परिधि का सूत्र है 2πr, जहां r वृत्त की त्रिज्या है। निम्नलिखित Python फ़ंक्शन इसे गणना करेगा:

```python
import math

def calculate_circumference(radius):
    return 2 * math.pi * radius
```

इस फ़ंक्शन का उपयोग करने के लिए, आपको बस वृत्त की त्रिज्या के साथ इसे कॉल करना होगा। उदाहरण के लिए:

```python
print(calculate_circumference(5))
```

यह वृत्त की परिधि की गणना करेगा जिसकी त्रिज्या 5 है।"
Mike's Copy of Benchmark Questions Verification V2.ipynb,140,सूचियों की सूची को संख्याओं के एकल सेट में समतल करने के लिए एक फ़ंक्शन लिखें।,"def extract_singly(test_list):
  res = []
  temp = set()
  for inner in test_list:
    for ele in inner:
      if not ele in temp:
        temp.add(ele)
        res.append(ele)
  return (res) ",[],"['assert set(extract_singly([(3, 4, 5), (4, 5, 7), (1, 4)])) == set([3, 4, 5, 7, 1])', 'assert set(extract_singly([(1, 2, 3), (4, 2, 3), (7, 8)])) == set([1, 2, 3, 4, 7, 8])', 'assert set(extract_singly([(7, 8, 9), (10, 11, 12), (10, 11)])) == set([7, 8, 9, 10, 11, 12])']","आप निम्नलिखित तरीके से इसे कर सकते हैं:

```python
def flatten_list(nested_list):
    return [element for sublist in nested_list for element in sublist]
```

इस फ़ंक्शन का उपयोग करने के लिए, आपको बस नेस्टेड सूची पास करनी होगी:

```python
nested_list = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
print(flatten_list(nested_list))
```

यह निम्नलिखित आउटपुट देगा:

```python
[1, 2, 3, 4, 5, 6, 7, 8, 9]
```

यह फ़ंक्शन सूची के हर सबसूची के लिए हर तत्व को एकल सूची में जोड़ता है।"
Mike's Copy of Benchmark Questions Verification V2.ipynb,141,तत्वों की सूची को क्रमबद्ध करने के लिए एक फ़ंक्शन लिखें।,"def pancake_sort(nums):
    arr_len = len(nums)
    while arr_len > 1:
        mi = nums.index(max(nums[0:arr_len]))
        nums = nums[mi::-1] + nums[mi+1:len(nums)]
        nums = nums[arr_len-1::-1] + nums[arr_len:len(nums)]
        arr_len -= 1
    return nums",[],"['assert pancake_sort([15, 79, 25, 38, 69]) == [15, 25, 38, 69, 79]', 'assert pancake_sort([98, 12, 54, 36, 85]) == [12, 36, 54, 85, 98]', 'assert pancake_sort([41, 42, 32, 12, 23]) == [12, 23, 32, 41, 42]']","आप निम्नलिखित फ़ंक्शन का उपयोग कर सकते हैं:

```python
def sort_elements(elements):
    return sorted(elements)
```

इस फ़ंक्शन का उपयोग करने के लिए, आपको बस तत्वों की एक सूची पास करनी होगी। उदाहरण के लिए:

```python
elements = [5, 2, 3, 1, 4]
sorted_elements = sort_elements(elements)
print(sorted_elements)  # यह [1, 2, 3, 4, 5] प्रिंट करेगा
```

यह फ़ंक्शन तत्वों की सूची को छोटे से बड़े क्रम में सॉर्ट करेगा। यदि आप बड़े से छोटे क्रम में सॉर्ट करना चाहते हैं, तो आप `sorted` फ़ंक्शन को `reverse=True` पैरामीटर के साथ कॉल कर सकते हैं:

```python
def sort_elements_descending(elements):
    return sorted(elements, reverse=True)
```"
Mike's Copy of Benchmark Questions Verification V2.ipynb,142,दी गई तीन सूचियों की एक ही स्थिति में समान संख्या वाले आइटमों को गिनने के लिए एक फ़ंक्शन लिखें।,"def count_samepair(list1,list2,list3):
    result = sum(m == n == o for m, n, o in zip(list1,list2,list3))
    return result",[],"['assert count_samepair([1,2,3,4,5,6,7,8],[2,2,3,1,2,6,7,9],[2,1,3,1,2,6,7,9])==3', 'assert count_samepair([1,2,3,4,5,6,7,8],[2,2,3,1,2,6,7,8],[2,1,3,1,2,6,7,8])==4', 'assert count_samepair([1,2,3,4,2,6,7,8],[2,2,3,1,2,6,7,8],[2,1,3,1,2,6,7,8])==5']","आप निम्नलिखित तरीके से एक फ़ंक्शन लिख सकते हैं:

```python
def count_same_items(list1, list2, list3):
    count = 0
    for i in range(len(list1)):
        if list1[i] == list2[i] == list3[i]:
            count += 1
    return count
```

यह फ़ंक्शन तीन सूचियों की एक ही स्थिति में समान संख्या वाले आइटमों की संख्या गिनता है। यह मानता है कि सभी सूचियाँ समान लंबाई की होती हैं। यदि यह मान्य नहीं है, तो आपको इसे अनुकूलित करने की आवश्यकता हो सकती है।"
Mike's Copy of Benchmark Questions Verification V2.ipynb,143,दिए गए टुपल में मौजूद सूचियों की संख्या ज्ञात करने के लिए एक फ़ंक्शन लिखें।,"def find_lists(Input): 
	if isinstance(Input, list): 
		return 1
	else: 
		return len(Input) ",[],"['assert find_lists(([1, 2, 3, 4], [5, 6, 7, 8])) == 2', 'assert find_lists(([1, 2], [3, 4], [5, 6]))  == 3', 'assert find_lists(([9, 8, 7, 6, 5, 4, 3, 2, 1])) == 1']","आप निम्नलिखित फ़ंक्शन का उपयोग कर सकते हैं:

```python
def count_lists_in_tuple(tup):
    return sum(isinstance(i, list) for i in tup)
```

यह फ़ंक्शन टुपल में प्रत्येक आइटम के लिए चेक करता है कि क्या यह एक सूची है, और यदि हाँ, तो यह उन सभी सूचियों की संख्या को जोड़ता है। इसका परिणाम टुपल में मौजूद सूचियों की कुल संख्या होगी।"
Mike's Copy of Benchmark Questions Verification V2.ipynb,145,किसी दिए गए सरणी में किन्हीं दो तत्वों के बीच अधिकतम अंतर जानने के लिए एक पायथन फ़ंक्शन लिखें।,"def max_Abs_Diff(arr): 
    n = len(arr)
    minEle = arr[0] 
    maxEle = arr[0] 
    for i in range(1, n): 
        minEle = min(minEle,arr[i]) 
        maxEle = max(maxEle,arr[i]) 
    return (maxEle - minEle) ",[],"['assert max_Abs_Diff((2,1,5,3)) == 4', 'assert max_Abs_Diff((9,3,2,5,1)) == 8', 'assert max_Abs_Diff((3,2,1)) == 2']","आप निम्नलिखित पायथन फ़ंक्शन का उपयोग कर सकते हैं:

```python
def max_difference(lst):
    return max(lst) - min(lst)
```

इस फ़ंक्शन का उपयोग करके, आप किसी भी सूची में दो तत्वों के बीच अधिकतम अंतर का पता लगा सकते हैं। यह फ़ंक्शन सूची में सबसे बड़े और सबसे छोटे तत्व के बीच अंतर की गणना करता है, जो कि दो तत्वों के बीच संभव अधिकतम अंतर होता है।"
Benchmark Questions Verification V2.ipynb,160,"एक फ़ंक्शन लिखें जो पूर्णांक x और y लौटाता है जो ax + by = n को टुपल के रूप में संतुष्ट करता है, या यदि कोई समाधान मौजूद नहीं है तो कोई नहीं लौटाता है।","def find_solution(a, b, n):
	i = 0
	while i * a <= n:
		if (n - (i * a)) % b == 0: 
			return (i, (n - (i * a)) // b)
		i = i + 1
	return None",[],"['assert find_solution(2, 3, 7) == (2, 1)', 'assert find_solution(4, 2, 7) == None', 'assert find_solution(1, 13, 17) == (4, 1)']","यहां एक संभावित समाधान है जो आपके विवरण के अनुसार काम करता है। यह फ़ंक्शन एक ब्रूट फ़ोर्स तरीका अपनाता है और सभी संभावित (x, y) जोड़ों को जांचता है जो दी गई सीमा के भीतर हैं। यदि यह एक जोड़ी पाता है जो दी गई समीकरण को संतुष्ट करता है, तो यह उसे वापस करता है। यदि ऐसा कोई जोड़ी नहीं मिलती, तो यह None वापस करता है।

```python
def find_solution(a, b, n, limit=100):
    for x in range(-limit, limit+1):
        for y in range(-limit, limit+1):
            if a*x + b*y == n:
                return (x, y)
    return None
```

इस फ़ंक्शन का उपयोग करने के लिए, आपको बस आवश्यक पैरामीटर देने की आवश्यकता होती है:

```python
print(find_solution(3, 4, 10))  # उदाहरण के लिए
```

कृपया ध्यान दें कि यह फ़ंक्शन बहुत धीमा हो सकता है यदि आपकी 'limit' मान बहुत बड़ी है, क्योंकि यह सभी संभावित जोड़ों को जांचता है। इसे अधिक कुशल बनाने के लिए, आप एक अलग एल्गोरिदम का उपयोग कर सकते हैं, जैसे कि यूक्लिडी एल्गोरिदम, लेकिन यह अधिक जटिल हो सकता है।"
Benchmark Questions Verification V2.ipynb,161,किसी दी गई सूची से किसी अन्य सूची में मौजूद सभी तत्वों को हटाने के लिए एक फ़ंक्शन लिखें।,"def remove_elements(list1, list2):
    result = [x for x in list1 if x not in list2]
    return result",[],"['assert remove_elements([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [2, 4, 6, 8]) == [1, 3, 5, 7, 9, 10]', 'assert remove_elements([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [1, 3, 5, 7]) == [2, 4, 6, 8, 9, 10]', 'assert remove_elements([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [5, 7]) == [1, 2, 3, 4, 6, 8, 9, 10]']","आप निम्नलिखित फ़ंक्शन का उपयोग कर सकते हैं:

```python
def remove_elements(list1, list2):
    return [i for i in list1 if i not in list2]
```

इस फ़ंक्शन का उपयोग करने के लिए, आपको दो सूचियाँ पास करनी होगी - पहली सूची से आपको तत्व हटाने हैं और दूसरी सूची में वे तत्व हैं जिन्हें आप हटाना चाहते हैं। फ़ंक्शन सूची 1 से सूची 2 में मौजूद सभी तत्वों को हटा देगा और नई सूची लौटाएगा।

उदाहरण के लिए:

```python
list1 = [1, 2, 3, 4, 5]
list2 = [2, 4]
print(remove_elements(list1, list2))  # Output: [1, 3, 5]
```"
Benchmark Questions Verification V2.ipynb,162,"i=0 से n // 2 तक के योग (n - 2*i) की गणना करने के लिए एक फ़ंक्शन लिखें, उदाहरण के लिए n + (n-2) + (n-4)... (nx =&lt; 0 तक)।","def sum_series(n):
  if n < 1:
    return 0
  else:
    return n + sum_series(n - 2)",[],"['assert sum_series(6) == 12', 'assert sum_series(10) == 30', 'assert sum_series(9) == 25']","आप निम्नलिखित फ़ंक्शन का उपयोग कर सकते हैं:

```python
def calculate_sum(n):
    return sum(n - 2*i for i in range(n // 2 + 1))
```

यह फ़ंक्शन `range` फ़ंक्शन का उपयोग करके 0 से `n // 2` तक के सभी संख्याओं के लिए `(n - 2*i)` की गणना करता है, और फिर `sum` फ़ंक्शन का उपयोग करके उन सभी मानों का योग करता है।"
Benchmark Questions Verification V2.ipynb,163,एक नियमित बहुभुज की लंबाई और भुजाओं की संख्या को देखते हुए उसके क्षेत्रफल की गणना करने के लिए एक फ़ंक्शन लिखें।,"from math import tan, pi
def area_polygon(s, l):
  area = s * (l ** 2) / (4 * tan(pi / s))
  return area",['import math'],"['assert math.isclose(area_polygon(4, 20), 400., rel_tol=0.001)', 'assert math.isclose(area_polygon(10, 15), 1731.197, rel_tol=0.001)', 'assert math.isclose(area_polygon(9, 7), 302.909, rel_tol=0.001)']","एक नियमित बहुभुज का क्षेत्रफल निम्न सूत्र से गणना किया जा सकता है:

Area = (n * s^2) / (4 * tan(pi/n))

जहां n भुजाओं की संख्या है और s एक भुजा की लंबाई है। यहां टैन और पाई गणितीय संकेत हैं जिनका उपयोग trigonometry में किया जाता है।

इसे Python में लागू करने के लिए, हम math मॉड्यूल का उपयोग करेंगे, जो टैन और पाई के लिए फ़ंक्शन प्रदान करता है।

```python
import math

def polygon_area(n, s):
    return (n * s**2) / (4 * math.tan(math.pi/n))
```

इस फ़ंक्शन का उपयोग करने के लिए, आपको बस भुजाओं की संख्या और एक भुजा की लंबाई पास करनी होगी। उदाहरण के लिए:

```python
print(polygon_area(5, 6))
```

यह एक पांच भुजा वाले बहुभुज का क्षेत्रफल गणना करेगा जिसकी प्रत्येक भुजा 6 इकाई लंबी है।"
Benchmark Questions Verification V2.ipynb,164,यह निर्धारित करने के लिए एक फ़ंक्शन लिखें कि क्या दो पूर्णांकों के विभाजकों का योग समान है।,"import math 
def div_sum(n): 
  total = 1
  i = 2

  while i * i <= n:
    if (n % i == 0):
      total = (total + i + math.floor(n / i))
    i += 1

  return total

def are_equivalent(num1, num2): 
    return div_sum(num1) == div_sum(num2); ",[],"['assert are_equivalent(36, 57) == False', 'assert are_equivalent(2, 4) == False', 'assert are_equivalent(23, 47) == True']","यहां एक संभावित समाधान है:

```python
def sum_of_divisors(n):
    sum = 0
    for i in range(1, n):
        if n % i == 0:
            sum += i
    return sum

def are_divisors_equal(num1, num2):
    return sum_of_divisors(num1) == sum_of_divisors(num2)
```

इसमें `sum_of_divisors` फ़ंक्शन एक पूर्णांक के सभी विभाजकों का योग निर्धारित करता है, और `are_divisors_equal` फ़ंक्शन दो पूर्णांकों के विभाजकों के योग की तुलना करता है।"
Benchmark Questions Verification V2.ipynb,165,एक स्ट्रिंग में वर्णों की संख्या की गणना करने के लिए एक फ़ंक्शन लिखें जो स्ट्रिंग में अंग्रेजी वर्णमाला (केस असंवेदनशील) के समान स्थान पर होते हैं।,"def count_char_position(str1): 
    count_chars = 0
    for i in range(len(str1)):
        if ((i == ord(str1[i]) - ord('A')) or 
            (i == ord(str1[i]) - ord('a'))): 
            count_chars += 1
    return count_chars ",[],"['assert count_char_position(""xbcefg"") == 2', 'assert count_char_position(""ABcED"") == 3', 'assert count_char_position(""AbgdeF"") == 5']","आप निम्नलिखित फ़ंक्शन का उपयोग कर सकते हैं:

```python
def count_letters_in_position(string):
    count = 0
    for i in range(len(string)):
        if i < 26 and string[i].lower() == chr(97 + i):
            count += 1
    return count
```

यह फ़ंक्शन एक स्ट्रिंग को इनपुट के रूप में लेता है और स्ट्रिंग की हर वर्ण की जांच करता है। यदि वर्ण का ASCII मान (केस असंवेदनशील) उसकी स्थिति (0-आधारित इंडेक्स) + 97 (ASCII मान के लिए 'a') के बराबर है, तो यह गणना बढ़ाता है। फ़ंक्शन फिर गणना करता है।

कृपया ध्यान दें कि यह फ़ंक्शन केवल पहले 26 वर्णों की गणना करेगा, क्योंकि अंग्रेजी वर्णमाला में केवल 26 अक्षर होते हैं।"
Benchmark Questions Verification V2.ipynb,166,एक फ़ंक्शन लिखें जो किसी सूची में पूर्णांकों के जोड़े की संख्या को सम संख्या में गिनता है।,"def find_even_pair(A): 
  count = 0
  for i in range(0, len(A)): 
    for j in range(i+1, len(A)): 
        if ((A[i] ^ A[j]) % 2 == 0): 
          count += 1

  return count",[],"['assert find_even_pair([5, 4, 7, 2, 1]) == 4', 'assert find_even_pair([7, 2, 8, 1, 0, 5, 11]) == 9', 'assert find_even_pair([1, 2, 3]) == 1']","आप निम्नलिखित तरीके से एक फ़ंक्शन लिख सकते हैं:

```python
def count_even_pairs(lst):
    count = 0
    for i in range(len(lst)):
        for j in range(i+1, len(lst)):
            if (lst[i] + lst[j]) % 2 == 0:
                count += 1
    return count
```

यह फ़ंक्शन `count_even_pairs` एक सूची `lst` लेता है और सूची में पूर्णांकों के जोड़े की संख्या को सम संख्या में गिनता है। यह फ़ंक्शन दो लूप का उपयोग करता है जो सूची के हर तत्व के लिए सभी अन्य तत्वों के साथ जोड़ता है, और यदि जोड़ सम है, तो यह गिनती बढ़ाता है। अंत में, यह फ़ंक्शन गिनती को वापस करता है।"
Benchmark Questions Verification V2.ipynb,167,n से अधिक या उसके बराबर 2 की सबसे छोटी शक्ति ज्ञात करने के लिए एक पायथन फ़ंक्शन लिखें।,"def next_power_of_2(n): 
  if n and not n & (n - 1):
    return n

  count = 0
  while n != 0: 
    n >>= 1
    count += 1

  return 1 << count; ",[],"['assert next_power_of_2(0) == 1', 'assert next_power_of_2(5) == 8', 'assert next_power_of_2(17) == 32']","आप निम्नलिखित पायथन फ़ंक्शन का उपयोग कर सकते हैं:

```python
import math

def smallest_power_of_two(n):
    return 2**math.ceil(math.log(n, 2))
```

इस फ़ंक्शन का उपयोग करने के लिए, आपको बस इसे निम्नलिखित तरीके से कॉल करना होगा:

```python
print(smallest_power_of_two(10))  # यह 16 प्रिंट करेगा
```

यह फ़ंक्शन `math.log(n, 2)` का उपयोग करके n की 2 की लॉग की गणना करता है, फिर `math.ceil` का उपयोग करके उसे ऊपर की ओर गोली जाती है, और फिर `2**` का उपयोग करके उस शक्ति की गणना की जाती है।"
Benchmark Questions Verification V2.ipynb,168,किसी दी गई सूची में किसी संख्या के घटित होने की संख्या गिनने के लिए एक फ़ंक्शन लिखें।,"def frequency(a,x): 
    count = 0  
    for i in a: 
      if i == x: 
        count += 1

    return count ",[],"['assert frequency([1,2,3], 4) == 0', 'assert frequency([1,2,2,3,3,3,4], 3) == 3', 'assert frequency([0,1,2,3,1,2], 1) == 2']","आप निम्नलिखित तरीके से एक फ़ंक्शन लिख सकते हैं:

```python
def count_occurrences(lst, num):
    return lst.count(num)
```

इस फ़ंक्शन का उपयोग करने के लिए, आप एक सूची और एक संख्या पास करेंगे और यह आपको उस संख्या की संख्या देगा जो सूची में होती है। उदाहरण के लिए:

```python
lst = [1, 2, 3, 2, 2, 4, 5, 2]
num = 2
print(count_occurrences(lst, num))  # यह 4 प्रिंट करेगा, क्योंकि 2 सूची में 4 बार होता है
```"
Benchmark Questions Verification V2.ipynb,170,दो सूचकांकों द्वारा निर्दिष्ट सीमा के भीतर किसी सूची में संख्याओं का योग ज्ञात करने के लिए एक फ़ंक्शन लिखें।,"def sum_range_list(list1, m, n):                                                                                                                                                                                                
    sum_range = 0                                                                                                                                                                                                         
    for i in range(m, n+1, 1):                                                                                                                                                                                        
        sum_range += list1[i]                                                                                                                                                                                                  
    return sum_range   ",[],"['assert sum_range_list([2,1,5,6,8,3,4,9,10,11,8,12], 8, 10) == 29', 'assert sum_range_list([2,1,5,6,8,3,4,9,10,11,8,12], 5, 7) == 16', 'assert sum_range_list([2,1,5,6,8,3,4,9,10,11,8,12], 7, 10) == 38']","आप निम्नलिखित तरीके से एक फ़ंक्शन लिख सकते हैं:

```python
def sum_within_range(lst, start, end):
    return sum(lst[start:end+1])
```

इस फ़ंक्शन में, `lst` सूची है, `start` और `end` सूचकांक हैं। यह फ़ंक्शन सूची `lst` के `start` और `end` सूचकांक के बीच के सभी संख्याओं का योग देता है। ध्यान दें कि `end+1` किया गया है क्योंकि Python में सूची की सीमा अंतिम सूचकांक से एक कम होती है।"
Benchmark Questions Verification V2.ipynb,171,एक नियमित पंचभुज की भुजाओं की लंबाई से उसका परिमाप ज्ञात करने के लिए एक फ़ंक्शन लिखें।,"import math
def perimeter_pentagon(a):
  perimeter=(5*a)
  return perimeter",[],"['assert perimeter_pentagon(5) == 25', 'assert perimeter_pentagon(10) == 50', 'assert perimeter_pentagon(15) == 75']","एक नियमित पंचभुज के सभी भुजाएं समान होती हैं, इसलिए उसका परिमाप भुजा की लंबाई को 5 से गुणा करने से मिलेगा। निम्नलिखित पायथन फ़ंक्शन इसे करेगा:

```python
def pentagon_perimeter(side_length):
    return 5 * side_length
```

इस फ़ंक्शन का उपयोग करने के लिए, आपको केवल पंचभुज की भुजा की लंबाई पास करनी होगी। उदाहरण के लिए:

```python
print(pentagon_perimeter(10))
```

यह 50 प्रिंट करेगा, क्योंकि एक भुजा की लंबाई 10 वाली पंचभुज का परिमाप 50 होगा।"
Benchmark Questions Verification V2.ipynb,172,किसी दिए गए स्ट्रिंग में स्ट्रिंग &#39;std&#39; की घटनाओं की संख्या गिनने के लिए एक फ़ंक्शन लिखें।,"def count_occurance(s):
  count = 0
  for i in range(len(s) - 2):
    if (s[i] == 's' and s[i+1] == 't' and s[i+2] == 'd'):
      count = count + 1
  return count",[],"['assert count_occurance(""letstdlenstdporstd"") == 3', 'assert count_occurance(""truststdsolensporsd"") == 1', 'assert count_occurance(""makestdsostdworthit"") == 2', 'assert count_occurance(""stds"") == 1', 'assert count_occurance("""") == 0']","आप निम्नलिखित फ़ंक्शन का उपयोग कर सकते हैं:

```python
def count_occurrences(string):
    return string.count('std')
```

इस फ़ंक्शन का उपयोग करने के लिए, आपको बस उस स्ट्रिंग को आपूर्ति करना होगा जिसमें आप 'std' की घटनाओं की संख्या जानना चाहते हैं। उदाहरण के लिए:

```python
print(count_occurrences('stdstdstd'))  # यह 3 प्रिंट करेगा
```

यह फ़ंक्शन 'std' की हर घटना की गिनती करता है, चाहे वह एक ही स्ट्रिंग में कई बार आए।"
Benchmark Questions Verification V2.ipynb,222,यह जांचने के लिए एक फ़ंक्शन लिखें कि टुपल में सभी तत्वों का डेटा प्रकार समान है या नहीं।,"def check_type(test_tuple):
  res = True
  for ele in test_tuple:
    if not isinstance(ele, type(test_tuple[0])):
      res = False
      break
  return (res) ",[],"['assert check_type((5, 6, 7, 3, 5, 6) ) == True', 'assert check_type((1, 2, ""4"") ) == False', 'assert check_type((3, 2, 1, 4, 5) ) == True']","आप निम्नलिखित फ़ंक्शन का उपयोग कर सकते हैं:

```python
def check_elements_type(tup):
    return len(set(type(i) for i in tup)) == 1
```

यह फ़ंक्शन टुपल के सभी तत्वों के डेटा प्रकार की एक सेट बनाता है, और यदि सेट की लंबाई 1 है, तो यह वापस लौटती है `True`, अन्यथा `False`. यदि सभी तत्वों का डेटा प्रकार समान होता है, तो सेट की लंबाई 1 होगी."
Benchmark Questions Verification V2.ipynb,223,"एक फ़ंक्शन लिखें जो एक क्रमबद्ध सरणी, उसकी लंबाई (एन), और एक तत्व लेता है और लौटाता है कि तत्व दिए गए क्रमबद्ध सरणी में बहुमत तत्व है या नहीं। (बहुसंख्यक तत्व वह तत्व है जो n/2 बार से अधिक होता है।)","def is_majority(arr, n, x):
	i = binary_search(arr, 0, n-1, x)
	if i == -1:
		return False
	if ((i + n//2) <= (n -1)) and arr[i + n//2] == x:
		return True
	else:
		return False
def binary_search(arr, low, high, x):
	if high >= low:
		mid = (low + high)//2 
		if (mid == 0 or x > arr[mid-1]) and (arr[mid] == x):
			return mid
		elif x > arr[mid]:
			return binary_search(arr, (mid + 1), high, x)
		else:
			return binary_search(arr, low, (mid -1), x)
	return -1",[],"['assert is_majority([1, 2, 3, 3, 3, 3, 10], 7, 3) == True', 'assert is_majority([1, 1, 2, 4, 4, 4, 6, 6], 8, 4) == False', 'assert is_majority([1, 1, 1, 2, 2], 5, 1) == True', 'assert is_majority([1, 1, 2, 2], 5, 1) == False']","आप निम्नलिखित फ़ंक्शन का उपयोग कर सकते हैं:

```python
def is_majority(arr, n, x):
    count = arr.count(x)
    if count > n/2:
        return True
    else:
        return False
```

इस फ़ंक्शन में, `arr` क्रमबद्ध सरणी है, `n` उसकी लंबाई है, और `x` वह तत्व है जिसकी बहुसंख्यकता की जांच करनी है। फ़ंक्शन `arr.count(x)` का उपयोग करके `x` की संख्या की गणना करता है, और फिर यह जांचता है कि क्या यह संख्या `n/2` से अधिक है। यदि हां, तो फ़ंक्शन `True` लौटाता है, अन्यथा `False` लौटाता है।"
Benchmark Questions Verification V2.ipynb,224,किसी दिए गए नंबर में सेट बिट्स (मान 1 के साथ बाइनरी अंक) की संख्या गिनने के लिए एक पायथन फ़ंक्शन लिखें।,"def count_Set_Bits(n): 
    count = 0
    while (n): 
        count += n & 1
        n >>= 1
    return count ",[],"['assert count_Set_Bits(2) == 1', 'assert count_Set_Bits(4) == 1', 'assert count_Set_Bits(6) == 2']","आप निम्नलिखित पायथन फ़ंक्शन का उपयोग कर सकते हैं:

```python
def count_set_bits(n):
    return bin(n).count('1')
```

इस फ़ंक्शन में, `bin(n)` नंबर को बाइनरी में परिवर्तित करता है और `count('1')` बाइनरी नंबर में 1 की संख्या गिनता है।"
Benchmark Questions Verification V2.ipynb,226,किसी दिए गए स्ट्रिंग के विषम सूचकांक मान वाले वर्णों को हटाने के लिए एक पायथन फ़ंक्शन लिखें।,"def odd_values_string(str):
  result = """" 
  for i in range(len(str)):
    if i % 2 == 0:
      result = result + str[i]
  return result",[],"[""assert odd_values_string('abcdef') == 'ace'"", ""assert odd_values_string('python') == 'pto'"", ""assert odd_values_string('data') == 'dt'"", ""assert odd_values_string('lambs') == 'lms'""]","आप निम्नलिखित पायथन फ़ंक्शन का उपयोग कर सकते हैं:

```python
def remove_odd_index_chars(s):
    return s[::2]
```

यह फ़ंक्शन एक स्ट्रिंग `s` को इनपुट के रूप में लेता है और विषम सूचकांक मान वाले वर्णों को हटाकर नई स्ट्रिंग वापस करता है। यहां `::2` एक स्लाइस ऑपरेटर है जो स्ट्रिंग के हर दूसरे वर्ण को चुनता है, शुरुआत से शुरू होते हुए, जो सम सूचकांक मान वाले वर्ण होते हैं।"
Benchmark Questions Verification V2.ipynb,227,न्यूनतम तीन संख्याएँ ज्ञात करने के लिए एक फ़ंक्शन लिखें।,"def min_of_three(a,b,c): 
      if (a <= b) and (a <= c): 
        smallest = a 
      elif (b <= a) and (b <= c): 
        smallest = b 
      else: 
        smallest = c 
      return smallest ",[],"['assert min_of_three(10,20,0)==0', 'assert min_of_three(19,15,18)==15', 'assert min_of_three(-10,-20,-30)==-30']","आप निम्नलिखित फ़ंक्शन का उपयोग कर सकते हैं:

```python
def find_three_smallest(numbers):
    return sorted(numbers)[:3]
```

इस फ़ंक्शन का उपयोग करने के लिए, आपको बस एक सूची या टपल जैसे इतरेबल को इसमें पास करना होगा। यह फ़ंक्शन संख्याओं को छोटी से बड़ी क्रम में क्रमबद्ध करेगा, और फिर पहले तीन तत्वों को वापस करेगा।

उदाहरण के लिए:

```python
numbers = [10, 2, 5, 1, 7, 6]
print(find_three_smallest(numbers))  # Output: [1, 2, 5]
```"
Benchmark Questions Verification V2.ipynb,228,यह जांचने के लिए एक पायथन फ़ंक्शन लिखें कि सभी बिट्स दी गई सीमा में अनसेट हैं या नहीं।,"def all_Bits_Set_In_The_Given_Range(n,l,r):  
    num = (((1 << r) - 1) ^ ((1 << (l - 1)) - 1)) 
    new_num = n & num
    if (new_num == 0): 
        return True
    return False",[],"['assert all_Bits_Set_In_The_Given_Range(4,1,2) == True', 'assert all_Bits_Set_In_The_Given_Range(17,2,4) == True', 'assert all_Bits_Set_In_The_Given_Range(39,4,6) == False']","आप निम्नलिखित तरीके से एक पायथन फ़ंक्शन लिख सकते हैं:

```python
def check_all_bits_unset(n):
    # यदि n शून्य है, तो सभी बिट्स अनसेट हैं
    if n == 0:
        return True
    # यदि n और n-1 का बिटवाइज़ एंड शून्य नहीं है, तो कुछ बिट्स सेट हैं
    if n & (n-1) != 0:
        return False
    # अन्यथा, सभी बिट्स अनसेट हैं
    return True
```

यह फ़ंक्शन एक पूर्णांक n लेता है और यदि सभी बिट्स अनसेट हैं तो True लौटाता है, अन्यथा False लौटाता है। यह बिटवाइज़ एंड ऑपरेशन का उपयोग करता है जो दो बाइनरी संख्याओं के बीच एंड ऑपरेशन करता है, और यदि दोनों बिट्स 1 हैं तो 1 लौटाता है, अन्यथा 0 लौटाता है।"
Benchmark Questions Verification V2.ipynb,229,"एक फ़ंक्शन लिखें जो एक सरणी और एक पूर्णांक n लेता है, और दिए गए सरणी के पहले n तत्वों को फिर से व्यवस्थित करता है ताकि सभी नकारात्मक तत्व सकारात्मक तत्वों से पहले दिखाई दें, और जहां नकारात्मक और सकारात्मक तत्वों के बीच सापेक्ष क्रम संरक्षित है।","def re_arrange_array(arr, n):
  j=0
  for i in range(0, n):
    if (arr[i] < 0):
      temp = arr[i]
      arr[i] = arr[j]
      arr[j] = temp
      j = j + 1
  return arr",[],"['assert re_arrange_array([-1, 2, -3, 4, 5, 6, -7, 8, 9], 9) == [-1, -3, -7, 4, 5, 6, 2, 8, 9]', 'assert re_arrange_array([12, -14, -26, 13, 15], 5) == [-14, -26, 12, 13, 15]', 'assert re_arrange_array([10, 24, 36, -42, -39, -78, 85], 7) == [-42, -39, -78, 10, 24, 36, 85]']","आप निम्नलिखित फ़ंक्शन का उपयोग कर सकते हैं:

```python
def rearrange(arr, n):
    neg = []
    pos = []
    for i in range(n):
        if arr[i] < 0:
            neg.append(arr[i])
        else:
            pos.append(arr[i])
    return neg + pos
```

यह फ़ंक्शन एक सरणी और एक पूर्णांक n लेता है, और दिए गए सरणी के पहले n तत्वों को फिर से व्यवस्थित करता है ताकि सभी नकारात्मक तत्व सकारात्मक तत्वों से पहले दिखाई दें, और जहां नकारात्मक और सकारात्मक तत्वों के बीच सापेक्ष क्रम संरक्षित है।

उदाहरण के लिए, यदि आप इसे `[1, -2, -3, 4, 5, -6]` और `6` के साथ कॉल करते हैं, तो यह `[-2, -3, -6, 1, 4, 5]` देगा।"
Benchmark Questions Verification V2.ipynb,230,"एक फ़ंक्शन लिखें जो एक स्ट्रिंग और कैरेक्टर लेता है, स्ट्रिंग में रिक्त स्थानों को कैरेक्टर से बदल देता है, और स्ट्रिंग लौटाता है।","def replace_blank(str1,char):
 str2 = str1.replace(' ', char)
 return str2",[],"['assert replace_blank(""hello people"",\'@\')==(""hello@people"")', 'assert replace_blank(""python program language"",\'$\')==(""python$program$language"")', 'assert replace_blank(""blank space"",""-"")==(""blank-space"")']","आप निम्नलिखित फ़ंक्शन का उपयोग कर सकते हैं:

```python
def replace_spaces(string, char):
    return string.replace(' ', char)
```

इस फ़ंक्शन का उपयोग करने के लिए, आपको बस एक स्ट्रिंग और एक कैरेक्टर पास करना होगा। फ़ंक्शन स्ट्रिंग में सभी रिक्त स्थानों को दिए गए कैरेक्टर से बदल देगा और नई स्ट्रिंग लौटाएगा।

उदाहरण के लिए:

```python
print(replace_spaces(""Hello World"", ""*""))
```

यह ""Hello*World"" लौटाएगा।"
Benchmark Questions Verification V2.ipynb,232,एक फ़ंक्शन लिखें जो एक सूची और एक पूर्णांक n लेता है और सूची से n सबसे बड़े आइटम वाली एक सूची लौटाता है।,"import heapq
def larg_nnum(list1,n):
 largest=heapq.nlargest(n,list1)
 return largest",[],"['assert set(larg_nnum([10, 20, 50, 70, 90, 20, 50, 40, 60, 80, 100],2))==set([100,90])', 'assert set(larg_nnum([10, 20, 50, 70, 90, 20, 50, 40, 60, 80, 100],5))==set([100,90,80,70,60])', 'assert set(larg_nnum([10, 20, 50, 70, 90, 20, 50, 40, 60, 80, 100],3))==set([100,90,80])']","आप निम्नलिखित तरीके से इसे कर सकते हैं:

```python
def n_largest_in_list(lst, n):
    return sorted(lst, reverse=True)[:n]
```

इस फ़ंक्शन में, हम पहले सूची को उलटा क्रम में सॉर्ट करते हैं (यानी, सबसे बड़े आइटम से लेकर सबसे छोटे आइटम तक), और फिर हम सूची के पहले n आइटम लौटाते हैं।"
Benchmark Questions Verification V2.ipynb,233,बेलन का पार्श्व सतह क्षेत्रफल ज्ञात करने के लिए एक फ़ंक्शन लिखें।,"def lateralsuface_cylinder(r,h):
  lateralsurface= 2*3.1415*r*h
  return lateralsurface",['import math'],"['assert math.isclose(lateralsuface_cylinder(10,5), 314.15000000000003, rel_tol=0.001)', 'assert math.isclose(lateralsuface_cylinder(4,5), 125.66000000000001, rel_tol=0.001)', 'assert math.isclose(lateralsuface_cylinder(4,10), 251.32000000000002, rel_tol=0.001)']","बेलन का पार्श्व सतह क्षेत्रफल (लैटरल सर्फेस एरिया) की गणना करने के लिए, हमें बेलन की ऊचाई (h) और त्रिज्या (r) की जानकारी चाहिए। फ़ॉर्मूला 2πrh है।

यहां एक पायथन फ़ंक्शन है जो इसे गणना करता है:

```python
import math

def lateral_surface_area_cylinder(r, h):
    return 2 * math.pi * r * h
```

इस फ़ंक्शन का उपयोग करने के लिए, आपको बस बेलन की त्रिज्या और ऊचाई को फ़ंक्शन के रूप में पास करना होगा। उदाहरण के लिए:

```python
print(lateral_surface_area_cylinder(3, 5))
```

यह बेलन के पार्श्व सतह क्षेत्रफल की गणना करेगा जिसकी त्रिज्या 3 और ऊचाई 5 है।"
Benchmark Questions Verification V2.ipynb,234,किसी घन की भुजा की लंबाई को देखते हुए उसका आयतन ज्ञात करने के लिए एक फ़ंक्शन लिखें।,"def volume_cube(l):
  volume = l * l * l
  return volume",[],"['assert volume_cube(3)==27', 'assert volume_cube(2)==8', 'assert volume_cube(5)==125']","आप निम्नलिखित तरीके से एक फ़ंक्शन लिख सकते हैं:

```python
def volume_of_cube(side_length):
    return side_length ** 3
```

इस फ़ंक्शन का उपयोग करने के लिए, आप बस घन की भुजा की लंबाई को फ़ंक्शन के रूप में पास करें:

```python
print(volume_of_cube(3))  # यह 27 प्रिंट करेगा
```

यह फ़ंक्शन घन के आयतन की गणना करता है, जो भुजा की लंबाई का घन होती है."
Benchmark Questions Verification V2.ipynb,235,किसी दिए गए नंबर के सभी सम बिट सेट करने के लिए एक पायथन फ़ंक्शन लिखें।,"def even_bit_set_number(n): 
    count = 0;res = 0;temp = n 
    while(temp > 0): 
        if (count % 2 == 1): 
            res |= (1 << count)
        count+=1
        temp >>= 1
    return (n | res) ",[],"['assert even_bit_set_number(10) == 10', 'assert even_bit_set_number(20) == 30', 'assert even_bit_set_number(30) == 30']","आप निम्नलिखित पायथन फ़ंक्शन का उपयोग कर सकते हैं:

```python
def set_all_even_bits(n):
    # 32 bit number
    for i in range(32):
        # check if bit is even
        if i % 2 == 0:
            # set bit
            n |= (1 << i)
    return n
```

इस फ़ंक्शन का उपयोग करने के लिए, आप बस इसे निम्नलिखित तरीके से कॉल करें:

```python
print(set_all_even_bits(10))  # Output: 171
```

यह फ़ंक्शन 32 बिट संख्या के सभी सम बिट सेट करता है। यदि आपके पास अलग बिट संख्या है, तो आपको फ़ंक्शन को उचित रूप से समायोजित करना होगा।"
Benchmark Questions Verification V2.ipynb,237,एक फ़ंक्शन लिखें जो टुपल्स की एक सूची लेता है और प्रत्येक अद्वितीय टुपल को सूची में आने की संख्या के अनुसार मैप करते हुए एक शब्दकोश लौटाता है।,"from collections import Counter 
def check_occurences(test_list):
  res = dict(Counter(tuple(ele) for ele in map(sorted, test_list)))
  return  (res) ",[],"['assert check_occurences([(3, 1), (1, 3), (2, 5), (5, 2), (6, 3)] ) == {(1, 3): 2, (2, 5): 2, (3, 6): 1}', 'assert check_occurences([(4, 2), (2, 4), (3, 6), (6, 3), (7, 4)] ) == {(2, 4): 2, (3, 6): 2, (4, 7): 1}', 'assert check_occurences([(13, 2), (11, 23), (12, 25), (25, 12), (16, 23)] ) == {(2, 13): 1, (11, 23): 1, (12, 25): 2, (16, 23): 1}']","आप इसे `collections` मॉड्यूल के `Counter` क्लास का उपयोग करके कर सकते हैं। यहां एक उदाहरण है:

```python
from collections import Counter

def count_tuples(lst):
    return dict(Counter(lst))

# उदाहरण के लिए
print(count_tuples([(1, 2), (3, 4), (1, 2), (5, 6), (7, 8), (1, 2), (3, 4), (3, 4), (7, 8), (9, 10)]))
```

इस कोड का आउटपुट होगा:

```
{(1, 2): 3, (3, 4): 3, (5, 6): 1, (7, 8): 2, (9, 10): 1}
```

जो दिखाता है कि (1, 2) और (3, 4) तीन बार आते हैं, (5, 6) और (9, 10) एक बार आते हैं, और (7, 8) दो बार आते हैं।"
Benchmark Questions Verification V2.ipynb,238,किसी दिए गए स्ट्रिंग के गैर-रिक्त सबस्ट्रिंग की संख्या गिनने के लिए एक पायथन फ़ंक्शन लिखें।,"def number_of_substrings(str): 
	str_len = len(str); 
	return int(str_len * (str_len + 1) / 2); ",[],"['assert number_of_substrings(""abc"") == 6', 'assert number_of_substrings(""abcd"") == 10', 'assert number_of_substrings(""abcde"") == 15']","एक स्ट्रिंग के गैर-रिक्त सबस्ट्रिंग की संख्या गिनने के लिए, हम निम्नलिखित पायथन फ़ंक्शन का उपयोग कर सकते हैं:

```python
def count_substrings(s):
    n = len(s)
    return n * (n + 1) // 2
```

यह फ़ंक्शन स्ट्रिंग की लंबाई को लेता है और उसे उसकी लंबाई से 1 अधिक से गुणा करता है, और फिर उसे 2 से विभाजित करता है। यह फ़ंक्शन सभी संभव गैर-रिक्त सबस्ट्रिंग की संख्या को गिनती है।

उदाहरण के लिए, यदि हम इसे ""abc"" स्ट्रिंग पर लागू करते हैं, तो यह 6 लौटेगा, क्योंकि ""abc"" के सभी गैर-रिक्त सबस्ट्रिंग हैं: ""a"", ""b"", ""c"", ""ab"", ""bc"", और ""abc""."
Benchmark Questions Verification V2.ipynb,239,"एक फ़ंक्शन लिखें जो धनात्मक पूर्णांक m और n लेता है और लंबाई n के संभावित अनुक्रमों की संख्या ज्ञात करता है, जैसे कि प्रत्येक तत्व एक धनात्मक पूर्णांक है और पिछले तत्व के दोगुने से अधिक या उसके बराबर है लेकिन m से कम या उसके बराबर है।","def get_total_number_of_sequences(m,n): 
	T=[[0 for i in range(n+1)] for i in range(m+1)] 
	for i in range(m+1): 
		for j in range(n+1): 
			if i==0 or j==0: 
				T[i][j]=0
			elif i<j: 
				T[i][j]=0
			elif j==1: 
				T[i][j]=i 
			else: 
				T[i][j]=T[i-1][j]+T[i//2][j-1] 
	return T[m][n]",[],"['assert get_total_number_of_sequences(10, 4) == 4', 'assert get_total_number_of_sequences(5, 2) == 6', 'assert get_total_number_of_sequences(16, 3) == 84']","आप इसे डायनामिक प्रोग्रामिंग का उपयोग करके हल कर सकते हैं। नीचे एक संभावित समाधान है:

```python
def count_sequences(m, n):
    dp = [[0 for _ in range(m+1)] for _ in range(n+1)]
    for i in range(1, m+1):
        dp[1][i] = i
    for i in range(2, n+1):
        for j in range(1, m+1):
            dp[i][j] = dp[i][j-1] + dp[i-1][j//2]
    return dp[n][m]
```

इस फ़ंक्शन का उपयोग करके, आप एक धनात्मक पूर्णांक m और n के लिए संभावित अनुक्रमों की संख्या ज्ञात कर सकते हैं। यह फ़ंक्शन एक 2D डायनामिक प्रोग्रामिंग तालिका बनाता है, जिसमें dp[i][j] में लंबाई i के सभी संभावित अनुक्रमों की संख्या होती है, जिनमें प्रत्येक तत्व j से कम या उसके बराबर है। फिर, यह तालिका का उपयोग करके, यह लंबाई n के सभी संभावित अनुक्रमों की संख्या ज्ञात करता है, जिनमें प्रत्येक तत्व m से कम या उसके बराबर है।"
Benchmark Questions Verification V2.ipynb,240,एक फ़ंक्शन लिखें जो दो सूचियाँ लेता है और पहली सूची के अंतिम तत्व को दूसरी सूची के तत्वों से बदल देता है।,"def replace_list(list1,list2):
 list1[-1:] = list2
 replace_list=list1
 return replace_list
",[],"['assert replace_list([1, 3, 5, 7, 9, 10],[2, 4, 6, 8])==[1, 3, 5, 7, 9, 2, 4, 6, 8]', 'assert replace_list([1,2,3,4,5],[5,6,7,8])==[1,2,3,4,5,6,7,8]', 'assert replace_list([""red"",""blue"",""green""],[""yellow""])==[""red"",""blue"",""yellow""]']","आप निम्नलिखित फ़ंक्शन का उपयोग कर सकते हैं:

```python
def replace_last_element(list1, list2):
    if list1 and list2:  # यह सुनिश्चित करता है कि दोनों सूचियाँ खाली नहीं हैं
        list1[-1] = list2
    return list1
```

इस फ़ंक्शन का उपयोग करने के लिए, आप निम्नलिखित कोड का उपयोग कर सकते हैं:

```python
list1 = [1, 2, 3]
list2 = [4, 5, 6]
print(replace_last_element(list1, list2))  # यह [1, 2, [4, 5, 6]] प्रिंट करेगा
```"
Benchmark Questions Verification V2.ipynb,242,किसी स्ट्रिंग में वर्णों की कुल संख्या गिनने के लिए एक फ़ंक्शन लिखें।,"def count_charac(str1):
 total = 0
 for i in str1:
    total = total + 1
 return total",[],"['assert count_charac(""python programming"")==18', 'assert count_charac(""language"")==8', 'assert count_charac(""words"")==5']","आप निम्नलिखित फ़ंक्शन का उपयोग कर सकते हैं:

```python
def count_characters(string):
    return len(string)
```

इस फ़ंक्शन का उपयोग करने के लिए, आप बस इसे निम्नलिखित तरीके से कॉल करें:

```python
print(count_characters(""हेलो वर्ल्ड""))
```

यह ""हेलो वर्ल्ड"" में वर्णों की कुल संख्या प्रिंट करेगा, जो 10 है। ध्यान दें कि यह फ़ंक्शन रिक्त स्थानों को भी वर्ण के रूप में गिनता है। यदि आप चाहते हैं कि यह रिक्त स्थानों को न गिने, तो आप इसे निम्नलिखित तरीके से संशोधित कर सकते हैं:

```python
def count_characters(string):
    return len(string.replace("" "", """"))
```

अब, जब आप `count_characters(""हेलो वर्ल्ड"")` को कॉल करेंगे, तो यह 9 प्रिंट करेगा, क्योंकि यह अब रिक्त स्थानों को नहीं गिन रहा है।"
Benchmark Questions Verification V2.ipynb,244,किसी दी गई संख्या से बड़ा अगला पूर्ण वर्ग ज्ञात करने के लिए एक पायथन फ़ंक्शन लिखें।,"import math  
def next_Perfect_Square(N): 
    nextN = math.floor(math.sqrt(N)) + 1
    return nextN * nextN ",[],"['assert next_Perfect_Square(35) == 36', 'assert next_Perfect_Square(6) == 9', 'assert next_Perfect_Square(9) == 16']","यहां एक पायथन फ़ंक्शन है जो दी गई संख्या से बड़ा अगला पूर्ण वर्ग ज्ञात करता है:

```python
import math

def next_square(n):
    # अगला पूर्ण वर्ग ज्ञात करने के लिए, हमें पहले दी गई संख्या का वर्गमूल ज्ञात करना होगा
    root = math.sqrt(n)
    
    # अगर वर्गमूल पूर्णांक है, तो हमें अगले पूर्णांक का वर्ग ज्ञात करना होगा
    if root.is_integer():
        next_root = root + 1
    # अगर वर्गमूल पूर्णांक नहीं है, तो हमें वर्गमूल के ऊपरी पूर्णांक का वर्ग ज्ञात करना होगा
    else:
        next_root = math.ceil(root)
    
    # अगले पूर्ण वर्ग को ज्ञात करने के लिए, हमें अगले वर्गमूल का वर्ग ज्ञात करना होगा
    next_square = next_root ** 2
    
    return next_square
```

उदाहरण के लिए, `next_square(24)` का परिणाम `25` होगा, और `next_square(25)` का परिणाम `36` होगा."
Benchmark Questions Verification V2.ipynb,245,"एक फ़ंक्शन लिखें जो एक सरणी लेता है और दिए गए सरणी के लिए बिटोनिक अनुवर्ती का अधिकतम योग पाता है, जहां एक अनुक्रम बिटोनिक होता है यदि यह पहले बढ़ रहा है और फिर घट रहा है।","def max_sum(arr): 
	MSIBS = arr[:] 
	for i in range(len(arr)): 
		for j in range(0, i): 
			if arr[i] > arr[j] and MSIBS[i] < MSIBS[j] + arr[i]: 
				MSIBS[i] = MSIBS[j] + arr[i] 
	MSDBS = arr[:] 
	for i in range(1, len(arr) + 1): 
		for j in range(1, i): 
			if arr[-i] > arr[-j] and MSDBS[-i] < MSDBS[-j] + arr[-i]: 
				MSDBS[-i] = MSDBS[-j] + arr[-i] 
	max_sum = float(""-Inf"") 
	for i, j, k in zip(MSIBS, MSDBS, arr): 
		max_sum = max(max_sum, i + j - k) 
	return max_sum",[],"['assert max_sum([1, 15, 51, 45, 33, 100, 12, 18, 9]) == 194', 'assert max_sum([80, 60, 30, 40, 20, 10]) == 210', 'assert max_sum([2, 3 ,14, 16, 21, 23, 29, 30]) == 138']","यहां एक फ़ंक्शन है जो दिए गए सरणी के लिए बिटोनिक अनुवर्ती का अधिकतम योग पाता है:

```python
def max_bitonic_subsequence_sum(arr):
    n = len(arr)

    # Initialize lists for storing results
    inc = [0 for i in range(n)]
    dec = [0 for i in range(n)]

    # Initialize first and last values of lists
    inc[0] = arr[0]
    dec[n-1] = arr[n-1]

    # Fill inc[] and dec[] lists
    for i in range(1, n):
        inc[i] = max(inc[j] for j in range(i) if arr[j] < arr[i]) + arr[i]
        dec[n-i-1] = max(dec[j] for j in range(n-i, n) if arr[j] < arr[n-i-1]) + arr[n-i-1]

    # Return the maximum value of inc[i] + dec[i] - arr[i]
    return max(inc[i] + dec[i] - arr[i] for i in range(n))

# Test the function
arr = [1, 15, 51, 45, 33, 100, 12, 18, 9]
print(max_bitonic_subsequence_sum(arr))  # Output: 194
```

इस फ़ंक्शन का उपयोग करके, हम एक सरणी के लिए बिटोनिक अनुवर्ती का अधिकतम योग पा सकते हैं। यह फ़ंक्शन पहले एक सरणी बनाता है जिसमें सभी उप-सरणियों के लिए अधिकतम योग होते हैं जो बढ़ रहे हैं, और फिर एक दूसरी सरणी बनाता है जिसमें सभी उप-सरणियों के लिए अधिकतम योग होते हैं जो घट रहे हैं। अंत में, यह फ़ंक्शन उन सभी योगों का अधिकतम चुनता है जो एक बिटोनिक अनुवर्ती का हिस्सा हो सकते हैं।"
Benchmark Questions Verification V2.ipynb,246,बेबीलोनियन विधि का उपयोग करके वर्गमूल की गणना के लिए एक फ़ंक्शन लिखें।,"def babylonian_squareroot(number):
    if(number == 0):
        return 0;
    g = number/2.0;
    g2 = g + 1;
    while(g != g2):
        n = number/ g;
        g2 = g;
        g = (g + n)/2;
    return g;",['import math'],"['assert math.isclose(babylonian_squareroot(10), 3.162277660168379, rel_tol=0.001)', 'assert math.isclose(babylonian_squareroot(2), 1.414213562373095, rel_tol=0.001)', 'assert math.isclose(babylonian_squareroot(9), 3.0, rel_tol=0.001)']","बेबीलोनियन विधि एक प्राचीन अनुमानित विधि है जिसका उपयोग वर्गमूल की गणना करने के लिए किया जाता है। यह विधि निम्नलिखित फ़ंक्शन के माध्यम से पायथन में लागू की जा सकती है:

```python
def babylonian_method(n, error=0.00001):
    guess = n
    while abs(guess*guess - n) >= error:
        guess = (guess + n/guess) / 2.0
    return guess
```

इस फ़ंक्शन में, `n` वह संख्या है जिसका वर्गमूल हमें निकालना है, और `error` वह त्रुटि है जिसे हम स्वीकार करने के लिए तैयार हैं। फ़ंक्शन तब तक चलता रहेगा जब तक कि अनुमानित वर्गमूल का वर्ग और `n` के बीच का अंतर `error` से अधिक नहीं हो जाता।"
Benchmark Questions Verification V2.ipynb,247,दी गई स्ट्रिंग में सबसे लंबे पैलिन्ड्रोमिक अनुवर्ती की लंबाई ज्ञात करने के लिए एक फ़ंक्शन लिखें।,"def lps(str): 
	n = len(str) 
	L = [[0 for x in range(n)] for x in range(n)] 
	for i in range(n): 
		L[i][i] = 1
	for cl in range(2, n+1): 
		for i in range(n-cl+1): 
			j = i+cl-1
			if str[i] == str[j] and cl == 2: 
				L[i][j] = 2
			elif str[i] == str[j]: 
				L[i][j] = L[i+1][j-1] + 2
			else: 
				L[i][j] = max(L[i][j-1], L[i+1][j]); 
	return L[0][n-1]",[],"['assert lps(""TENS FOR TENS"") == 5', 'assert lps(""CARDIO FOR CARDS"") == 7', 'assert lps(""PART OF THE JOURNEY IS PART"") == 9']","पैलिंड्रोम वह शब्द होता है जो उल्टा पढ़ने पर भी समान होता है। यहां एक फ़ंक्शन दिया गया है जो एक स्ट्रिंग में सबसे लंबे पैलिंड्रोमिक अनुवर्ती की लंबाई ज्ञात करता है।

```python
def longest_palindromic_substring_length(s):
    if not s:
        return 0

    n = len(s)
    longest_length = 0

    # Create a table to store results of subproblems
    dp = [[False for x in range(n)] for y in range(n)]

    # All substrings of length 1 are palindromes
    for i in range(n):
        dp[i][i] = True
        longest_length = 1

    # Check for substring of length 2
    start = 0
    for i in range(n - 1):
        if s[i] == s[i + 1]:
            dp[i][i + 1] = True
            start = i
            longest_length = 2

    # Check for lengths greater than 2
    for k in range(3, n + 1):
        for i in range(n - k + 1):
            j = i + k - 1
            if dp[i + 1][j - 1] and s[i] == s[j]:
                dp[i][j] = True
                if k > longest_length:
                    start = i
                    longest_length = k

    return longest_length
```

इस फ़ंक्शन का उपयोग करके, आप किसी भी स्ट्रिंग में सबसे लंबे पैलिंड्रोमिक अनुवर्ती की लंबाई ज्ञात कर सकते हैं। उदाहरण के लिए, `longest_palindromic_substring_length(""babad"")` का परिणाम `3` होगा, क्योंकि ""bab"" या ""aba"" सबसे लंबे पैलिंड्रोमिक अनुवर्ती हैं।"
Benchmark Questions Verification V2.ipynb,248,एक फ़ंक्शन लिखें जो एक पूर्णांक n लेता है और n-1 के हार्मोनिक योग की गणना करता है।,"def harmonic_sum(n):
  if n < 2:
    return 1
  else:
    return 1 / n + (harmonic_sum(n - 1)) ",['import math'],"['assert math.isclose(harmonic_sum(7), 2.5928571428571425, rel_tol=0.001)', 'assert math.isclose(harmonic_sum(4), 2.083333333333333, rel_tol=0.001)', 'assert math.isclose(harmonic_sum(19), 3.547739657143682, rel_tol=0.001)']","हार्मोनिक योग का सूत्र 1/1 + 1/2 + 1/3 + ... + 1/n है। इसे Python में इस तरह से लिखा जा सकता है:

```python
def harmonic_sum(n):
    if n < 2:
        return 1
    else:
        return 1/n + harmonic_sum(n-1)
```

इस फ़ंक्शन का उपयोग करके, आप एक पूर्णांक n के लिए हार्मोनिक योग की गणना कर सकते हैं। उदाहरण के लिए, `harmonic_sum(5)` का परिणाम `2.283333333333333` होगा।"
Benchmark Questions Verification V2.ipynb,249,दो सरणियों के प्रतिच्छेदन को खोजने के लिए एक फ़ंक्शन लिखें।,"def intersection_array(array_nums1,array_nums2):
 result = list(filter(lambda x: x in array_nums1, array_nums2)) 
 return result",[],"['assert intersection_array([1, 2, 3, 5, 7, 8, 9, 10],[1, 2, 4, 8, 9])==[1, 2, 8, 9]', 'assert intersection_array([1, 2, 3, 5, 7, 8, 9, 10],[3,5,7,9])==[3,5,7,9]', 'assert intersection_array([1, 2, 3, 5, 7, 8, 9, 10],[10,20,30,40])==[10]']","आप दो सरणियों के प्रतिच्छेदन को खोजने के लिए निम्नलिखित फ़ंक्शन का उपयोग कर सकते हैं:

```python
def find_difference(series1, series2):
    return series1 - series2
```

यह फ़ंक्शन दो सरणियों के बीच के प्रतिच्छेदन को खोजेगा। यहां, `series1` और `series2` दो सरणियाँ हैं जिनके बीच का प्रतिच्छेदन आप खोजना चाहते हैं।

ध्यान दें कि यह फ़ंक्शन केवल तब काम करेगा जब `series1` और `series2` एक ही आकार की होंगी। यदि वे एक ही आकार की नहीं हैं, तो आपको उन्हें एक ही आकार में परिवर्तित करने की आवश्यकता होगी जैसे कि आप उन्हें छोटा कर सकते हैं या उन्हें बड़ा कर सकते हैं ताकि वे एक ही आकार की हों।"
Benchmark Questions Verification V2.ipynb,250,एक पायथन फ़ंक्शन लिखें जो एक टुपल और एक तत्व लेता है और टुपल में तत्व की घटनाओं को गिनता है।,"def count_X(tup, x): 
    count = 0
    for ele in tup: 
        if (ele == x): 
            count = count + 1
    return count ",[],"['assert count_X((10, 8, 5, 2, 10, 15, 10, 8, 5, 8, 8, 2),4) == 0', 'assert count_X((10, 8, 5, 2, 10, 15, 10, 8, 5, 8, 8, 2),10) == 3', 'assert count_X((10, 8, 5, 2, 10, 15, 10, 8, 5, 8, 8, 2),8) == 4']","आप निम्नलिखित तरीके से एक पायथन फ़ंक्शन लिख सकते हैं:

```python
def count_element_in_tuple(tup, elem):
    return tup.count(elem)
```

इस फ़ंक्शन का उपयोग करने के लिए, आप निम्नलिखित तरीके से कर सकते हैं:

```python
tup = (1, 2, 3, 2, 4, 2, 5)
elem = 2
print(count_element_in_tuple(tup, elem))  # यह 3 प्रिंट करेगा
```

यह फ़ंक्शन `tup.count(elem)` का उपयोग करके टुपल `tup` में तत्व `elem` की संख्या को गिनती है।"
Benchmark Questions Verification V2.ipynb,251,"एक फ़ंक्शन लिखें जो एक सूची और एक तत्व लेता है और सूची में प्रत्येक तत्व से पहले तत्व सम्मिलित करता है, और परिणामी सूची लौटाता है।","def insert_element(list,element):
 list = [v for elt in list for v in (element, elt)]
 return list",[],"[""assert insert_element(['Red', 'Green', 'Black'] ,'c')==['c', 'Red', 'c', 'Green', 'c', 'Black']"", ""assert insert_element(['python', 'java'] ,'program')==['program', 'python', 'program', 'java']"", ""assert insert_element(['happy', 'sad'] ,'laugh')==['laugh', 'happy', 'laugh', 'sad']""]","आप निम्नलिखित तरीके से इसे कर सकते हैं:

```python
def insert_element_before_each(list, element):
    result = []
    for i in list:
        result.append(element)
        result.append(i)
    return result
```

इस फ़ंक्शन का उपयोग करने के लिए, आप निम्नलिखित तरीके से कर सकते हैं:

```python
print(insert_element_before_each([1, 2, 3, 4, 5], 0))
```

यह `[0, 1, 0, 2, 0, 3, 0, 4, 0, 5]` लौटाएगा, जो हर तत्व से पहले `0` सम्मिलित करता है।"
Benchmark Questions Verification V2.ipynb,252,जटिल संख्याओं को ध्रुवीय निर्देशांक में बदलने के लिए एक पायथन फ़ंक्शन लिखें।,"import cmath  
def convert(numbers):    
  num = cmath.polar(numbers)  
  return (num) ",[],"['assert convert(1) == (1.0, 0.0)', 'assert convert(4) == (4.0,0.0)', 'assert convert(5) == (5.0,0.0)']","जटिल संख्याओं को ध्रुवीय निर्देशांक में बदलने के लिए, हमें इसकी परिधि (r) और कोण (θ) की आवश्यकता होती है। यहां एक पायथन फ़ंक्शन है जो जटिल संख्या को ध्रुवीय निर्देशांक में बदलता है:

```python
import cmath

def complex_to_polar(complex_num):
    r = abs(complex_num)
    theta = cmath.phase(complex_num)
    return r, theta

# उदाहरण के लिए:
complex_num = 1 + 1j
r, theta = complex_to_polar(complex_num)
print(f""r: {r}, theta: {theta}"")
```

इस फ़ंक्शन में, `cmath.phase()` फ़ंक्शन का उपयोग कोण (θ) की गणना करने के लिए किया जाता है, और `abs()` फ़ंक्शन का उपयोग परिधि (r) की गणना करने के लिए किया जाता है।"
Benchmark Questions Verification V2.ipynb,253,एक पायथन फ़ंक्शन लिखें जो किसी दी गई सूची में पूर्णांक तत्वों की संख्या लौटाता है।,"def count_integer(list1):
    ctr = 0
    for i in list1:
        if isinstance(i, int):
            ctr = ctr + 1
    return ctr",[],"[""assert count_integer([1,2,'abc',1.2]) == 2"", 'assert count_integer([1,2,3]) == 3', 'assert count_integer([1,1.2,4,5.1]) == 2']","आप निम्नलिखित तरीके से एक पायथन फ़ंक्शन लिख सकते हैं:

```python
def count_integers(lst):
    return len([i for i in lst if type(i) == int])
```

इस फ़ंक्शन का उपयोग करके, आप किसी सूची में पूर्णांक तत्वों की संख्या का पता लगा सकते हैं। उदाहरण के लिए:

```python
lst = [1, 2, 'a', 'b', 3, 4.0, 5]
print(count_integers(lst))  # यह 4 प्रिंट करेगा
```

इस उदाहरण में, सूची में 4 पूर्णांक हैं (1, 2, 3, और 5), इसलिए फ़ंक्शन 4 लौटाता है।"
Benchmark Questions Verification V2.ipynb,255,"एक फ़ंक्शन लिखें जो एक सूची और लंबाई n लेता है, और सूची के तत्वों के सभी संयोजन (दोहराव के साथ) उत्पन्न करता है और प्रत्येक संयोजन के लिए एक टपल के साथ एक सूची लौटाता है।","from itertools import combinations_with_replacement 
def combinations_colors(l, n):
    return list(combinations_with_replacement(l,n))
",[],"['assert combinations_colors( [""Red"",""Green"",""Blue""],1)==[(\'Red\',), (\'Green\',), (\'Blue\',)]', 'assert combinations_colors( [""Red"",""Green"",""Blue""],2)==[(\'Red\', \'Red\'), (\'Red\', \'Green\'), (\'Red\', \'Blue\'), (\'Green\', \'Green\'), (\'Green\', \'Blue\'), (\'Blue\', \'Blue\')]', 'assert combinations_colors( [""Red"",""Green"",""Blue""],3)==[(\'Red\', \'Red\', \'Red\'), (\'Red\', \'Red\', \'Green\'), (\'Red\', \'Red\', \'Blue\'), (\'Red\', \'Green\', \'Green\'), (\'Red\', \'Green\', \'Blue\'), (\'Red\', \'Blue\', \'Blue\'), (\'Green\', \'Green\', \'Green\'), (\'Green\', \'Green\', \'Blue\'), (\'Green\', \'Blue\', \'Blue\'), (\'Blue\', \'Blue\', \'Blue\')]']","आप itertools मॉड्यूल का उपयोग करके इसे कर सकते हैं। यहां एक उदाहरण है:

```python
import itertools

def generate_combinations(lst, n):
    return list(itertools.product(lst, repeat=n))

# उदाहरण के लिए
print(generate_combinations([1, 2, 3], 2))
```

इस फ़ंक्शन को कॉल करने से एक सूची लौटाई जाती है जिसमें सभी संभव संयोजन होते हैं, जिनमें प्रत्येक संयोजन को एक टपल के रूप में प्रस्तुत किया जाता है। उदाहरण के लिए, `[1, 2, 3]` सूची और `n=2` के लिए, यह फ़ंक्शन `[(1, 1), (1, 2), (1, 3), (2, 1), (2, 2), (2, 3), (3, 1), (3, 2), (3, 3)]` लौटाएगा।"
Benchmark Questions Verification V2.ipynb,256,एक पायथन फ़ंक्शन लिखें जो एक गैर-नकारात्मक संख्या लेता है और दी गई गैर-नकारात्मक संख्या से कम अभाज्य संख्याओं की संख्या लौटाता है।,"def count_Primes_nums(n):
    ctr = 0
    for num in range(n):
        if num <= 1:
            continue
        for i in range(2,num):
            if (num % i) == 0:
                break
        else:
            ctr += 1
    return ctr",[],"['assert count_Primes_nums(5) == 2', 'assert count_Primes_nums(10) == 4', 'assert count_Primes_nums(100) == 25']","यहां एक पायथन फ़ंक्शन है जो आपके द्वारा वर्णित कार्य करता है:

```python
def count_primes(n):
    if n < 2:
        return 0
    primes = [1] * n
    primes[0] = primes[1] = 0
    for i in range(2, int(n**0.5) + 1):
        if primes[i]:
            primes[i*i: n: i] = [0] * len(primes[i*i: n: i])
    return sum(primes)
```

इस फ़ंक्शन का उपयोग करने के लिए, आपको बस इसे एक गैर-नकारात्मक संख्या के साथ कॉल करना होगा, जैसे कि `count_primes(10)`. यह फ़ंक्शन 10 से कम सभी अभाज्य संख्याओं की संख्या लौटाएगा."
Benchmark Questions Verification V2.ipynb,257,एक फ़ंक्शन लिखें जो दो नंबर लेता है और दूसरे नंबर और फिर पहले नंबर के साथ एक टुपल लौटाता है।,"def swap_numbers(a,b):
 temp = a
 a = b
 b = temp
 return (a,b)",[],"['assert swap_numbers(10,20)==(20,10)', 'assert swap_numbers(15,17)==(17,15)', 'assert swap_numbers(100,200)==(200,100)']","आप निम्नलिखित तरीके से एक फ़ंक्शन लिख सकते हैं:

```python
def create_tuple(num1, num2):
    return (num2, num1)
```

इस फ़ंक्शन को इस तरह उपयोग किया जा सकता है:

```python
print(create_tuple(5, 10))  # Output: (10, 5)
```"
Benchmark Questions Verification V2.ipynb,259,दिए गए दो टुपल्स को अधिकतम करने के लिए एक फ़ंक्शन लिखें।,"def maximize_elements(test_tup1, test_tup2):
  res = tuple(tuple(max(a, b) for a, b in zip(tup1, tup2))
   for tup1, tup2 in zip(test_tup1, test_tup2))
  return (res) ",[],"['assert maximize_elements(((1, 3), (4, 5), (2, 9), (1, 10)), ((6, 7), (3, 9), (1, 1), (7, 3))) == ((6, 7), (4, 9), (2, 9), (7, 10))', 'assert maximize_elements(((2, 4), (5, 6), (3, 10), (2, 11)), ((7, 8), (4, 10), (2, 2), (8, 4))) == ((7, 8), (5, 10), (3, 10), (8, 11))', 'assert maximize_elements(((3, 5), (6, 7), (4, 11), (3, 12)), ((8, 9), (5, 11), (3, 3), (9, 5))) == ((8, 9), (6, 11), (4, 11), (9, 12))']","आप निम्नलिखित तरीके से एक फ़ंक्शन लिख सकते हैं जो दो टुपल्स को अधिकतम करता है:

```python
def max_tuples(tup1, tup2):
    return max(tup1, tup2)
```

इस फ़ंक्शन का उपयोग करने के लिए, आप दो टुपल्स को इसके पैरामीटर के रूप में पास करेंगे। यह फ़ंक्शन उन दोनों में से अधिकतम टुपल को वापस करेगा।

उदाहरण:

```python
tup1 = (1, 2, 3)
tup2 = (4, 5, 6)
print(max_tuples(tup1, tup2))  # Output: (4, 5, 6)
```"
Benchmark Questions Verification V2.ipynb,260,nवाँ न्यूमैन-शैंक्स-विलियम्स अभाज्य संख्या ज्ञात करने के लिए एक फ़ंक्शन लिखें।,"def newman_prime(n): 
	if n == 0 or n == 1: 
		return 1
	return 2 * newman_prime(n - 1) + newman_prime(n - 2)",[],"['assert newman_prime(3) == 7', 'assert newman_prime(4) == 17', 'assert newman_prime(5) == 41']","यहां एक संभावित फ़ंक्शन है जो न्यूमैन-शैंक्स-विलियम्स अभाज्य संख्या की गणना करता है:

```python
import sympy

def newman_shanks_williams_prime(n):
    if n < 1:
        return ""Input must be a positive integer.""
    elif n == 1:
        return 1
    elif n == 2:
        return 7
    else:
        s = [1, 7]
        for i in range(2, n+1):
            s.append(2*s[i-1] + 3*s[i-2])
        return s[n]
```

इस फ़ंक्शन का उपयोग करके, आप nवाँ न्यूमैन-शैंक्स-विलियम्स अभाज्य संख्या ज्ञात कर सकते हैं। उदाहरण के लिए, `newman_shanks_williams_prime(3)` 31 देगा, जो तीसरी न्यूमैन-शैंक्स-विलियम्स अभाज्य संख्या है।"
Benchmark Questions Verification V2.ipynb,261,एक फ़ंक्शन लिखें जो दो टुपल्स लेता है और दिए गए टुपल्स में तत्व-वार गणितीय विभाजन ऑपरेशन करता है।,"def division_elements(test_tup1, test_tup2):
  res = tuple(ele1 // ele2 for ele1, ele2 in zip(test_tup1, test_tup2))
  return (res) ",[],"['assert division_elements((10, 4, 6, 9),(5, 2, 3, 3)) == (2, 2, 2, 3)', 'assert division_elements((12, 6, 8, 16),(6, 3, 4, 4)) == (2, 2, 2, 4)', 'assert division_elements((20, 14, 36, 18),(5, 7, 6, 9)) == (4, 2, 6, 2)']","आप निम्नलिखित फ़ंक्शन का उपयोग कर सकते हैं:

```python
def tuple_division(tuple1, tuple2):
    return tuple(i/j for i, j in zip(tuple1, tuple2))
```

यह फ़ंक्शन `zip` फ़ंक्शन का उपऔग करता है जो दो टुपल्स के तत्वों को एक साथ लूप करने की अनुमति देता है, और फिर उन्हें विभाजित करता है। यह एक नया टुपल वापस करता है जिसमें प्रत्येक तत्व दोनों टुपल्स के तत्वों का विभाजन होता है।

कृपया ध्यान दें कि यदि दूसरे टुपल में शून्य होता है, तो यह फ़ंक्शन एक त्रुटि उत्पन्न करेगा, क्योंकि आप किसी संख्या को शून्य से विभाजित नहीं कर सकते।"
Benchmark Questions Verification V2.ipynb,262,"एक फ़ंक्शन लिखें जो एक सूची और एक पूर्णांक L लेता है और दी गई सूची को दो भागों में विभाजित करता है जहां सूची के पहले भाग की लंबाई L है, और परिणामी सूचियों को एक टुपल में लौटाता है।","def split_two_parts(list1, L):
    return list1[:L], list1[L:]",[],"['assert split_two_parts([1,1,2,3,4,4,5,1],3)==([1, 1, 2], [3, 4, 4, 5, 1])', ""assert split_two_parts(['a', 'b', 'c', 'd'],2)==(['a', 'b'], ['c', 'd'])"", ""assert split_two_parts(['p', 'y', 't', 'h', 'o', 'n'],4)==(['p', 'y', 't', 'h'], ['o', 'n'])""]","आप निम्नलिखित फ़ंक्शन का उपयोग कर सकते हैं:

```python
def split_list(lst, L):
    return (lst[:L], lst[L:])
```

इस फ़ंक्शन का उपयोग करने के लिए, आप एक सूची और एक पूर्णांक L पास करेंगे, और यह एक टुपल लौटाएगा जिसमें दो सूचियाँ होंगी - पहली सूची में पहले L तत्व होंगे, और दूसरी सूची में बाकी के तत्व होंगे।

उदाहरण के लिए:

```python
print(split_list([1, 2, 3, 4, 5, 6], 3))
```

यह निम्नलिखित आउटपुट देगा:

```python
([1, 2, 3], [4, 5, 6])
```"
Benchmark Questions Verification V2.ipynb,264,कुत्ते के वर्षों में कुत्ते की उम्र की गणना करने के लिए एक फ़ंक्शन लिखें।,"def dog_age(h_age):
 if h_age < 0:
 	exit()
 elif h_age <= 2:
	 d_age = h_age * 10.5
 else:
	 d_age = 21 + (h_age - 2)*4
 return d_age",[],"['assert dog_age(12)==61', 'assert dog_age(15)==73', 'assert dog_age(24)==109']","आम तौर पर कहा जाता है कि हर एक कुत्ते का वर्ष मानव के 7 वर्षों के बराबर होता है। इसलिए, निम्नलिखित फ़ंक्शन कुत्ते की उम्र को मानव वर्षों में बदल देगा:

```python
def dog_years_to_human_years(dog_years):
    return dog_years * 7
```

इस फ़ंक्शन का उपयोग करने के लिए, आपको केवल कुत्ते की उम्र (कुत्ते के वर्षों में) को इसके आर्गुमेंट के रूप में पास करना होगा। उदाहरण के लिए:

```python
print(dog_years_to_human_years(3))  # Outputs: 21
```

यह उदाहरण दिखाता है कि 3 वर्ष का कुत्ता मानव के लिए 21 वर्ष का होता है।"
Benchmark Questions Verification V2.ipynb,265,"एक फ़ंक्शन लिखें जो एक सूची और एक पूर्णांक n लेता है और प्रत्येक nवें तत्व के लिए एक सूची को विभाजित करता है, जिसके परिणामस्वरूप सूचियों की एक सूची वापस आती है।","def list_split(S, step):
    return [S[i::step] for i in range(step)]",[],"[""assert list_split(['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n'],3)==[['a', 'd', 'g', 'j', 'm'], ['b', 'e', 'h', 'k', 'n'], ['c', 'f', 'i', 'l']]"", 'assert list_split([1,2,3,4,5,6,7,8,9,10,11,12,13,14],3)==[[1,4,7,10,13], [2,5,8,11,14], [3,6,9,12]]', ""assert list_split(['python','java','C','C++','DBMS','SQL'],2)==[['python', 'C', 'DBMS'], ['java', 'C++', 'SQL']]""]","आप निम्नलिखित फ़ंक्शन का उपयोग कर सकते हैं:

```python
def divide_list(lst, n):
    return [lst[i:i+n] for i in range(0, len(lst), n)]
```

यह फ़ंक्शन एक सूची `lst` और एक पूर्णांक `n` लेता है, और `lst` को `n` तत्वों की सूचियों में विभाजित करता है। यह फ़ंक्शन एक सूची की सूची वापस करता है, जिसमें प्रत्येक सूची `n` तत्वों की होती है।

उदाहरण के लिए, यदि आप इसे `[1, 2, 3, 4, 5, 6, 7, 8, 9]` और `3` के साथ कॉल करते हैं, तो यह `[[1, 2, 3], [4, 5, 6], [7, 8, 9]]` वापस करेगा।"
Benchmark Questions Verification V2.ipynb,266,किसी घन की भुजा की लंबाई को देखते हुए उसका पार्श्व पृष्ठीय क्षेत्रफल ज्ञात करने के लिए एक फ़ंक्शन लिखें।,"def lateralsurface_cube(l):
  LSA = 4 * (l * l)
  return LSA",[],"['assert lateralsurface_cube(5)==100', 'assert lateralsurface_cube(9)==324', 'assert lateralsurface_cube(10)==400']","घन का पार्श्व पृष्ठीय क्षेत्रफल निम्न सूत्र से ज्ञात किया जा सकता है:

पार्श्व पृष्ठीय क्षेत्रफल = 6 * (भुजा की लंबाई) ^ 2

इसे Python में फ़ंक्शन के रूप में लिखा जा सकता है:

```python
def cube_surface_area(side_length):
    return 6 * (side_length ** 2)
```

इस फ़ंक्शन का उपयोग निम्न प्रकार से किया जा सकता है:

```python
print(cube_surface_area(5))  # यह 150 प्रिंट करेगा
```"
Benchmark Questions Verification V2.ipynb,267,एक पायथन फ़ंक्शन लिखें जो एक पूर्णांक n लेता है और पहले n विषम प्राकृतिक संख्याओं के वर्गों का योग लौटाता है।,"def square_Sum(n):  
    return int(n*(4*n*n-1)/3) ",[],"['assert square_Sum(2) == 10', 'assert square_Sum(3) == 35', 'assert square_Sum(4) == 84']","आप निम्नलिखित पायथन फ़ंक्शन का उपयोग कर सकते हैं:

```python
def sum_of_squares_of_odd_numbers(n):
    return sum(i**2 for i in range(1, 2*n, 2))
```

यह फ़ंक्शन `range` फ़ंक्शन का उपयोग करके पहले `n` विषम संख्याओं की सूची उत्पन्न करता है, फिर `sum` फ़ंक्शन का उपयोग करके उनके वर्गों का योग लौटाता है।"
Benchmark Questions Verification V2.ipynb,268,n&#39;वें तारा संख्या को खोजने के लिए एक फ़ंक्शन लिखें।,"def find_star_num(n): 
	return (6 * n * (n - 1) + 1) ",[],"['assert find_star_num(3) == 37', 'assert find_star_num(4) == 73', 'assert find_star_num(5) == 121']","आप नीचे दिए गए कोड का उपयोग कर सकते हैं:

```python
def nth_star_number(n):
    return 6 * n * (n - 1) + 1
```

यह फ़ंक्शन `n`वें स्टार नंबर को खोजता है। स्टार नंबर एक ऐसी संख्या होती है जिसे आप तारों के आकार में व्यवस्थित कर सकते हैं, जैसे कि पेंटागनल नंबर या हेक्सागोनल नंबर। इसे गणितीय रूप में `6n(n - 1) + 1` के रूप में व्याख्या किया जा सकता है, जहां `n` वह संख्या है जिसका स्टार नंबर आप खोज रहे हैं।"
Benchmark Questions Verification V2.ipynb,269,किसी कैरेक्टर का एएससीआईआई मान ज्ञात करने के लिए एक फ़ंक्शन लिखें।,"def ascii_value(k):
  ch=k
  return ord(ch)",[],"[""assert ascii_value('A')==65"", ""assert ascii_value('R')==82"", ""assert ascii_value('S')==83""]","आप निम्नलिखित फ़ंक्शन का उपयोग कर सकते हैं:

```python
def get_ascii_value(character):
    return ord(character)
```

इस फ़ंक्शन का उपयोग करने के लिए, आप बस किसी भी कैरेक्टर को इसमें पास करें:

```python
print(get_ascii_value('A'))  # यह 65 प्रिंट करेगा
```

यह फ़ंक्शन `ord` फ़ंक्शन का उपयोग करता है, जो पायथन में एक बिल्ट-इन फ़ंक्शन है और यह एक कैरेक्टर का एएससीआईआई मान लौटाता है।"
Benchmark Questions Verification V2.ipynb,270,किसी सूची के सम स्थानों पर सम संख्याओं का योग ज्ञात करने के लिए एक पायथन फ़ंक्शन लिखें।,"def sum_even_and_even_index(arr):  
    i = 0
    sum = 0
    for i in range(0, len(arr),2): 
        if (arr[i] % 2 == 0) : 
            sum += arr[i]  
    return sum",[],"['assert sum_even_and_even_index([5, 6, 12, 1, 18, 8]) == 30', 'assert sum_even_and_even_index([3, 20, 17, 9, 2, 10, 18, 13, 6, 18]) == 26', 'assert sum_even_and_even_index([5, 6, 12, 1]) == 12']","आप निम्नलिखित पायथन फ़ंक्शन का उपयोग कर सकते हैं:

```python
def sum_even_index_numbers(lst):
    return sum(lst[i] for i in range(0, len(lst), 2))
```

यह फ़ंक्शन एक सूची `lst` लेता है और सम स्थानों पर संख्याओं का योग लौटाता है। यह `range` फ़ंक्शन का उपयोग करके सूची के हर दूसरे तत्व के लिए चलता है, शुरुआत करता है `0` से (जो सूची का पहला तत्व होता है, जिसे हम सम मानते हैं क्योंकि पायथन में इंडेक्सिंग `0`-आधारित होती है), और फिर हर दूसरे तत्व पर जाता है (`2` कदम)."
Benchmark Questions Verification V2.ipynb,271,एक पायथन फ़ंक्शन लिखें जो एक पूर्णांक n लेता है और पहले n सम प्राकृतिक संख्याओं का योग ढूंढता है जिन्हें पांचवीं शक्ति तक बढ़ाया जाता है।,"def even_Power_Sum(n): 
    sum = 0; 
    for i in range(1,n+1): 
        j = 2*i; 
        sum = sum + (j*j*j*j*j); 
    return sum; ",[],"['assert even_Power_Sum(2) == 1056', 'assert even_Power_Sum(3) == 8832', 'assert even_Power_Sum(1) == 32']","आप निम्नलिखित पायथन फ़ंक्शन का उपयोग कर सकते हैं:

```python
def sum_of_powers(n):
    return sum(i**5 for i in range(1, n+1))
```

इस फ़ंक्शन का उपयोग करके, आप पहले n सम प्राकृतिक संख्याओं का योग जो पांचवीं शक्ति तक बढ़ाया जाता है, निकाल सकते हैं। उदाहरण के लिए, `sum_of_powers(3)` का परिणाम `276` होगा, क्योंकि 1^5 + 2^5 + 3^5 = 276."
Benchmark Questions Verification V2.ipynb,272,एक फ़ंक्शन लिखें जो टुपल्स की एक सूची लेता है और प्रत्येक टुपल के पीछे के तत्व वाली एक सूची लौटाता है।,"def rear_extract(test_list):
  res = [lis[-1] for lis in test_list]
  return (res) ",[],"[""assert rear_extract([(1, 'Rash', 21), (2, 'Varsha', 20), (3, 'Kil', 19)]) == [21, 20, 19]"", ""assert rear_extract([(1, 'Sai', 36), (2, 'Ayesha', 25), (3, 'Salman', 45)]) == [36, 25, 45]"", ""assert rear_extract([(1, 'Sudeep', 14), (2, 'Vandana', 36), (3, 'Dawood', 56)]) == [14, 36, 56]""]","आप निम्नलिखित फ़ंक्शन का उपयोग कर सकते हैं:

```python
def last_element_of_tuples(tuples_list):
    return [t[-1] for t in tuples_list]
```

इस फ़ंक्शन का उपयोग करने के लिए, आप इसे निम्नलिखित तरीके से कॉल कर सकते हैं:

```python
print(last_element_of_tuples([(1, 2), (3, 4), (5, 6)]))  # Output: [2, 4, 6]
```

यह फ़ंक्शन एक सूची comprehension का उपयोग करता है जो प्रत्येक टुपल के अंतिम तत्व को एक नई सूची में डालता है। यह फ़ंक्शन टुपल्स की सूची को इनपुट के रूप में लेता है और प्रत्येक टुपल के अंतिम तत्व की सूची को वापस लौटाता है।"
Benchmark Questions Verification V2.ipynb,273,एक फ़ंक्शन लिखें जो दो टुपल्स लेता है और उसी इंडेक्स के साथ पहले टुपल के तत्वों को दूसरे टुपल के तत्वों से घटाता है।,"def substract_elements(test_tup1, test_tup2):
  res = tuple(map(lambda i, j: i - j, test_tup1, test_tup2))
  return (res) ",[],"['assert substract_elements((10, 4, 5), (2, 5, 18)) == (8, -1, -13)', 'assert substract_elements((11, 2, 3), (24, 45 ,16)) == (-13, -43, -13)', 'assert substract_elements((7, 18, 9), (10, 11, 12)) == (-3, 7, -3)']","आप निम्नलिखित फ़ंक्शन का उपयोग कर सकते हैं:

```python
def subtract_tuples(t1, t2):
    return tuple(e1-e2 for e1, e2 in zip(t1, t2))
```

यह फ़ंक्शन `zip` फ़ंक्शन का उपऔग करता है जो दो टुपल्स के तत्वों को एक साथ लूप करने की अनुमति देता है, और फिर उन्हें घटाता है। इसका परिणाम एक नया टुपल होता है जिसमें पहले टुपल के प्रत्येक तत्व से दूसरे टुपल के संबंधित तत्व को घटाया गया है।"
Benchmark Questions Verification V2.ipynb,274,एक पायथन फ़ंक्शन लिखें जो एक सकारात्मक पूर्णांक n लेता है और सम सूचकांक द्विपद गुणांक का योग ढूंढता है।,"import math  
def even_binomial_Coeff_Sum( n): 
    return (1 << (n - 1)) ",[],"['assert even_binomial_Coeff_Sum(4) == 8', 'assert even_binomial_Coeff_Sum(6) == 32', 'assert even_binomial_Coeff_Sum(2) == 2']","यहां एक संभावित पायथन फ़ंक्शन है जो आपके विवरण के अनुसार काम करता है:

```python
def sum_even_indexed_digits(n):
    # संख्या को स्ट्रिंग में परिवर्तित करें
    str_n = str(n)
    # सम सूचकांक द्विपद गुणांक का योग
    sum = 0
    for i in range(0, len(str_n), 2):
        sum += int(str_n[i])
    return sum
```

इस फ़ंक्शन का उपयोग करने के लिए, आप बस इसे एक सकारात्मक पूर्णांक के साथ कॉल करें, जैसे कि `sum_even_indexed_digits(123456)`. यह सम सूचकांक द्विपद गुणांक का योग लौटाएगा."
Benchmark Questions Verification V2.ipynb,276,एक फ़ंक्शन लिखें जो सिलेंडर की त्रिज्या और ऊंचाई लेता है और आयतन लौटाता है।,"def volume_cylinder(r,h):
  volume=3.1415*r*r*h
  return volume",['import math'],"['assert math.isclose(volume_cylinder(10,5), 1570.7500000000002, rel_tol=0.001)', 'assert math.isclose(volume_cylinder(4,5), 251.32000000000002, rel_tol=0.001)', 'assert math.isclose(volume_cylinder(4,10), 502.64000000000004, rel_tol=0.001)']","आप निम्नलिखित तरीके से एक फ़ंक्शन लिख सकते हैं:

```python
import math

def cylinder_volume(radius, height):
    return math.pi * radius**2 * height
```

इस फ़ंक्शन का उपयोग करने के लिए, आपको सिलेंडर की त्रिज्या और ऊंचाई पास करनी होगी। उदाहरण के लिए:

```python
print(cylinder_volume(3, 5))
```

यह सिलेंडर का आयतन लौटाएगा जिसकी त्रिज्या 3 और ऊंचाई 5 है।"
Benchmark Questions Verification V2.ipynb,277,एक फ़ंक्शन लिखें जो एक शब्दकोश और पूर्णांक n लेता है और शब्दकोश को फ़िल्टर करता है जिसमें केवल n से अधिक या उसके बराबर मान वाली प्रविष्टियाँ शामिल होती हैं।,"def dict_filter(dict,n):
 result = {key:value for (key, value) in dict.items() if value >=n}
 return result",[],"[""assert dict_filter({'Cierra Vega': 175, 'Alden Cantrell': 180, 'Kierra Gentry': 165, 'Pierre Cox': 190},170)=={'Cierra Vega': 175, 'Alden Cantrell': 180, 'Pierre Cox': 190}"", ""assert dict_filter({'Cierra Vega': 175, 'Alden Cantrell': 180, 'Kierra Gentry': 165, 'Pierre Cox': 190},180)=={ 'Alden Cantrell': 180, 'Pierre Cox': 190}"", ""assert dict_filter({'Cierra Vega': 175, 'Alden Cantrell': 180, 'Kierra Gentry': 165, 'Pierre Cox': 190},190)=={ 'Pierre Cox': 190}""]","आप निम्नलिखित तरीके से एक फ़ंक्शन लिख सकते हैं:

```python
def filter_dict(d, n):
    return {k: v for k, v in d.items() if v >= n}
```

इस फ़ंक्शन में, `d` एक शब्दकोश है और `n` एक पूर्णांक है। फ़ंक्शन शब्दकोश `d` के हर प्रविष्टि के लिए चेक करता है कि उसका मान `n` से अधिक या उसके बराबर है या नहीं। यदि हां, तो वह प्रविष्टि नई शब्दकोश में शामिल की जाती है। फ़ंक्शन फ़िल्टर किए गए शब्दकोश को वापस करता है।"
Benchmark Questions Verification V2.ipynb,278,दिए गए टुपल में टुपल तत्व से पहले आने वाले तत्वों की संख्या ज्ञात करने के लिए एक फ़ंक्शन लिखें।,"def count_first_elements(test_tup):
  for count, ele in enumerate(test_tup):
    if isinstance(ele, tuple):
      break
  return (count) ",[],"['assert count_first_elements((1, 5, 7, (4, 6), 10) ) == 3', 'assert count_first_elements((2, 9, (5, 7), 11) ) == 2', 'assert count_first_elements((11, 15, 5, 8, (2, 3), 8) ) == 4']","आप निम्नलिखित फ़ंक्शन का उपयोग कर सकते हैं:

```python
def count_elements_before_tuple(input_tuple):
    count = 0
    for i in input_tuple:
        if isinstance(i, tuple):
            break
        count += 1
    return count
```

यह फ़ंक्शन एक टुपल को इनपुट के रूप में लेता है और टुपल तत्व से पहले आने वाले तत्वों की संख्या को गिनती है। यदि इनपुट टुपल में कोई टुपल तत्व नहीं है, तो यह फ़ंक्शन 0 लौटाएगा।"
Benchmark Questions Verification V2.ipynb,279,nवीं दशकोणीय संख्या ज्ञात करने के लिए एक फ़ंक्शन लिखें।,"def is_num_decagonal(n): 
	return 4 * n * n - 3 * n ",[],"['assert is_num_decagonal(3) == 27', 'assert is_num_decagonal(7) == 175', 'assert is_num_decagonal(10) == 370']","आप निम्नलिखित तरीके से एक फ़ंक्शन लिख सकते हैं जो दशकोणीय संख्या को ज्ञात करता है:

```python
def decimal_number(n):
    return int(n, 10)
```

इस फ़ंक्शन का उपयोग करने के लिए, आप निम्नलिखित तरीके से कॉल कर सकते हैं:

```python
print(decimal_number('123'))
```

यह '123' को दशकोणीय संख्या में परिवर्तित करेगा और 123 प्रिंट करेगा."
Benchmark Questions Verification V2.ipynb,280,एक फ़ंक्शन लिखें जो एक सरणी और तत्व लेता है और एक बूलियन युक्त टुपल लौटाता है जो इंगित करता है कि तत्व सरणी में है और तत्व की सूचकांक स्थिति (या -1 यदि तत्व नहीं मिला है)।,"def sequential_search(dlist, item):
    pos = 0
    found = False
    while pos < len(dlist) and not found:
        if dlist[pos] == item:
            found = True
        else:
            pos = pos + 1
    return found, pos",[],"['assert sequential_search([11,23,58,31,56,77,43,12,65,19],31) == (True, 3)', 'assert sequential_search([12, 32, 45, 62, 35, 47, 44, 61],61) == (True, 7)', 'assert sequential_search([9, 10, 17, 19, 22, 39, 48, 56],48) == (True, 6)']","आप निम्नलिखित फ़ंक्शन का उपयोग कर सकते हैं:

```python
def find_element_in_list(lst, element):
    if element in lst:
        return True, lst.index(element)
    else:
        return False, -1
```

इस फ़ंक्शन का उपयोग करने के लिए, आप एक सूची और एक तत्व पास करेंगे, और यह एक टुपल लौटाएगा जिसमें बूलियन मान और सूचकांक स्थिति (या -1 यदि तत्व सूची में नहीं है) होगी।

उदाहरण के लिए:

```python
print(find_element_in_list([1, 2, 3, 4, 5], 3))  # Output: (True, 2)
print(find_element_in_list([1, 2, 3, 4, 5], 6))  # Output: (False, -1)
```"
Benchmark Questions Verification V2.ipynb,281,यह जांचने के लिए एक पायथन फ़ंक्शन लिखें कि किसी दी गई सूची के तत्व अद्वितीय हैं या नहीं।,"def all_unique(test_list):
    if len(test_list) > len(set(test_list)):
        return False
    return True",[],"['assert all_unique([1,2,3]) == True', 'assert all_unique([1,2,1,2]) == False', 'assert all_unique([1,2,3,4,5]) == True']","आप निम्नलिखित पायथन फ़ंक्शन का उपयोग कर सकते हैं:

```python
def check_unique(lst):
    if len(lst) == len(set(lst)):
        return True
    else:
        return False
```

इस फ़ंक्शन में, हम सूची के तत्वों को एक सेट में परिवर्तित करते हैं। सेट में, सभी तत्व अद्वितीय होते हैं, इसलिए यदि सूची की लंबाई और सेट की लंबाई समान है, तो सभी तत्व अद्वितीय हैं। यदि वे समान नहीं हैं, तो कुछ तत्व डुप्लिकेट हैं।"
Benchmark Questions Verification V2.ipynb,282,तत्व-वार दो सूचियों को घटाने के लिए एक फ़ंक्शन लिखें।,"def sub_list(nums1,nums2):
  result = map(lambda x, y: x - y, nums1, nums2)
  return list(result)",[],"['assert sub_list([1, 2, 3],[4,5,6])==[-3,-3,-3]', 'assert sub_list([1,2],[3,4])==[-2,-2]', 'assert sub_list([90,120],[50,70])==[40,50]']","आप निम्नलिखित तरीके से एक फ़ंक्शन लिख सकते हैं:

```python
def subtract_lists(list1, list2):
    return [a - b for a, b in zip(list1, list2)]
```

इस फ़ंक्शन का उपयोग करने के लिए, आप दो सूचियों को इसमें पास कर सकते हैं:

```python
list1 = [5, 4, 3, 2, 1]
list2 = [1, 2, 3, 4, 5]
print(subtract_lists(list1, list2))  # Output: [4, 2, 0, -2, -4]
```

यह फ़ंक्शन `zip` फ़ंक्शन का उपयोग करके दो सूचियों के बीच तत्व-वार घटाव करता है। यदि सूचियाँ विभिन्न लंबाई की होती हैं, तो `zip` फ़ंक्शन सबसे छोटी सूची के आकार के अनुसार युग्म बनाएगा।"
Benchmark Questions Verification V2.ipynb,283,एक पायथन फ़ंक्शन को एक पूर्णांक में लिखें और जांचें कि पूर्णांक में प्रत्येक अंक की आवृत्ति अंक से कम या उसके बराबर है या नहीं।,"def validate(n): 
    for i in range(10): 
        temp = n;  
        count = 0; 
        while (temp): 
            if (temp % 10 == i): 
                count+=1;  
            if (count > i): 
                return False
            temp //= 10; 
    return True",[],"['assert validate(1234) == True', 'assert validate(51241) == False', 'assert validate(321) == True']","आप निम्नलिखित तरीके से एक पायथन फ़ंक्शन लिख सकते हैं:

```python
def check_frequency(n):
    n = str(n)
    for i in n:
        if n.count(i) > int(i):
            return False
    return True
```

इस फ़ंक्शन में, हम पहले पूर्णांक को एक स्ट्रिंग में परिवर्तित करते हैं, ताकि हम उसके अंकों को आसानी से इतरेट कर सकें। फिर, हम हर अंक के लिए, उसकी आवृत्ति की जांच करते हैं। यदि किसी अंक की आवृत्ति उस अंक से अधिक होती है, तो हम False लौटते हैं। यदि हम सभी अंकों के लिए इसे चेक करते हैं और कोई भी अंक इस शर्त को पूरा नहीं करता है, तो हम True लौटते हैं।"
Benchmark Questions Verification V2.ipynb,284,एक फ़ंक्शन लिखें जो एक सूची और तत्व लेता है और जांचता है कि सूची में सभी आइटम दिए गए तत्व के बराबर हैं या नहीं।,"def check_element(list,element):
  check_element=all(v== element for v in list)
  return check_element",[],"['assert check_element([""green"", ""orange"", ""black"", ""white""],\'blue\')==False', 'assert check_element([1,2,3,4],7)==False', 'assert check_element([""green"", ""green"", ""green"", ""green""],\'green\')==True']","आप निम्नलिखित फ़ंक्शन का उपयोग कर सकते हैं:

```python
def check_elements(lst, element):
    return all(x == element for x in lst)
```

इस फ़ंक्शन का उपयोग करने के लिए, आप एक सूची और एक तत्व पास करेंगे, और यह वापस लौटेगा `True` अगर सभी आइटम सूची में दिए गए तत्व के बराबर हैं, अन्यथा `False`."
Benchmark Questions Verification V2.ipynb,285,एक फ़ंक्शन लिखें जो जाँचता है कि क्या स्ट्रिंग में &#39;ए&#39; वर्ण के बाद दो या तीन &#39;बी&#39; वर्ण हैं।,"import re
def text_match_two_three(text):
        patterns = 'ab{2,3}'
        if re.search(patterns,  text):
                return True
        else:
                return False",[],"['assert text_match_two_three(""ac"")==(False)', 'assert text_match_two_three(""dc"")==(False)', 'assert text_match_two_three(""abbbba"")==(True)']","आप इसे निम्नलिखित तरीके से कर सकते हैं:

```python
import re

def check_string(s):
    return bool(re.search('ए(ब{2,3})', s))
```

इस फ़ंक्शन में, हमें एक रेगुलर एक्सप्रेशन का उपयोग करके जाँचना होगा कि क्या स्ट्रिंग में 'ए' के बाद दो या तीन 'बी' हैं। यदि हां, तो यह फ़ंक्शन `True` लौटाएगा, अन्यथा `False`."
Benchmark Questions Verification V2.ipynb,286,संशोधित सरणी में सन्निहित सरणी का सबसे बड़ा योग खोजने के लिए एक फ़ंक्शन लिखें जो दिए गए सरणी को k बार दोहराकर बनता है।,"def max_sub_array_sum_repeated(a, n, k): 
	max_so_far = -2147483648
	max_ending_here = 0
	for i in range(n*k): 
		max_ending_here = max_ending_here + a[i%n] 
		if (max_so_far < max_ending_here): 
			max_so_far = max_ending_here 
		if (max_ending_here < 0): 
			max_ending_here = 0
	return max_so_far",[],"['assert max_sub_array_sum_repeated([10, 20, -30, -1], 4, 3) == 30', 'assert max_sub_array_sum_repeated([-1, 10, 20], 3, 2) == 59', 'assert max_sub_array_sum_repeated([-1, -2, -3], 3, 3) == -1']","आप निम्नलिखित फ़ंक्शन का उपयोग कर सकते हैं:

```python
def find_max_sum(arr, k):
    # सरणी को k बार दोहराने के लिए
    arr = arr * k

    # सबसे बड़ा योग खोजने के लिए
    max_sum = float('-inf')
    current_sum = 0

    for num in arr:
        current_sum = max(current_sum + num, num)
        max_sum = max(max_sum, current_sum)

    return max_sum
```

इस फ़ंक्शन का उपयोग निम्नलिखित तरीके से किया जा सकता है:

```python
arr = [1, 2, 3, 4, 5]
k = 3
print(find_max_sum(arr, k))  # यह 45 प्रिंट करेगा
```

यह फ़ंक्शन काम करता है इसलिए क्योंकि यह सरणी को k बार दोहराता है, और फिर कड़ी से कड़ी जोड़ता है, हमेशा अगले नंबर के साथ जोड़ने का फैसला करने के लिए मौजूदा योग की तुलना करता है। यदि अगला नंबर अकेले ही बड़ा होता है, तो यह मौजूदा योग को छोड़ देता है और नई शुरुआत करता है। इसे कड़ी से कड़ी जोड़ने की विधि कहा जाता है।"
Benchmark Questions Verification V2.ipynb,287,एक पायथन फ़ंक्शन लिखें जो एक पूर्णांक n लेता है और पहले n सम प्राकृतिक संख्याओं के वर्गों का योग लौटाता है।,"def square_Sum(n):  
    return int(2*n*(n+1)*(2*n+1)/3)",[],"['assert square_Sum(2) == 20', 'assert square_Sum(3) == 56', 'assert square_Sum(4) == 120']","आप निम्नलिखित पायथन फ़ंक्शन का उपयोग कर सकते हैं:

```python
def sum_of_squares(n):
    return sum(i**2 for i in range(2, 2*n+1, 2))
```

यह फ़ंक्शन `range` फ़ंक्शन का उपयोग करके 2 से लेकर `2*n+1` तक की सभी सम संख्याओं के वर्गों का योग लौटाता है। `range` फ़ंक्शन का तीसरा पैरामीटर संख्याओं के बीच की वृद्धि को निर्धारित करता है, जो इस मामले में 2 है, इसलिए यह केवल सम संख्याओं को शामिल करता है।"
Ellen's Copy of Benchmark Questions Verification V2.ipynb,290,सूचियों की सूची में अधिकतम लंबाई की सूची खोजने के लिए एक फ़ंक्शन लिखें।,"def max_length(list1):
    max_length = max(len(x) for x in  list1 )  
    max_list = max((x) for x in   list1)
    return(max_length, max_list)",[],"['assert max_length([[0], [1, 3], [5, 7], [9, 11], [13, 15, 17]])==(3, [13, 15, 17])', 'assert max_length([[1], [5, 7], [10, 12, 14,15]])==(4, [10, 12, 14,15])', 'assert max_length([[5], [15,20,25]])==(3, [15,20,25])']","आप निम्नलिखित फ़ंक्शन का उपयोग कर सकते हैं:

```python
def longest_list(list_of_lists):
    return max(list_of_lists, key=len)
```

यह फ़ंक्शन `max` फ़ंक्शन का उपऔग करता है जिसका `key` पैरामीटर `len` फ़ंक्शन को निर्दिष्ट करता है, जिससे यह लंबाई के आधार पर अधिकतम सूची खोजता है।

उदाहरण के लिए:

```python
print(longest_list([[1, 2, 3], [1, 2, 3, 4, 5], [1, 2]]))
```

यह `[1, 2, 3, 4, 5]` प्रिंट करेगा, क्योंकि यह सबसे लंबी सूची है।"
Ellen's Copy of Benchmark Questions Verification V2.ipynb,291,"बाड़ को पेंट करने के तरीकों की संख्या जानने के लिए एक फ़ंक्शन लिखें, ताकि अधिकतम 2 आसन्न पोस्टों में एन पोस्ट और के रंगों के साथ दिए गए बाड़ के लिए समान रंग हो।","def count_no_of_ways(n, k): 
	dp = [0] * (n + 1) 
	total = k 
	mod = 1000000007
	dp[1] = k 
	dp[2] = k * k	 
	for i in range(3,n+1): 
		dp[i] = ((k - 1) * (dp[i - 1] + dp[i - 2])) % mod 
	return dp[n]",[],"['assert count_no_of_ways(2, 4) == 16', 'assert count_no_of_ways(3, 2) == 6', 'assert count_no_of_ways(4, 4) == 228']","यह समस्या एक डायनामिक प्रोग्रामिंग समस्या है, जिसमें हमें एक बाड़ को पेंट करने के तरीकों की संख्या जाननी होती है, ताकि अधिकतम 2 आसन्न पोस्टों में एन पोस्ट और के रंगों के साथ दिए गए बाड़ के लिए समान रंग हो।

इसे समझने का एक तरीका यह हो सकता है कि हमें दो विभिन्न श्रेणियों की संख्या ट्रैक करनी होती है - एक जहां अंतिम दो पोस्ट समान रंग के होते हैं, और दूसरी जहां वे अलग होते हैं।

यहां एक संभावित समाधान है:

```python
def numWays(n, k):
    if n == 0:
        return 0
    elif n == 1:
        return k
    elif n == 2:
        return k*k
    else:
        same = k
        diff = k*(k-1)
        for _ in range(3, n+1):
            same, diff = diff, (same+diff)*(k-1)
        return same + diff
```

इस फ़ंक्शन में, `n` पोस्टों की संख्या है और `k` उपलब्ध रंगों की संख्या है। यह फ़ंक्शन `n` पोस्टों को पेंट करने के तरीकों की संख्या लौटाता है, ताकि कोई भी दो आसन्न पोस्ट समान रंग न हों।"
Ellen's Copy of Benchmark Questions Verification V2.ipynb,292,दो संख्याओं का भागफल ज्ञात करने के लिए एक पायथन फ़ंक्शन लिखें (निकटतम पूर्णांक तक पूर्णांकित करें)।,"def find(n,m):  
    q = n//m 
    return (q)",[],"['assert find(10,3) == 3', 'assert find(4,2) == 2', 'assert find(20,5) == 4']","आप निम्नलिखित पायथन फ़ंक्शन का उपयोग कर सकते हैं:

```python
def divide_numbers(num1, num2):
    if num2 == 0:
        return ""भाग संख्या शून्य नहीं हो सकती""
    else:
        return round(num1 / num2)
```

इस फ़ंक्शन का उपयोग करने के लिए, आपको दो संख्याएं इसमें देनी होंगी। यह फ़ंक्शन पहली संख्या को दूसरे से भाग देगा और निकटतम पूर्णांक तक पूर्णांकित करेगा। यदि दूसरी संख्या शून्य होती है, तो यह एक त्रुटि संदेश देगा, क्योंकि किसी भी संख्या को शून्य से भाग नहीं किया जा सकता।"
Ellen's Copy of Benchmark Questions Verification V2.ipynb,293,समकोण त्रिभुज की तीसरी भुजा ज्ञात करने के लिए एक फ़ंक्शन लिखें।,"import math
def otherside_rightangle(w,h):
  s=math.sqrt((w*w)+(h*h))
  return s",[],"['assert otherside_rightangle(7,8)==10.63014581273465', 'assert otherside_rightangle(3,4)==5', 'assert otherside_rightangle(7,15)==16.55294535724685']","आप निम्नलिखित फ़ंक्शन का उपयोग कर सकते हैं। यह फ़ंक्शन पायथागोरस के थियोरम का उपयोग करके समकोण त्रिभुज की तीसरी भुजा की गणना करता है।

```python
import math

def calculate_hypotenuse(side1, side2):
    return math.sqrt(side1**2 + side2**2)
```

इस फ़ंक्शन का उपयोग करने के लिए, आपको बस दो भुजाओं की लंबाई प्रदान करनी होगी। उदाहरण के लिए:

```python
print(calculate_hypotenuse(3, 4))  # Output: 5.0
```

यदि आप तीसरी भुजा की जगह विपरीत भुजा की गणना करना चाहते हैं, तो आप निम्नलिखित फ़ंक्शन का उपयोग कर सकते हैं:

```python
def calculate_opposite_side(hypotenuse, adjacent_side):
    return math.sqrt(hypotenuse**2 - adjacent_side**2)
```

इस फ़ंक्शन का उपयोग करने के लिए, आपको कर्ण और समीपस्थ भुजा की लंबाई प्रदान करनी होगी। उदाहरण के लिए:

```python
print(calculate_opposite_side(5, 3))  # Output: 4.0
```"
Ellen's Copy of Benchmark Questions Verification V2.ipynb,294,किसी दी गई विषमांगी सूची में अधिकतम मान ज्ञात करने के लिए एक फ़ंक्शन लिखें।,"def max_val(listval):
     max_val = max(i for i in listval if isinstance(i, int)) 
     return(max_val)",[],"[""assert max_val(['Python', 3, 2, 4, 5, 'version'])==5"", ""assert max_val(['Python', 15, 20, 25])==25"", ""assert max_val(['Python', 30, 20, 40, 50, 'version'])==50""]","आप निम्नलिखित फ़ंक्शन का उपयोग कर सकते हैं:

```python
def find_max_value(lst):
    return max(lst)
```

इस फ़ंक्शन का उपयोग करने के लिए, आपको बस अपनी सूची को इसके रूप में आपूर्ति करनी होगी। उदाहरण के लिए:

```python
numbers = [1, 2, 3, 4, 5]
print(find_max_value(numbers))  # यह 5 प्रिंट करेगा
```

यह फ़ंक्शन `max` फ़ंक्शन का उपयोग करता है, जो एक इटरेबल (जैसे कि एक सूची) में सबसे बड़े मान को लौटाता है। यदि सूची खाली है, तो यह एक `ValueError` उठाएगा।"
Ellen's Copy of Benchmark Questions Verification V2.ipynb,295,किसी संख्या के सभी विभाजकों का योग लौटाने के लिए एक फ़ंक्शन लिखें।,"def sum_div(number):
    divisors = [1]
    for i in range(2, number):
        if (number % i)==0:
            divisors.append(i)
    return sum(divisors)",[],"['assert sum_div(8)==7', 'assert sum_div(12)==16', 'assert sum_div(7)==1']","आप निम्नलिखित फ़ंक्शन का उपयोग कर सकते हैं:

```python
def sum_of_divisors(n):
    sum = 0
    i = 1
    while i <= n:
        if n % i == 0:
            sum = sum + i
        i = i + 1
    return sum
```

इस फ़ंक्शन का उपयोग करने के लिए, आपको बस विभाज्य संख्या को फ़ंक्शन के रूप में पास करना होगा। उदाहरण के लिए:

```python
print(sum_of_divisors(12))  # यह 28 लौटाएगा, क्योंकि 1 + 2 + 3 + 4 + 6 + 12 = 28
```"
Ellen's Copy of Benchmark Questions Verification V2.ipynb,296,किसी सरणी में व्युत्क्रमों की गणना करने के लिए एक पायथन फ़ंक्शन लिखें।,"def get_Inv_Count(arr): 
    inv_count = 0
    for i in range(len(arr)): 
        for j in range(i + 1, len(arr)): 
            if (arr[i] > arr[j]): 
                inv_count += 1
    return inv_count ",[],"['assert get_Inv_Count([1,20,6,4,5]) == 5', 'assert get_Inv_Count([1,2,1]) == 1', 'assert get_Inv_Count([1,2,5,6,1]) == 3']","व्युत्क्रम (इन्वर्शन) की गणना करने के लिए, हमें हर एक तत्व के लिए उसके बाद के सभी तत्वों की जांच करनी होती है और यदि कोई तत्व छोटा है, तो हमें एक व्युत्क्रम की गणना करनी होती है। नीचे दिए गए कोड स्निपेट में यह दिखाया गया है:

```python
def count_inversions(lst):
    inv_count = 0
    for i in range(len(lst)):
        for j in range(i+1, len(lst)):
            if lst[i] > lst[j]:
                inv_count += 1
    return inv_count
```

इस फ़ंक्शन का उपयोग करके, आप किसी भी सूची में व्युत्क्रमों की संख्या की गणना कर सकते हैं। उदाहरण के लिए:

```python
print(count_inversions([1, 20, 6, 4, 5]))  # Output: 5
```

यहां, 5 व्युत्क्रम हैं: (20, 6), (20, 4), (20, 5), (6, 4), (6, 5)."
Ellen's Copy of Benchmark Questions Verification V2.ipynb,297,किसी दी गई नेस्टेड सूची संरचना को समतल करने के लिए एक फ़ंक्शन लिखें।,"def flatten_list(list1):
    result_list = []
    if not list1: return result_list
    stack = [list(list1)]
    while stack:
        c_num = stack.pop()
        next = c_num.pop()
        if c_num: stack.append(c_num)
        if isinstance(next, list):
            if next: stack.append(list(next))
        else: result_list.append(next)
    result_list.reverse()
    return result_list ",[],"['assert flatten_list([0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]])==[0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120]', 'assert flatten_list([[10, 20], [40], [30, 56, 25], [10, 20], [33], [40]])==[10, 20, 40, 30, 56, 25, 10, 20, 33, 40]', 'assert flatten_list([[1,2,3], [4,5,6], [10,11,12], [7,8,9]])==[1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9]']","यहां एक फ़ंक्शन है जो नेस्टेड सूची संरचना को समतल कर सकता है:

```python
def flatten_list(nested_list):
    result = []
    for i in nested_list:
        if isinstance(i, list):
            result.extend(flatten_list(i))
        else:
            result.append(i)
    return result
```

इस फ़ंक्शन का उपयोग करने के लिए, आप बस इसे निम्नलिखित तरीके से कॉल करें:

```python
nested_list = [1, 2, [3, 4, [5, 6]], 7, [8, 9]]
print(flatten_list(nested_list))
```

यह निम्नलिखित आउटपुट देगा:

```python
[1, 2, 3, 4, 5, 6, 7, 8, 9]
```

यह फ़ंक्शन एक नेस्टेड सूची को लेता है और इसे एक समतल सूची में बदल देता है, जिसमें सभी उप-सूचियों के तत्व समतल सूची में जोड़ दिए जाते हैं।"
Ellen's Copy of Benchmark Questions Verification V2.ipynb,299,टुपल्स की सूची से अधिकतम समुच्चय की गणना करने के लिए एक फ़ंक्शन लिखें।,"from collections import defaultdict
def max_aggregate(stdata):
    temp = defaultdict(int)
    for name, marks in stdata:
        temp[name] += marks
    return max(temp.items(), key=lambda x: x[1])",[],"[""assert max_aggregate([('Juan Whelan',90),('Sabah Colley',88),('Peter Nichols',7),('Juan Whelan',122),('Sabah Colley',84)])==('Juan Whelan', 212)"", ""assert max_aggregate([('Juan Whelan',50),('Sabah Colley',48),('Peter Nichols',37),('Juan Whelan',22),('Sabah Colley',14)])==('Juan Whelan', 72)"", ""assert max_aggregate([('Juan Whelan',10),('Sabah Colley',20),('Peter Nichols',30),('Juan Whelan',40),('Sabah Colley',50)])==('Sabah Colley', 70)""]","यहां एक फ़ंक्शन है जो टुपल्स की सूची से अधिकतम समुच्चय की गणना करता है:

```python
def max_sum(lst):
    return max(sum(x) for x in lst)
```

इस फ़ंक्शन का उपयोग करने के लिए, आप इसे निम्नलिखित तरीके से कॉल कर सकते हैं:

```python
print(max_sum([(1, 2), (3, 4), (5, 6)]))  # यह 11 प्रिंट करेगा
```

यह फ़ंक्शन `max` फ़ंक्शन का उपयोग करता है जो एक इटरेबल (यहां पर एक जनरेटर एक्सप्रेशन) पर इटरेट करता है और प्रत्येक टुपल का योग निकालता है। फिर यह उन सभी योगों में से सबसे बड़े को चुनता है।"
Ellen's Copy of Benchmark Questions Verification V2.ipynb,300,"लंबाई 2n के सभी बाइनरी अनुक्रमों की गिनती ज्ञात करने के लिए एक फ़ंक्शन लिखें, ताकि पहले n बिट्स का योग अंतिम n बिट्स के योग के समान हो।","def count_binary_seq(n): 
	nCr = 1
	res = 1
	for r in range(1, n + 1): 
		nCr = (nCr * (n + 1 - r)) / r 
		res += nCr * nCr 
	return res ",['import math'],"['assert math.isclose(count_binary_seq(1), 2.0, rel_tol=0.001)', 'assert math.isclose(count_binary_seq(2), 6.0, rel_tol=0.001)', 'assert math.isclose(count_binary_seq(3), 20.0, rel_tol=0.001)']","यहां एक संभावित समाधान है:

```python
from math import comb

def count_sequences(n):
    return sum([comb(n, i)**2 for i in range(n+1)])

print(count_sequences(2))  # उदाहरण के लिए
```

इस फ़ंक्शन में, हम comb फ़ंक्शन का उपयोग करते हैं जो निम्नलिखित सूत्र का प्रयोग करता है: C(n, k) = n! / (k!(n-k)!). यह सूत्र एक समूह में n वस्तुओं में से k वस्तुओं की संख्या की गणना करता है.

हम comb(n, i) का वर्ग लेते हैं क्योंकि हमें पहले n बिट्स और अंतिम n बिट्स के बीच समानता सुनिश्चित करनी होती है, और दोनों के लिए हमें i बिट्स की आवश्यकता होती है.

फिर, हम इन सभी संभावित अनुक्रमों की संख्या का योग लेते हैं, i = 0 से n तक."
Ellen's Copy of Benchmark Questions Verification V2.ipynb,301,शब्दकोश की गहराई जानने के लिए एक फ़ंक्शन लिखें।,"def dict_depth(d):
    if isinstance(d, dict):
        return 1 + (max(map(dict_depth, d.values())) if d else 0)
    return 0",[],"[""assert dict_depth({'a':1, 'b': {'c': {'d': {}}}})==4"", ""assert dict_depth({'a':1, 'b': {'c':'python'}})==2"", ""assert dict_depth({1: 'Sun', 2: {3: {4:'Mon'}}})==3""]","आप निम्नलिखित फ़ंक्शन का उपयोग कर सकते हैं जो एक शब्दकोश की गहराई को जांचता है:

```python
def dict_depth(dic):
    if isinstance(dic, dict):
        return 1 + (max(map(dict_depth, dic.values())) if dic else 0)
    return 0
```

यह फ़ंक्शन एक शब्दकोश की गहराई को जांचता है जो उसके विभिन्न स्तरों की संख्या होती है। यदि शब्दकोश में कोई शब्दकोश नहीं है, तो गहराई 1 होती है। यदि शब्दकोश में एक या अधिक शब्दकोश हैं, तो गहराई उस शब्दकोश की गहराई + 1 होती है जिसमें सबसे अधिक स्तर होते हैं।"
Ellen's Copy of Benchmark Questions Verification V2.ipynb,304,घुमावों की संख्या के बाद किसी दिए गए सूचकांक पर तत्व खोजने के लिए एक पायथन फ़ंक्शन लिखें।,"def find_Element(arr,ranges,rotations,index) :  
    for i in range(rotations - 1,-1,-1 ) : 
        left = ranges[i][0] 
        right = ranges[i][1] 
        if (left <= index and right >= index) : 
            if (index == left) : 
                index = right 
            else : 
                index = index - 1 
    return arr[index] ",[],"['assert find_Element([1,2,3,4,5],[[0,2],[0,3]],2,1) == 3', 'assert find_Element([1,2,3,4],[[0,1],[0,2]],1,2) == 3', 'assert find_Element([1,2,3,4,5,6],[[0,1],[0,2]],1,1) == 1']","यहां एक साधारण फ़ंक्शन है जो एक सूची और एक सूचकांक को इनपुट के रूप में लेता है और उस सूचकांक पर सूची का तत्व लौटाता है। यदि सूचकांक सूची की सीमा से बाहर है, तो यह एक त्रुटि संदेश देता है।

```python
def find_element(list, index):
    try:
        return list[index]
    except IndexError:
        return ""सूचकांक सूची की सीमा से बाहर है""

# उदाहरण के लिए
list = [1, 2, 3, 4, 5]
index = 3
print(find_element(list, index))
```

इस फ़ंक्शन का उपयोग करके, आप एक सूची में घुमावों की संख्या के बाद किसी दिए गए सूचकांक पर तत्व खोज सकते हैं। यदि आपको घुमावों की संख्या के बाद किसी दिए गए सूचकांक पर तत्व खोजने की आवश्यकता है, तो आप सूची को उस संख्या के अनुसार घुमा सकते हैं और फिर उस सूचकांक पर तत्व खोज सकते हैं।"
Ellen's Copy of Benchmark Questions Verification V2.ipynb,305,अक्षर &#39;पी&#39; से शुरू होने वाले शब्दों की सूची से दो शब्दों को वापस लाने के लिए एक फ़ंक्शन लिखें।,"import re
def start_withp(words):
 for w in words:
        m = re.match(""(P\w+)\W(P\w+)"", w)
        if m:
            return m.groups()",[],"['assert start_withp([""Python PHP"", ""Java JavaScript"", ""c c++""])==(\'Python\', \'PHP\')', 'assert start_withp([""Python Programming"",""Java Programming""])==(\'Python\',\'Programming\')', 'assert start_withp([""Pqrst Pqr"",""qrstuv""])==(\'Pqrst\',\'Pqr\')']","यहां एक फ़ंक्शन है जो एक शब्दों की सूची लेता है और 'पी' से शुरू होने वाले पहले दो शब्दों को वापस लौटाता है:

```python
def find_words_starting_with_p(words):
    p_words = [word for word in words if word.startswith('पी')]
    return p_words[:2]

words = ['पीला', 'पीठ', 'बाल', 'पीपल', 'चावल', 'पीना']
print(find_words_starting_with_p(words))
```

इस फ़ंक्शन को चलाने से ['पीला', 'पीठ'] प्रिंट होगा, जो 'पी' से शुरू होने वाले पहले दो शब्द हैं।"
Ellen's Copy of Benchmark Questions Verification V2.ipynb,306,"उपसर्ग से iवें सूचकांक तक बढ़ते अनुवर्ती का अधिकतम योग ज्ञात करने के लिए एक फ़ंक्शन लिखें और इसमें दिए गए kth तत्व को भी शामिल करें जो कि i के बाद है, अर्थात, k &gt; i।","def max_sum_increasing_subseq(a, n, index, k):
	dp = [[0 for i in range(n)] 
			for i in range(n)]
	for i in range(n):
		if a[i] > a[0]:
			dp[0][i] = a[i] + a[0]
		else:
			dp[0][i] = a[i]
	for i in range(1, n):
		for j in range(n):
			if a[j] > a[i] and j > i:
				if dp[i - 1][i] + a[j] > dp[i - 1][j]:
					dp[i][j] = dp[i - 1][i] + a[j]
				else:
					dp[i][j] = dp[i - 1][j]
			else:
				dp[i][j] = dp[i - 1][j]
	return dp[index][k]",[],"['assert max_sum_increasing_subseq([1, 101, 2, 3, 100, 4, 5 ], 7, 4, 6) == 11', 'assert max_sum_increasing_subseq([1, 101, 2, 3, 100, 4, 5 ], 7, 2, 5) == 7', 'assert max_sum_increasing_subseq([11, 15, 19, 21, 26, 28, 31], 7, 2, 4) == 71']","आप निम्नलिखित फ़ंक्शन का उपयोग कर सकते हैं:

```python
def max_sum_subsequence(arr, prefix, i, k):
    if i >= len(arr) or i > k:
        return prefix
    return max(max_sum_subsequence(arr, prefix + arr[i], i + 1, k),
               max_sum_subsequence(arr, prefix, i + 1, k))

arr = [1, 2, 3, 4, 5]
prefix = 0
i = 0
k = 3
print(max_sum_subsequence(arr, prefix, i, k))
```

इस फ़ंक्शन में, `arr` एक सूची है जिसमें आपके अंक हैं, `prefix` उपसर्ग का योग है, `i` वर्तमान सूचकांक है, और `k` आपका अंतिम सूचकांक है। यह फ़ंक्शन उपसर्ग से `i`वें सूचकांक तक बढ़ते अनुवर्ती का अधिकतम योग ज्ञात करता है, `k`वें तत्व को भी शामिल करता है।

यह फ़ंक्शन दो तरीके से अधिकतम योग की गणना करता है: एक तरीका जिसमें वर्तमान तत्व को योग में शामिल किया जाता है, और दूसरा तरीका जिसमें वर्तमान तत्व को छोड़ दिया जाता है। इसके बाद, यह दोनों तरीकों में से अधिकतम योग वाले को चुनता है।"
Ellen's Copy of Benchmark Questions Verification V2.ipynb,307,टुपल का कोलन प्राप्त करने के लिए एक फ़ंक्शन लिखें।,"from copy import deepcopy
def colon_tuplex(tuplex,m,n):
  tuplex_colon = deepcopy(tuplex)
  tuplex_colon[m].append(n)
  return tuplex_colon",[],"['assert colon_tuplex((""HELLO"", 5, [], True) ,2,50)==(""HELLO"", 5, [50], True)', 'assert colon_tuplex((""HELLO"", 5, [], True) ,2,100)==((""HELLO"", 5, [100],True))', 'assert colon_tuplex((""HELLO"", 5, [], True) ,2,500)==(""HELLO"", 5, [500], True)']","यहां एक फ़ंक्शन है जो टुपल का कोलन प्राप्त करता है:

```python
def get_tuple_clone(original_tuple):
    return original_tuple[:]
```

इस फ़ंक्शन का उपयोग करने के लिए, आप इसे निम्नलिखित तरीके से कॉल कर सकते हैं:

```python
original_tuple = (1, 2, 3, 4, 5)
cloned_tuple = get_tuple_clone(original_tuple)
print(cloned_tuple)  # यह (1, 2, 3, 4, 5) प्रिंट करेगा
```

यह फ़ंक्शन टुपल की एक क्लोन बनाता है, जिसका अर्थ है कि यह नया टुपल मूल टुपल की समान कॉपी होता है, लेकिन यह दोनों अलग-अलग ऑब्जेक्ट होते हैं। इसलिए, यदि आप मूल टुपल में कुछ बदलते हैं, तो यह क्लोन टुपल पर कोई प्रभाव नहीं डालेगा, और उलटा।"
Ellen's Copy of Benchmark Questions Verification V2.ipynb,308,"प्रत्येक सूची से एक कारक का चयन करते हुए, दो दी गई सूचियों से सबसे बड़े उत्पादों की निर्दिष्ट संख्या ज्ञात करने के लिए एक फ़ंक्शन लिखें।","def large_product(nums1, nums2, N):
    result = sorted([x*y for x in nums1 for y in nums2], reverse=True)[:N]
    return result",[],"['assert large_product([1, 2, 3, 4, 5, 6],[3, 6, 8, 9, 10, 6],3)==[60, 54, 50]', 'assert large_product([1, 2, 3, 4, 5, 6],[3, 6, 8, 9, 10, 6],4)==[60, 54, 50, 48]', 'assert large_product([1, 2, 3, 4, 5, 6],[3, 6, 8, 9, 10, 6],5)==[60, 54, 50, 48, 45]']","आप निम्नलिखित फ़ंक्शन का उपयोग कर सकते हैं:

```python
def max_product(list1, list2, n_largest):
    import heapq
    max_product_list = []
    for i in list1:
        for j in list2:
            if len(max_product_list) < n_largest:
                heapq.heappush(max_product_list, i*j)
            else:
                if i*j > max_product_list[0]:
                    heapq.heapreplace(max_product_list, i*j)
    return max_product_list
```

इस फ़ंक्शन का उपयोग करने के लिए, आप दो सूचियों और एक संख्या पास करें, जैसे कि:

```python
list1 = [1, 2, 3, 4, 5]
list2 = [6, 7, 8, 9, 10]
n_largest = 3
print(max_product(list1, list2, n_largest))  # Output: [40, 45, 50]
```

यह फ़ंक्शन दोनों सूचियों के बीच सभी संभावित उत्पादों की सूची बनाता है, और फिर उस सूची से n_largest उत्पादों की सूची बनाता है।"
Ellen's Copy of Benchmark Questions Verification V2.ipynb,309,अधिकतम दो संख्याएँ ज्ञात करने के लिए एक पायथन फ़ंक्शन लिखें।,"def maximum(a,b):   
    if a >= b: 
        return a 
    else: 
        return b ",[],"['assert maximum(5,10) == 10', 'assert maximum(-1,-2) == -1', 'assert maximum(9,7) == 9']","आप निम्नलिखित तरीके से एक पायथन फ़ंक्शन लिख सकते हैं जो दो संख्याओं में से अधिकतम को ज्ञात करता है:

```python
def max_of_two_numbers(num1, num2):
    if num1 > num2:
        return num1
    else:
        return num2
```

इस फ़ंक्शन का उपयोग करने के लिए, आप दो संख्याएँ आपूर्ति कर सकते हैं और यह आपको उनमें से अधिकतम संख्या देगा। उदाहरण के लिए:

```python
print(max_of_two_numbers(10, 20))  # Outputs: 20
```"
Ellen's Copy of Benchmark Questions Verification V2.ipynb,310,किसी दिए गए स्ट्रिंग को वर्णों के टुपल में बदलने के लिए एक फ़ंक्शन लिखें।,"def string_to_tuple(str1):
    result = tuple(x for x in str1 if not x.isspace()) 
    return result",[],"['assert string_to_tuple(""python 3.0"")==(\'p\', \'y\', \'t\', \'h\', \'o\', \'n\', \'3\', \'.\', \'0\')', 'assert string_to_tuple(""item1"")==(\'i\', \'t\', \'e\', \'m\', \'1\')', 'assert string_to_tuple(""15.10"")==(\'1\', \'5\', \'.\', \'1\', \'0\')']","आप निम्नलिखित फ़ंक्शन का उपयोग कर सकते हैं:

```python
def convert_string_to_tuple(s):
    return tuple(s)
```

इस फ़ंक्शन का उपयोग करने के लिए, आप बस इसे निम्नलिखित तरीके से कॉल करें:

```python
print(convert_string_to_tuple(""Hello""))
```

यह ""Hello"" को एक टुपल में बदल देगा, जैसे कि ('H', 'e', 'l', 'l', 'o')."
Ellen's Copy of Benchmark Questions Verification V2.ipynb,311,सबसे बाईं ओर के अनसेट बिट को सेट करने के लिए एक पायथन फ़ंक्शन लिखें।,"def set_left_most_unset_bit(n): 
    if not (n & (n + 1)): 
        return n 
    pos, temp, count = 0, n, 0 
    while temp: 
        if not (temp & 1): 
            pos = count      
        count += 1; temp>>=1
    return (n | (1 << (pos))) ",[],"['assert set_left_most_unset_bit(10) == 14', 'assert set_left_most_unset_bit(12) == 14', 'assert set_left_most_unset_bit(15) == 15']","यहां एक पायथन फ़ंक्शन है जो सबसे बाईं ओर के अनसेट बिट को सेट करता है:

```python
def set_leftmost_unset_bit(n):
    # बाईं ओर से पहला अनसेट बिट ढूंढने के लिए बिट्स को बाईं ओर से देखना शुरू करें
    i = 0
    while n:
        # यदि बिट सेट नहीं है, तो उसे सेट करें और नंबर लौटाएं
        if (n & 1) == 0:
            return n | (1 << i)
        # अगले बिट पर जाएं
        n >>= 1
        i += 1
    # यदि सभी बिट सेट हैं, तो सबसे बाईं ओर एक नया बिट जोड़ें
    return n | (1 << i)
```

यह फ़ंक्शन एक बाइनरी नंबर को एक इंटेजर के रूप में लेता है और सबसे बाईं ओर के अनसेट बिट को सेट करके नया नंबर लौटाता है। यदि सभी बिट सेट हैं, तो यह सबसे बाईं ओर एक नया बिट जोड़ता है।"
Ellen's Copy of Benchmark Questions Verification V2.ipynb,312,शंकु का आयतन ज्ञात करने के लिए एक फ़ंक्शन लिखें।,"import math
def volume_cone(r,h):
  volume = (1.0/3) * math.pi * r * r * h
  return volume",['import math'],"['assert math.isclose(volume_cone(5,12), 314.15926535897927, rel_tol=0.001)', 'assert math.isclose(volume_cone(10,15), 1570.7963267948965, rel_tol=0.001)', 'assert math.isclose(volume_cone(19,17), 6426.651371693521, rel_tol=0.001)']","शंकु का आयतन ज्ञात करने के लिए, हमें शंकु की ऊचाई (h) और आधार की त्रिज्या (r) की जरूरत होती है। शंकु का आयतन निम्न सूत्र से ज्ञात किया जा सकता है:

V = 1/3 * π * r^2 * h

इसे Python में इस तरह से लिखा जा सकता है:

```python
import math

def cone_volume(r, h):
    return (1/3) * math.pi * r * r * h
```

इस फ़ंक्शन का उपयोग करके, आप किसी भी शंकु का आयतन ज्ञात कर सकते हैं। उदाहरण के लिए, यदि आपके पास एक शंकु है जिसकी ऊचाई 10 यूनिट और आधार की त्रिज्या 5 यूनिट है, तो आप इसे निम्नलिखित तरीके से उपयोग कर सकते हैं:

```python
print(cone_volume(5, 10))
```

यह आपको शंकु का आयतन देगा।"
Benchmark Questions Verification V2.ipynb,388,2 की उच्चतम शक्ति ज्ञात करने के लिए एक पायथन फ़ंक्शन लिखें जो n से कम या उसके बराबर है।,"def highest_Power_of_2(n): 
    res = 0 
    for i in range(n, 0, -1): 
        if ((i & (i - 1)) == 0): 
            res = i 
            break 
    return res ",[],"['assert highest_Power_of_2(10) == 8', 'assert highest_Power_of_2(19) == 16', 'assert highest_Power_of_2(32) == 32']","आप निम्नलिखित पायथन फ़ंक्शन का उपयोग कर सकते हैं:

```python
def highest_power_of_two(n):
    i = 1
    while i <= n:
        i = i * 2
    return i // 2
```

यह फ़ंक्शन 2 की उच्चतम शक्ति को खोजता है जो n से कम या उसके बराबर है। यह फ़ंक्शन 2 को बार-बार दोगुना करता है जब तक कि यह n से अधिक नहीं हो जाता, और फिर वह अंतिम मान को 2 से विभाजित करता है जो n से अधिक था।"
Benchmark Questions Verification V2.ipynb,389,n&#39;वें लुकास नंबर को खोजने के लिए एक फ़ंक्शन लिखें।,"def find_lucas(n): 
	if (n == 0): 
		return 2
	if (n == 1): 
		return 1
	return find_lucas(n - 1) + find_lucas(n - 2) ",[],"['assert find_lucas(9) == 76', 'assert find_lucas(4) == 7', 'assert find_lucas(3) == 4']","लुकास संख्याएं एक संख्या श्रृंखला हैं जिसमें प्रत्येक संख्या इसके दो पूर्ववर्ती संख्याओं का योग होती है, लेकिन श्रृंखला 2 और 1 से शुरू होती है, न कि 0 और 1 से।

यहां एक फ़ंक्शन है जो n वां लुकास संख्या खोजता है:

```python
def lucas(n):
    if n == 0:
        return 2
    elif n == 1:
        return 1
    else:
        a, b = 2, 1
        for _ in range(n-1):
            a, b = b, a + b
        return b
```

इस फ़ंक्शन का उपयोग करके, आप निम्नलिखित तरीके से n वां लुकास संख्या प्राप्त कर सकते हैं:

```python
print(lucas(10))  # Output: 123
```"
Benchmark Questions Verification V2.ipynb,390,किसी सूची के सभी तत्वों पर दिए गए प्रारूप स्ट्रिंग को लागू करने के लिए एक फ़ंक्शन लिखें।,"def add_string(list_, string):
 add_string=[string.format(i) for i in  list_]
 return add_string",[],"[""assert add_string([1,2,3,4],'temp{0}')==['temp1', 'temp2', 'temp3', 'temp4']"", ""assert add_string(['a','b','c','d'], 'python{0}')==[ 'pythona', 'pythonb', 'pythonc', 'pythond']"", ""assert add_string([5,6,7,8],'string{0}')==['string5', 'string6', 'string7', 'string8']""]","आप इसे Python के `map` फ़ंक्शन का उपयोग करके कर सकते हैं। यहां एक उदाहरण है:

```python
def apply_format_to_list_elements(format_string, lst):
    return list(map(lambda x: format_string.format(x), lst))
```

इस फ़ंक्शन का उपयोग करने के लिए, आप एक प्रारूप स्ट्रिंग और एक सूची पास करेंगे। यह फ़ंक्शन सूची के प्रत्येक तत्व पर प्रारूप स्ट्रिंग लागू करेगा और नई सूची वापस करेगा।

उदाहरण के लिए:

```python
print(apply_format_to_list_elements(""Hello, {}!"", [""Alice"", ""Bob"", ""Charlie""]))
```

यह निम्नलिखित आउटपुट देगा:

```
['Hello, Alice!', 'Hello, Bob!', 'Hello, Charlie!']
```"
Benchmark Questions Verification V2.ipynb,391,एक से अधिक सूचियों को नेस्टेड शब्दकोश में बदलने के लिए एक फ़ंक्शन लिखें।,"def convert_list_dictionary(l1, l2, l3):
     result = [{x: {y: z}} for (x, y, z) in zip(l1, l2, l3)]
     return result",[],"['assert convert_list_dictionary([""S001"", ""S002"", ""S003"", ""S004""],[""Adina Park"", ""Leyton Marsh"", ""Duncan Boyle"", ""Saim Richards""] ,[85, 98, 89, 92])==[{\'S001\': {\'Adina Park\': 85}}, {\'S002\': {\'Leyton Marsh\': 98}}, {\'S003\': {\'Duncan Boyle\': 89}}, {\'S004\': {\'Saim Richards\': 92}}]', 'assert convert_list_dictionary([""abc"",""def"",""ghi"",""jkl""],[""python"",""program"",""language"",""programs""],[100,200,300,400])==[{\'abc\':{\'python\':100}},{\'def\':{\'program\':200}},{\'ghi\':{\'language\':300}},{\'jkl\':{\'programs\':400}}]', 'assert convert_list_dictionary([""A1"",""A2"",""A3"",""A4""],[""java"",""C"",""C++"",""DBMS""],[10,20,30,40])==[{\'A1\':{\'java\':10}},{\'A2\':{\'C\':20}},{\'A3\':{\'C++\':30}},{\'A4\':{\'DBMS\':40}}]']","यहां एक फ़ंक्शन है जो एक से अधिक सूचियों को नेस्टेड शब्दकोश में बदलता है:

```python
def lists_to_nested_dict(*lists):
    if not lists:
        return {}
    return {lists[0]: lists_to_nested_dict(*lists[1:])}
```

इस फ़ंक्शन का उपयोग करने के लिए, आप इसे निम्नलिखित तरीके से कॉल कर सकते हैं:

```python
print(lists_to_nested_dict('a', 'b', 'c', 'd'))
```

यह निम्नलिखित आउटपुट देगा:

```python
{'a': {'b': {'c': 'd'}}}
```

यह फ़ंक्शन एक से अधिक सूचियों को नेस्टेड शब्दकोश में बदलता है, जहां प्रत्येक सूची का पहला आइटम अगली सूची के लिए एक कुंजी होता है, और अगली सूची का पहला आइटम उस कुंजी का मान होता है। यदि कोई सूची नहीं होती है, तो फ़ंक्शन एक खाली शब्दकोश लौटाता है।"
Benchmark Questions Verification V2.ipynb,392,"दिए गए समीकरण f(n) = max( (f(n/2) + f(n/3) + f(n/4) + f(n/5)) का उपयोग करके अधिकतम संभव योग ज्ञात करने के लिए एक फ़ंक्शन लिखें , एन)।","def get_max_sum (n):
	res = list()
	res.append(0)
	res.append(1)
	i = 2
	while i<n + 1:
		res.append(max(i, (res[int(i / 2)] 
						+ res[int(i / 3)] +
							res[int(i / 4)]
						+ res[int(i / 5)])))
		i = i + 1
	return res[n]",[],"['assert get_max_sum(60) == 106', 'assert get_max_sum(10) == 12', 'assert get_max_sum(2) == 2']","यहां एक फ़ंक्शन है जो दिए गए समीकरण का उपयोग करके अधिकतम संभव योग ज्ञात करता है। यह फ़ंक्शन डायनामिक प्रोग्रामिंग का उपयोग करता है।

```python
def max_sum(n):
    dp = [0]*(n+1)
    dp[0] = 0
    dp[1] = 1

    for i in range(2, n+1):
        dp[i] = max(i, dp[i//2] + dp[i//3] + dp[i//4] + dp[i//5])

    return dp[n]
```

इस फ़ंक्शन का उपयोग करने के लिए, आपको बस इसे बुलाना होगा और आपको चाहिए वह संख्या जिसके लिए आप अधिकतम संभव योग ज्ञात करना चाहते हैं। उदाहरण के लिए, `max_sum(10)` आपको `10` देगा, क्योंकि `10` से बड़ी कोई योगदान नहीं हो सकता है।"
charlessutton@: Benchmark Questions Verification V2.ipynb,393,अधिकतम लंबाई वाली सूची ढूंढने के लिए एक फ़ंक्शन लिखें।,"def max_length_list(input_list):
    max_length = max(len(x) for x in input_list )   
    max_list = max(input_list, key = lambda i: len(i))    
    return(max_length, max_list)",[],"['assert max_length_list([[0], [1, 3], [5, 7], [9, 11], [13, 15, 17]])==(3, [13, 15, 17])', 'assert max_length_list([[1,2,3,4,5],[1,2,3,4],[1,2,3],[1,2],[1]])==(5,[1,2,3,4,5])', 'assert max_length_list([[3,4,5],[6,7,8,9],[10,11,12]])==(4,[6,7,8,9])']","यहां एक फ़ंक्शन है जो एक सूची की सूची लेता है और सबसे लंबी सूची वापस करता है:

```python
def longest_list(list_of_lists):
    return max(list_of_lists, key=len)
```

इस फ़ंक्शन का उपयोग करने के लिए, आप इसे निम्नलिखित तरीके से कॉल कर सकते हैं:

```python
print(longest_list([[1, 2, 3], [1, 2, 3, 4, 5], [1, 2]]))  # Output: [1, 2, 3, 4, 5]
```

यह फ़ंक्शन `max` फ़ंक्शन का उपयोग करता है जिसका `key` पैरामीटर `len` फ़ंक्शन सेट करता है, जिससे यह लंबाई के आधार पर सबसे बड़ी सूची ढूंढता है।"
Benchmark Questions Verification V2.ipynb,394,यह जांचने के लिए एक फ़ंक्शन लिखें कि दिए गए टुपल में कोई डुप्लिकेट नहीं है या नहीं।,"def check_distinct(test_tup):
  res = True
  temp = set()
  for ele in test_tup:
    if ele in temp:
      res = False
      break
    temp.add(ele)
  return res ",[],"['assert check_distinct((1, 4, 5, 6, 1, 4)) == False', 'assert check_distinct((1, 4, 5, 6)) == True', 'assert check_distinct((2, 3, 4, 5, 6)) == True']","यहां एक फ़ंक्शन है जो यह जांचता है कि दिए गए टुपल में कोई डुप्लिकेट नहीं है या नहीं।

```python
def check_duplicates_in_tuple(tup):
    if len(tup) == len(set(tup)):
        return False
    else:
        return True
```

इस फ़ंक्शन का उपयोग करने के लिए, आप इसे निम्नलिखित तरीके से कॉल कर सकते हैं:

```python
tup = (1, 2, 3, 4, 5, 6, 7, 8, 9, 1)
print(check_duplicates_in_tuple(tup))
```

यदि टुपल में डुप्लिकेट होते हैं, तो यह `True` लौटाएगा, अन्यथा `False`."
Benchmark Questions Verification V2.ipynb,395,किसी दिए गए स्ट्रिंग में पहले गैर-दोहराए गए वर्ण को खोजने के लिए एक पायथन फ़ंक्शन लिखें।,"def first_non_repeating_character(str1):
  char_order = []
  ctr = {}
  for c in str1:
    if c in ctr:
      ctr[c] += 1
    else:
      ctr[c] = 1 
      char_order.append(c)
  for c in char_order:
    if ctr[c] == 1:
      return c
  return None",[],"['assert first_non_repeating_character(""abcabc"") == None', 'assert first_non_repeating_character(""abc"") == ""a""', 'assert first_non_repeating_character(""ababc"") == ""c""']","आप निम्नलिखित पायथन फ़ंक्शन का उपयोग कर सकते हैं:

```python
def find_first_non_repeating_char(string):
    char_count = {}
    for char in string:
        if char in char_count:
            char_count[char] += 1
        else:
            char_count[char] = 1
    for char in string:
        if char_count[char] == 1:
            return char
    return None
```

इस फ़ंक्शन का उपयोग करने के लिए, आप बस इसे निम्नलिखित तरीके से कॉल करें:

```python
print(find_first_non_repeating_char('hello world'))
```

यह 'h' प्रिंट करेगा, क्योंकि यह 'hello world' में पहला गैर-दोहराया गया वर्ण है।"
charlessutton@: Benchmark Questions Verification V2.ipynb,396,यह जांचने के लिए एक फ़ंक्शन लिखें कि दी गई स्ट्रिंग एक ही वर्ण से शुरू और समाप्त होती है या नहीं।,"import re  
regex = r'^[a-z]$|^([a-z]).*\1$'
def check_char(string): 
	if(re.search(regex, string)): 
		return ""Valid"" 
	else: 
		return ""Invalid"" ",[],"['assert check_char(""abba"") == ""Valid""', 'assert check_char(""a"") == ""Valid""', 'assert check_char(""abcd"") == ""Invalid""']","आप निम्नलिखित फ़ंक्शन का उपयोग कर सकते हैं:

```python
def same_start_end(s):
    return s[0] == s[-1]
```

यह फ़ंक्शन एक स्ट्रिंग `s` को इनपुट के रूप में लेता है और यदि स्ट्रिंग का पहला और आखिरी वर्ण समान हैं, तो यह `True` लौटाता है, अन्यथा `False` लौटाता है।"
Benchmark Questions Verification V2.ipynb,397,तीन संख्याओं का माध्य ज्ञात करने के लिए एक फ़ंक्शन लिखें।,"def median_numbers(a,b,c):
 if a > b:
    if a < c:
        median = a
    elif b > c:
        median = b
    else:
        median = c
 else:
    if a > c:
        median = a
    elif b < c:
        median = b
    else:
        median = c
 return median",[],"['assert median_numbers(25,55,65)==55.0', 'assert median_numbers(20,10,30)==20.0', 'assert median_numbers(15,45,75)==45.0']","आप तीन संख्याओं का माध्य ज्ञात करने के लिए निम्नलिखित फ़ंक्शन का उपयोग कर सकते हैं:

```python
def find_median_of_three_numbers(num1, num2, num3):
    numbers = [num1, num2, num3]
    numbers.sort()
    return numbers[1]
```

इस फ़ंक्शन का उपयोग करके, आप तीन संख्याओं का माध्य ज्ञात कर सकते हैं। उदाहरण के लिए:

```python
print(find_median_of_three_numbers(1, 2, 3))  # Output: 2
print(find_median_of_three_numbers(9, 3, 6))  # Output: 6
print(find_median_of_three_numbers(5, 5, 5))  # Output: 5
```

यह फ़ंक्शन पहले तीन संख्याओं को सॉर्ट करता है, और फिर मध्य संख्या को वापस लौटाता है, जो माध्य होती है।"
Benchmark Questions Verification V2.ipynb,398,किसी दी गई सूची की प्रत्येक संख्या के अंकों के योग की गणना करने के लिए एक फ़ंक्शन लिखें।,"def sum_of_digits(nums):
    return sum(int(el) for n in nums for el in str(n) if el.isdigit())",[],"['assert sum_of_digits([10,2,56])==14', ""assert sum_of_digits([[10,20,4,5,'b',70,'a']])==19"", 'assert sum_of_digits([10,20,-4,5,-70])==19']","आप निम्नलिखित फ़ंक्शन का उपयोग कर सकते हैं:

```python
def sum_of_digits_in_list(lst):
    return [sum(int(digit) for digit in str(num)) for num in lst]
```

इस फ़ंक्शन का उपयोग करने के लिए, आपको बस एक सूची पास करनी होगी। उदाहरण के लिए:

```python
print(sum_of_digits_in_list([123, 456, 789]))
```

यह आउटपुट देगा:

```python
[6, 15, 24]
```

यहां, 123 के अंकों का योग 6 है (1 + 2 + 3), 456 के अंकों का योग 15 है (4 + 5 + 6), और 789 के अंकों का योग 24 है (7 + 8 + 9)."
Benchmark Questions Verification V2.ipynb,399,दिए गए टुपल्स में गणितीय बिटवाइज़ xor ऑपरेशन करने के लिए एक फ़ंक्शन लिखें।,"def bitwise_xor(test_tup1, test_tup2):
  res = tuple(ele1 ^ ele2 for ele1, ele2 in zip(test_tup1, test_tup2))
  return (res) ",[],"['assert bitwise_xor((10, 4, 6, 9), (5, 2, 3, 3)) == (15, 6, 5, 10)', 'assert bitwise_xor((11, 5, 7, 10), (6, 3, 4, 4)) == (13, 6, 3, 14)', 'assert bitwise_xor((12, 6, 8, 11), (7, 4, 5, 6)) == (11, 2, 13, 13)']","आप निम्नलिखित तरीके से एक फ़ंक्शन लिख सकते हैं:

```python
def bitwise_xor(tuples):
    result = 0
    for num in tuples:
        result ^= num
    return result
```

इस फ़ंक्शन का उपयोग करने के लिए, आप बस इसे निम्नलिखित तरीके से कॉल करें:

```python
print(bitwise_xor((5, 6, 7)))  # Output: 2
```

यह फ़ंक्शन टुपल में सभी संख्याओं के बीच बिटवाइज़ xor ऑपरेशन करता है। यदि आप इसे एक खाली टुपल के साथ कॉल करते हैं, तो यह 0 लौटाएगा, क्योंकि xor ऑपरेशन का आधार नियम है कि किसी भी संख्या का xor 0 उसी संख्या होता है।"
Benchmark Questions Verification V2.ipynb,400,दी गई सूची में अद्वितीय टुपल्स की संख्या निकालने के लिए एक फ़ंक्शन लिखें।,"def extract_freq(test_list):
  res = len(list(set(tuple(sorted(sub)) for sub in test_list)))
  return (res)",[],"['assert extract_freq([(3, 4), (1, 2), (4, 3), (5, 6)] ) == 3', 'assert extract_freq([(4, 15), (2, 3), (5, 4), (6, 7)] ) == 4', 'assert extract_freq([(5, 16), (2, 3), (6, 5), (6, 9)] ) == 4']","आप निम्नलिखित फ़ंक्शन का उपयोग कर सकते हैं:

```python
def count_unique_tuples(lst):
    return len(set(lst))

# उदाहरण के लिए:
lst = [(1, 2), (3, 4), (1, 2), (5, 6), (7, 8), (1, 2), (3, 4), (3, 4), (7, 8), (9, 10)]
print(count_unique_tuples(lst))  # यह 5 प्रिंट करेगा
```

इस फ़ंक्शन में, हम सबसे पहले टुपल्स की सूची को एक सेट में परिवर्तित करते हैं, जो अद्वितीय मानों को ही रखता है। फिर हम इस सेट की लंबाई को लौटाते हैं, जो अद्वितीय टुपल्स की संख्या होती है।"
Benchmark Questions Verification V2.ipynb,401,दिए गए दो नेस्टेड टुपल्स में टुपल तत्वों को सूचकांक के अनुसार जोड़ने के लिए एक फ़ंक्शन लिखें।,"def add_nested_tuples(test_tup1, test_tup2):
  res = tuple(tuple(a + b for a, b in zip(tup1, tup2))
   for tup1, tup2 in zip(test_tup1, test_tup2))
  return (res) ",[],"['assert add_nested_tuples(((1, 3), (4, 5), (2, 9), (1, 10)), ((6, 7), (3, 9), (1, 1), (7, 3))) == ((7, 10), (7, 14), (3, 10), (8, 13))', 'assert add_nested_tuples(((2, 4), (5, 6), (3, 10), (2, 11)), ((7, 8), (4, 10), (2, 2), (8, 4))) == ((9, 12), (9, 16), (5, 12), (10, 15))', 'assert add_nested_tuples(((3, 5), (6, 7), (4, 11), (3, 12)), ((8, 9), (5, 11), (3, 3), (9, 5))) == ((11, 14), (11, 18), (7, 14), (12, 17))']","यहां एक फ़ंक्शन है जो दो नेस्टेड टुपल्स के टुपल तत्वों को सूचकांक के अनुसार जोड़ता है:

```python
def join_tuples(tup1, tup2):
    # दोनों टुपल्स की लंबाई की जांच करें
    if len(tup1) != len(tup2):
        return ""टुपल्स की लंबाई समान होनी चाहिए""
    
    # नया टुपल बनाएं
    result = []
    for i in range(len(tup1)):
        # टुपल तत्वों को जोड़ें
        joined = tup1[i] + tup2[i]
        result.append(joined)
    
    return tuple(result)
```

उदाहरण के लिए:

```python
tup1 = ((1, 2), (3, 4), (5, 6))
tup2 = ((7, 8), (9, 10), (11, 12))
print(join_tuples(tup1, tup2))
```

आउटपुट:

```python
((1, 2, 7, 8), (3, 4, 9, 10), (5, 6, 11, 12))
```"
Benchmark Questions Verification V2.ipynb,404,न्यूनतम दो संख्याएँ ज्ञात करने के लिए एक पायथन फ़ंक्शन लिखें।,"def minimum(a,b):   
    if a <= b: 
        return a 
    else: 
        return b ",[],"['assert minimum(1,2) == 1', 'assert minimum(-5,-4) == -5', 'assert minimum(0,0) == 0']","आप निम्नलिखित पायथन फ़ंक्शन का उपयोग कर सकते हैं जो एक सूची में सबसे कम दो संख्याओं को लौटाता है:

```python
def find_two_smallest(numbers):
    # सूची की प्रतिलिपि बनाएं और छोटी से बड़ी क्रम में सॉर्ट करें
    sorted_numbers = sorted(numbers)
    # सबसे छोटी दो संख्याएं लौटाएं
    return sorted_numbers[0], sorted_numbers[1]

# उदाहरण के लिए
numbers = [10, 2, 5, 1, 8, 7]
print(find_two_smallest(numbers))  # यह (1, 2) लौटाएगा
```

यह फ़ंक्शन `sorted` फ़ंक्शन का उपयोग करता है जो एक सूची की प्रतिलिपि बनाता है और उसे छोटी से बड़ी क्रम में सॉर्ट करता है। फिर यह सबसे छोटी दो संख्याएं लौटाता है, जो सूची के पहले दो तत्व होंगे।"
Benchmark Questions Verification V2.ipynb,405,यह जांचने के लिए एक फ़ंक्शन लिखें कि क्या कोई तत्व टुपल के भीतर मौजूद है।,"def check_tuplex(tuplex,tuple1): 
  if tuple1 in tuplex:
    return True
  else:
     return False",[],"['assert check_tuplex((""w"", 3, ""r"", ""e"", ""s"", ""o"", ""u"", ""r"", ""c"", ""e""),\'r\')==True', 'assert check_tuplex((""w"", 3, ""r"", ""e"", ""s"", ""o"", ""u"", ""r"", ""c"", ""e""),\'5\')==False', 'assert check_tuplex((""w"", 3, ""r"", ""e"", ""s"", ""o"", ""u"", ""r"", ""c"",""e""),3)==True']","आप निम्नलिखित फ़ंक्शन का उपयोग कर सकते हैं:

```python
def check_element_in_tuple(tup, elem):
    return elem in tup
```

इस फ़ंक्शन का उपयोग करने के लिए, आप टुपल और जिस तत्व की जांच करनी है, उसे पास करें। यदि तत्व टुपल में मौजूग होता है, तो यह `True` लौटाएगा, अन्यथा `False`।

उदाहरण:

```python
tup = (1, 2, 3, 4, 5)
print(check_element_in_tuple(tup, 3))  # यह True प्रिंट करेगा
print(check_element_in_tuple(tup, 6))  # यह False प्रिंट करेगा
```"
Benchmark Questions Verification V2.ipynb,406,किसी दी गई संख्या की समता विषम है या नहीं यह जानने के लिए एक पायथन फ़ंक्शन लिखें।,"def find_Parity(x): 
    y = x ^ (x >> 1); 
    y = y ^ (y >> 2); 
    y = y ^ (y >> 4); 
    y = y ^ (y >> 8); 
    y = y ^ (y >> 16); 
    if (y & 1): 
        return True
    return False",[],"['assert find_Parity(12) == False', 'assert find_Parity(7) == True', 'assert find_Parity(10) == False']","आप निम्नलिखित पायथन फ़ंक्शन का उपयोग कर सकते हैं:

```python
def check_even_odd(num):
    if num % 2 == 0:
        return ""सम""
    else:
        return ""विषम""
```

इस फ़ंक्शन का उपयोग करने के लिए, आपको बस जांचने के लिए संख्या पास करनी होगी। उदाहरण के लिए:

```python
print(check_even_odd(7))  # विषम
print(check_even_odd(8))  # सम
```"
Benchmark Questions Verification V2.ipynb,407,किसी दी गई संख्या के अंकों को पुनर्व्यवस्थित करके अगली बड़ी संख्या बनाने के लिए एक फ़ंक्शन लिखें।,"def rearrange_bigger(n):
    nums = list(str(n))
    for i in range(len(nums)-2,-1,-1):
        if nums[i] < nums[i+1]:
            z = nums[i:]
            y = min(filter(lambda x: x > z[0], z))
            z.remove(y)
            z.sort()
            nums[i:] = [y] + z
            return int("""".join(nums))
    return False",[],"['assert rearrange_bigger(12)==21', 'assert rearrange_bigger(10)==False', 'assert rearrange_bigger(102)==120']","यहां एक फ़ंक्शन है जो दी गई संख्या के अंकों को पुनर्व्यवस्थित करके अगली बड़ी संख्या बनाता है। यह फ़ंक्शन नेक्स्ट परम्परागत लाइब्रेरी का उपयोग करता है।

```python
from itertools import permutations

def next_bigger_number(n):
    # संख्या को स्ट्रिंग में परिवर्तित करें
    str_n = str(n)
    
    # स्ट्रिंग के सभी संभावित परिवर्तनों की सूची बनाएं
    perm = [int(''.join(p)) for p in permutations(str_n)]
    
    # सूची को छोटी से बड़ी क्रम में क्रमबद्ध करें
    perm.sort()
    
    # वर्तमान संख्या के बाद की अगली संख्या खोजें
    for i in range(len(perm)):
        if perm[i] == n:
            if i+1 < len(perm):
                return perm[i+1]
            else:
                return -1

    return -1
```

उदाहरण के लिए, `next_bigger_number(123)` का परिणाम `132` होगा, और `next_bigger_number(321)` का परिणाम `-1` होगा क्योंकि इससे बड़ी कोई संख्या नहीं है जो इन्हीं अंकों का उपयोग करती हो।"
Benchmark Questions Verification V2.ipynb,408,"सबसे छोटी जोड़ियों की k संख्या ज्ञात करने के लिए एक फ़ंक्शन लिखें, जिसमें पहले एरे से एक तत्व और दूसरे एरे से एक तत्व शामिल हो।","import heapq
def k_smallest_pairs(nums1, nums2, k):
   queue = []
   def push(i, j):
       if i < len(nums1) and j < len(nums2):
           heapq.heappush(queue, [nums1[i] + nums2[j], i, j])
   push(0, 0)
   pairs = []
   while queue and len(pairs) < k:
       _, i, j = heapq.heappop(queue)
       pairs.append([nums1[i], nums2[j]])
       push(i, j + 1)
       if j == 0:
           push(i + 1, 0)
   return pairs",[],"['assert k_smallest_pairs([1,3,7],[2,4,6],2)==[[1, 2], [1, 4]]', 'assert k_smallest_pairs([1,3,7],[2,4,6],1)==[[1, 2]]', 'assert k_smallest_pairs([1,3,7],[2,4,6],7)==[[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]]']","यहां एक फ़ंक्शन है जो दो एरे और एक संख्या k को इनपुट के रूप में लेता है और सबसे छोटी जोड़ियों की k संख्या ज्ञात करता है, जिसमें पहले एरे से एक तत्व और दूसरे एरे से एक तत्व शामिल हो।

```python
import heapq

def smallest_pairs(nums1, nums2, k):
    queue = []

    def push(i, j):
        if i < len(nums1) and j < len(nums2):
            heapq.heappush(queue, [nums1[i] + nums2[j], i, j])

    push(0, 0)
    pairs = []
    while queue and len(pairs) < k:
        _, i, j = heapq.heappop(queue)
        pairs.append([nums1[i], nums2[j]])

        push(i, j + 1)
        if j == 0:
            push(i + 1, 0)

    return pairs
```

इस फ़ंक्शन का उपयोग करने के लिए, आप दो एरे और k की संख्या पास करें:

```python
nums1 = [1, 7, 11]
nums2 = [2, 4, 6]
k = 3
print(smallest_pairs(nums1, nums2, k))
```

यह [1,2], [1,4] और [1,6] के रूप में सबसे छोटी 3 जोड़ियाँ देगा।"
Benchmark Questions Verification V2.ipynb,409,किसी दी गई सूची में टुपल्स के जोड़े से न्यूनतम उत्पाद खोजने के लिए एक फ़ंक्शन लिखें।,"def min_product_tuple(list1):
    result_min = min([abs(x * y) for x, y in list1] )
    return result_min",[],"['assert min_product_tuple([(2, 7), (2, 6), (1, 8), (4, 9)] )==8', 'assert min_product_tuple([(10,20), (15,2), (5,10)] )==30', 'assert min_product_tuple([(11,44), (10,15), (20,5), (12, 9)] )==100']","आप इसे निम्नलिखित तरीके से कर सकते हैं:

```python
def min_product(lst):
    return min(a*b for a, b in lst)
```

इस फ़ंक्शन का उपयोग करके, आप एक सूची में टुपल्स के जोड़े का न्यूनतम उत्पाद प्राप्त कर सकते हैं। यह फ़ंक्शन एक सूची को इनपुट के रूप में लेता है और फिर उस सूची में हर टुपल के दोनों तत्वों का उत्पाद निकालता है, और फिर उन सभी उत्पादों में से सबसे छोटे को लौटाता है।"
Benchmark Questions Verification V2.ipynb,410,किसी दी गई विषमांगी सूची में न्यूनतम मान ज्ञात करने के लिए एक फ़ंक्शन लिखें।,"def min_val(listval):
     min_val = min(i for i in listval if isinstance(i, int))
     return min_val",[],"[""assert min_val(['Python', 3, 2, 4, 5, 'version'])==2"", ""assert min_val(['Python', 15, 20, 25])==15"", ""assert min_val(['Python', 30, 20, 40, 50, 'version'])==20""]","आप निम्नलिखित फ़ंक्शन का उपयोग कर सकते हैं:

```python
def find_min(lst):
    return min(lst)
```

इस फ़ंक्शन का उपयोग करने के लिए, आपको बस एक सूची पास करनी होगी। उदाहरण के लिए:

```python
numbers = [4, 2, 9, 3, 5, 1, 8, 7, 6]
print(find_min(numbers))
```

यह 1 प्रिंट करेगा, क्योंकि यह सूची में सबसे छोटा संख्या है।"
charlessutton@: Benchmark Questions Verification V2.ipynb,411,दिए गए स्नेक केस स्ट्रिंग को कैमल केस स्ट्रिंग में बदलने के लिए एक फ़ंक्शन लिखें।,"import re
def snake_to_camel(word):
  return ''.join(x.capitalize() or '_' for x in word.split('_'))",[],"[""assert snake_to_camel('android_tv') == 'AndroidTv'"", ""assert snake_to_camel('google_pixel') == 'GooglePixel'"", ""assert snake_to_camel('apple_watch') == 'AppleWatch'""]","आप निम्नलिखित फ़ंक्शन का उपयोग कर सकते हैं:

```python
def snake_to_camel(snake_str):
    components = snake_str.split('_')
    return components[0] + ''.join(x.title() for x in components[1:])
```

इस फ़ंक्शन का उपयोग करने के लिए, आप निम्नलिखित कोड का उपयोग कर सकते हैं:

```python
print(snake_to_camel('hello_world'))  # Outputs: helloWorld
```

यह फ़ंक्शन एक स्नेक केस स्ट्रिंग को लेता है, उसे अंडरस्कोर ('_') के आधार पर विभाजित करता है, और फिर प्रत्येक घटक को कैमल केस में बदलता है (पहले अक्षर को छोड़कर सभी अक्षरों को कैपिटलाइज़ करता है)."
charlessutton@: Benchmark Questions Verification V2.ipynb,412,किसी दी गई सूची से विषम संख्याओं को हटाने के लिए एक पायथन फ़ंक्शन लिखें।,"def remove_odd(l):
    for i in l:
        if i % 2 != 0:
            l.remove(i)
    return l",[],"['assert remove_odd([1,2,3]) == [2]', 'assert remove_odd([2,4,6]) == [2,4,6]', 'assert remove_odd([10,20,3]) == [10,20]']","आप निम्नलिखित पायथन फ़ंक्शन का उपयोग कर सकते हैं जो एक सूची से सभी विषम संख्याओं को हटा देगा:

```python
def remove_odd_numbers(lst):
    return [i for i in lst if i % 2 == 0]
```

इस फ़ंक्शन का उपयोग करने के लिए, आपको बस इसे एक सूची के साथ कॉल करना होगा, जैसे कि:

```python
numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9]
print(remove_odd_numbers(numbers))
```

यह सभी विषम संख्याओं को हटा देगा और सूची `[2, 4, 6, 8]` को प्रिंट करेगा."
charlessutton@: Benchmark Questions Verification V2.ipynb,413,टुपल्स की दी गई सूची से nवां तत्व निकालने के लिए एक फ़ंक्शन लिखें।,"def extract_nth_element(list1, n):
    result = [x[n] for x in list1]
    return result",[],"[""assert extract_nth_element([('Greyson Fulton', 98, 99), ('Brady Kent', 97, 96), ('Wyatt Knott', 91, 94), ('Beau Turnbull', 94, 98)] ,0)==['Greyson Fulton', 'Brady Kent', 'Wyatt Knott', 'Beau Turnbull']"", ""assert extract_nth_element([('Greyson Fulton', 98, 99), ('Brady Kent', 97, 96), ('Wyatt Knott', 91, 94), ('Beau Turnbull', 94, 98)] ,2)==[99, 96, 94, 98]"", ""assert extract_nth_element([('Greyson Fulton', 98, 99), ('Brady Kent', 97, 96), ('Wyatt Knott', 91, 94), ('Beau Turnbull', 94, 98)],1)==[98, 97, 91, 94]""]","आप निम्नलिखित फ़ंक्शन का उपयोग कर सकते हैं:

```python
def extract_nth_element(tuple_list, n):
    return [tup[n] for tup in tuple_list]
```

इस फ़ंक्शन का उपयोग करने के लिए, आपको टुपल्स की सूची और निकालने के लिए तत्व का सूचक पास करना होगा। उदाहरण के लिए:

```python
tuples = [(1, 'a'), (2, 'b'), (3, 'c')]
print(extract_nth_element(tuples, 0))  # यह [1, 2, 3] प्रिंट करेगा
print(extract_nth_element(tuples, 1))  # यह ['a', 'b', 'c'] प्रिंट करेगा
```

कृपया ध्यान दें कि इस फ़ंक्शन का उपयोग करते समय सूचक 0-आधारित है, इसलिए पहला तत्व 0 है, दूसरा 1 है, और इसी तरह से।"
charlessutton@: Benchmark Questions Verification V2.ipynb,414,यह जांचने के लिए एक पायथन फ़ंक्शन लिखें कि किसी अनुक्रम में कोई मान मौजूद है या नहीं।,"def overlapping(list1,list2):  
    for i in range(len(list1)): 
        for j in range(len(list2)): 
            if(list1[i]==list2[j]): 
                return True
    return False",[],"['assert overlapping([1,2,3,4,5],[6,7,8,9]) == False', 'assert overlapping([1,2,3],[4,5,6]) == False', 'assert overlapping([1,4,5],[1,4,5]) == True']","आप निम्नलिखित तरीके से एक पायथन फ़ंक्शन लिख सकते हैं:

```python
def check_value(sequence, value):
    return value in sequence
```

इस फ़ंक्शन का उपयोग करने के लिए, आप अनुक्रम और मान दोनों को आर्गुमेंट के रूप में पास करेंगे। यदि मान अनुक्रम में मौजूद है, तो यह True लौटाएगा, अन्यथा False।

उदाहरण:

```python
print(check_value([1, 2, 3, 4, 5], 3))  # यह True प्रिंट करेगा
print(check_value([1, 2, 3, 4, 5], 6))  # यह False प्रिंट करेगा
```"
charlessutton@: Benchmark Questions Verification V2.ipynb,415,पूर्णांकों की दी गई सारणी से उच्चतम उत्पाद वाला जोड़ा ढूंढने के लिए एक पायथन फ़ंक्शन लिखें।,"def max_Product(arr): 
    arr_len = len(arr) 
    if (arr_len < 2): 
        return (""No pairs exists"")           
    x = arr[0]; y = arr[1]      
    for i in range(0,arr_len): 
        for j in range(i + 1,arr_len): 
            if (arr[i] * arr[j] > x * y): 
                x = arr[i]; y = arr[j] 
    return x,y    ",[],"['assert max_Product([1,2,3,4,7,0,8,4]) == (7,8)', 'assert max_Product([0,-1,-2,-4,5,0,-6]) == (-4,-6)', 'assert max_Product([1,2,3]) == (2,3)']","यहां एक संभावित पायथन फ़ंक्शन है जो दिए गए पूर्णांकों की सूची से उच्चतम उत्पाद वाले जोड़े को ढूंढता है:

```python
def find_max_product_pair(lst):
    if len(lst) < 2:
        return None
    lst.sort()
    return (lst[-1], lst[-2])

# उदाहरण के लिए:
lst = [1, 3, 4, 5, 2]
print(find_max_product_pair(lst))  # यह (5, 4) प्रिंट करेगा
```

यह फ़ंक्शन सूची को छोटे से बड़े क्रम में सॉर्ट करता है, और फिर सबसे बड़े दो तत्वों को वापस लौटाता है, जो कि उच्चतम उत्पाद वाले जोड़े होंगे। यदि सूची में कम से कम दो तत्व नहीं हैं, तो यह None लौटाता है।"
charlessutton@: Benchmark Questions Verification V2.ipynb,417,टुपल की दी गई सूची में सामान्य पहला तत्व खोजने के लिए एक फ़ंक्शन लिखें।,"def group_tuples(Input): 
	out = {} 
	for elem in Input: 
		try: 
			out[elem[0]].extend(elem[1:]) 
		except KeyError: 
			out[elem[0]] = list(elem) 
	return [tuple(values) for values in out.values()] ",[],"[""assert group_tuples([('x', 'y'), ('x', 'z'), ('w', 't')]) == [('x', 'y', 'z'), ('w', 't')]"", ""assert group_tuples([('a', 'b'), ('a', 'c'), ('d', 'e')]) == [('a', 'b', 'c'), ('d', 'e')]"", ""assert group_tuples([('f', 'g'), ('f', 'g'), ('h', 'i')]) == [('f', 'g', 'g'), ('h', 'i')]""]","आप निम्नलिखित फ़ंक्शन का उपयोग कर सकते हैं:

```python
def find_first_common_element(list_of_tuples):
    # एक सेट बनाएं जिसमें पहले टुपल के सभी तत्व हों
    first_tuple_elements = set(list_of_tuples[0])

    # बाकी हर टुपल के लिए
    for tuple in list_of_tuples[1:]:
        # इस टुपल के तत्वों का एक सेट बनाएं
        tuple_elements = set(tuple)

        # पहले टुपल के तत्वों का सेट अपडेट करें ताकि यह केवल उन तत्वों को शामिल करे जो इस टुपल में भी हैं
        first_tuple_elements.intersection_update(tuple_elements)

    # पहला सामान्य तत्व लौटाएं, यदि कोई हो
    if first_tuple_elements:
        return list(first_tuple_elements)[0]
    else:
        return None
```

यह फ़ंक्शन एक सूची की तुपलों को इनपुट के रूप में लेता है और पहला सामान्य तत्व लौटाता है जो सभी तुपलों में पाया जाता है। यदि कोई सामान्य तत्व नहीं होता है, तो यह None लौटाता है."
charlessutton@: Benchmark Questions Verification V2.ipynb,418,अधिकतम लंबाई वाली सूची के तत्व को खोजने के लिए एक पायथन फ़ंक्शन लिखें।,"def Find_Max(lst): 
    maxList = max((x) for x in lst) 
    return maxList",[],"[""assert Find_Max([['A'],['A','B'],['A','B','C']]) == ['A','B','C']"", 'assert Find_Max([[1],[1,2],[1,2,3]]) == [1,2,3]', 'assert Find_Max([[1,1],[1,2,3],[1,5,6,1]]) == [1,5,6,1]']","यहां एक संभावित पायथन फ़ंक्शन है जो एक सूची में सबसे लंबी स्ट्रिंग को खोजता है:

```python
def longest_string_in_list(lst):
    if not lst:  # सूची खाली है
        return None
    longest_string = lst[0]
    for string in lst:
        if len(string) > len(longest_string):
            longest_string = string
    return longest_string
```

इस फ़ंक्शन का उपयोग निम्नलिखित प्रकार से किया जा सकता है:

```python
lst = ['एक', 'दो', 'तीन', 'चार', 'पांच']
print(longest_string_in_list(lst))  # आउटपुट: 'तीन'
```"
charlessutton@: Benchmark Questions Verification V2.ipynb,419,संख्याओं की दी गई सूची में प्रत्येक संख्या को पूर्णांकित करने के लिए एक फ़ंक्शन लिखें और कुल योग को सूची की लंबाई से गुणा करके प्रिंट करें।,"def round_and_sum(list1):
  lenght=len(list1)
  round_and_sum=sum(list(map(round,list1))* lenght)
  return round_and_sum",[],"['assert round_and_sum([22.4, 4.0, -16.22, -9.10, 11.00, -12.22, 14.20, -5.20, 17.50])==243', 'assert round_and_sum([5,2,9,24.3,29])==345', 'assert round_and_sum([25.0,56.7,89.2])==513']","आप निम्नलिखित फ़ंक्शन का उपयोग कर सकते हैं:

```python
def multiply_sum_by_length(numbers):
    # प्रत्येक संख्या को पूर्णांकित करने
    int_numbers = [int(num) for num in numbers]
    # कुल योग को सूची की लंबाई से गुणा करने
    result = sum(int_numbers) * len(int_numbers)
    print(result)

# उदाहरण के लिए
multiply_sum_by_length([1.2, 2.3, 3.4, 4.5, 5.6])
```

इस फ़ंक्शन का उपयोग करके, आप संख्याओं की दी गई सूची में प्रत्येक संख्या को पूर्णांकित कर सकते हैं और फिर कुल योग को सूची की लंबाई से गुणा कर सकते हैं।"
charlessutton@: Benchmark Questions Verification V2.ipynb,420,प्रथम n सम प्राकृतिक संख्याओं का घन योग ज्ञात करने के लिए एक पायथन फ़ंक्शन लिखें।,"def cube_Sum(n): 
    sum = 0
    for i in range(1,n + 1): 
        sum += (2*i)*(2*i)*(2*i) 
    return sum",[],"['assert cube_Sum(2) == 72', 'assert cube_Sum(3) == 288', 'assert cube_Sum(4) == 800']","आप निम्नलिखित पायथन फ़ंक्शन का उपयोग कर सकते हैं:

```python
def sum_of_cubes(n):
    sum = 0
    for i in range(1, n+1):
        sum += i**3
    return sum
```

इस फ़ंक्शन का उपयोग करके, आप प्रथम n सम प्राकृतिक संख्याओं का घन योग ज्ञात कर सकते हैं। उदाहरण के लिए, `sum_of_cubes(3)` का परिणाम `36` होगा, क्योंकि 1^3 + 2^3 + 3^3 = 1 + 8 + 27 = 36 है।"
charlessutton@: Benchmark Questions Verification V2.ipynb,421,टपल के प्रत्येक तत्व को सीमांकक द्वारा संयोजित करने के लिए एक फ़ंक्शन लिखें।,"def concatenate_tuple(test_tup):
    delim = ""-""
    res = ''.join([str(ele) + delim for ele in test_tup])
    res = res[ : len(res) - len(delim)]
    return (str(res)) ",[],"['assert concatenate_tuple((""ID"", ""is"", 4, ""UTS"") ) == \'ID-is-4-UTS\'', 'assert concatenate_tuple((""QWE"", ""is"", 4, ""RTY"") ) == \'QWE-is-4-RTY\'', 'assert concatenate_tuple((""ZEN"", ""is"", 4, ""OP"") ) == \'ZEN-is-4-OP\'']","आप निम्नलिखित फ़ंक्शन का उपयोग कर सकते हैं:

```python
def join_tuple_elements_with_comma(tup):
    return ', '.join(map(str, tup))
```

इस फ़ंक्शन का उपयोग करने के लिए, आप एक टपल पास करेंगे और यह एक स्ट्रिंग वापस करेगा जिसमें टपल के सभी तत्व कोमा से जोड़ा जाता है। उदाहरण के लिए:

```python
tup = (1, 2, 3, 4, 5)
print(join_tuple_elements_with_comma(tup))
```

आउटपुट होगा: '1, 2, 3, 4, 5'"
charlessutton@: Benchmark Questions Verification V2.ipynb,422,प्रथम n प्राकृतिक संख्याओं के घनों का औसत ज्ञात करने के लिए एक पायथन फ़ंक्शन लिखें।,"def find_Average_Of_Cube(n):  
    sum = 0
    for i in range(1, n + 1): 
        sum += i * i * i  
    return round(sum / n, 6) ",[],"['assert find_Average_Of_Cube(2) == 4.5', 'assert find_Average_Of_Cube(3) == 12', 'assert find_Average_Of_Cube(1) == 1']","आप निम्नलिखित पायथन फ़ंक्शन का उपयोग कर सकते हैं:

```python
def avg_cubes(n):
    sum_of_cubes = 0
    for i in range(1, n+1):
        sum_of_cubes += i**3
    return sum_of_cubes/n
```

इस फ़ंक्शन का उपयोग करके, आप प्रथम n प्राकृतिक संख्याओं के घनों का औसत ज्ञात कर सकते हैं। यह फ़ंक्शन प्रत्येक संख्या का घन निकालता है, उन्हें जोड़ता है, और फिर उस संख्या को n से विभाजित करता है ताकि औसत निकाला जा सके।"
charlessutton@: Benchmark Questions Verification V2.ipynb,424,दिए गए टुपल में प्रत्येक स्ट्रिंग के केवल पिछले इंडेक्स तत्व को निकालने के लिए एक फ़ंक्शन लिखें।,"def extract_rear(test_tuple):
  res = list(sub[len(sub) - 1] for sub in test_tuple)
  return (res) ",[],"[""assert extract_rear(('Mers', 'for', 'Vers') ) == ['s', 'r', 's']"", ""assert extract_rear(('Avenge', 'for', 'People') ) == ['e', 'r', 'e']"", ""assert extract_rear(('Gotta', 'get', 'go') ) == ['a', 't', 'o']""]","आप निम्नलिखित फ़ंक्शन का उपयोग कर सकते हैं:

```python
def last_index_elements(tup):
    return [item[-1] for item in tup if isinstance(item, str)]

# उदाहरण
tup = ('hello', 'world', 'python', 'programming')
print(last_index_elements(tup))  # ['o', 'd', 'n', 'g']
```

यह फ़ंक्शन एक टुपल लेता है और फिर उसके हर स्ट्रिंग तत्व के अंतिम अक्षर को एक सूची में डालता है। यह फ़ंक्शन टुपल में स्ट्रिंग के अलावा अन्य डेटा प्रकारों को छोड़ देगा।"
charlessutton@: Benchmark Questions Verification V2.ipynb,425,किसी विशेष तत्व वाली उपसूचियों की संख्या गिनने के लिए एक फ़ंक्शन लिखें।,"def count_element_in_list(list1, x): 
    ctr = 0
    for i in range(len(list1)): 
        if x in list1[i]: 
            ctr+= 1          
    return ctr",[],"['assert count_element_in_list([[1, 3], [5, 7], [1, 11], [1, 15, 7]],1)==3', ""assert count_element_in_list([['A', 'B'], ['A', 'C'], ['A', 'D', 'E'], ['B', 'C', 'D']],'A')==3"", ""assert count_element_in_list([['A', 'B'], ['A', 'C'], ['A', 'D', 'E'], ['B', 'C', 'D']],'E')==1""]","आप निम्नलिखित तरीके से एक फ़ंक्शन लिख सकते हैं:

```python
def count_sublists_with_element(lst, element):
    return sum(element in sublist for sublist in lst)
```

इस फ़ंक्शन का उपयोग करने के लिए, आप एक सूची और एक तत्व पास करेंगे, और यह उन सभी उपसूचियों की संख्या लौटाएगा जिनमें वह तत्व मौजूद है। उदाहरण के लिए:

```python
lst = [[1, 2, 3], [4, 5, 6], [1, 2, 3], [7, 8, 9]]
element = 1
print(count_sublists_with_element(lst, element))  # यह 2 प्रिंट करेगा, क्योंकि 1 पहली और तीसरी उपसूची में है।
```"
charlessutton@: Benchmark Questions Verification V2.ipynb,426,विषम संख्याओं को फ़िल्टर करने के लिए एक फ़ंक्शन लिखें।,"def filter_oddnumbers(nums):
 odd_nums = list(filter(lambda x: x%2 != 0, nums))
 return odd_nums",[],"['assert filter_oddnumbers([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])==[1,3,5,7,9]', 'assert filter_oddnumbers([10,20,45,67,84,93])==[45,67,93]', 'assert filter_oddnumbers([5,7,9,8,6,4,3])==[5,7,9,3]']","विषम संख्याओं को फ़िल्टर करने के लिए, हम एक फ़ंक्शन लिख सकते हैं जो एक सूची को इनपुट के रूप में लेता है और उस सूची में से सभी विषम संख्याओं की एक सूची वापस करता है। यहां एक उदाहरण है:

```python
def filter_odd_numbers(numbers):
    return [num for num in numbers if num % 2 != 0]
```

इस फ़ंक्शन का उपयोग करने के लिए, आप इसे निम्नलिखित तरीके से कॉल कर सकते हैं:

```python
print(filter_odd_numbers([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]))
```

यह `[1, 3, 5, 7, 9]` प्रिंट करेगा, जो 1 से 10 तक की सभी विषम संख्याओं की सूची है।"
charlessutton@: Benchmark Questions Verification V2.ipynb,427,yyyy-mm-dd प्रारूप की तारीख को dd-mm-yyyy प्रारूप में बदलने के लिए एक फ़ंक्शन लिखें।,"import re
def change_date_format(dt):
        return re.sub(r'(\d{4})-(\d{1,2})-(\d{1,2})', '\\3-\\2-\\1', dt)",[],"['assert change_date_format(""2026-01-02"") == \'02-01-2026\'', 'assert change_date_format(""2020-11-13"") == \'13-11-2020\'', 'assert change_date_format(""2021-04-26"") == \'26-04-2021\'']","आप निम्नलिखित तरीके से इसे कर सकते हैं:

```python
from datetime import datetime

def convert_date_format(date_string):
    date_object = datetime.strptime(date_string, '%Y-%m-%d')
    return date_object.strftime('%d-%m-%Y')
```

इस फ़ंक्शन का उपयोग करने के लिए, आप बस इसे निम्नलिखित तरीके से कॉल करें:

```python
print(convert_date_format('2022-01-01'))  # यह '01-01-2022' प्रिंट करेगा
```

यह फ़ंक्शन `datetime.strptime` का उपयोग करके तारीख को एक तारीख ऑब्जेक्ट में परिवर्तित करता है, और फिर `strftime` का उपयोग करके उसे नए प्रारूप में प्रिंट करता है."
charlessutton@: Benchmark Questions Verification V2.ipynb,428,शेल सॉर्ट का उपयोग करके दिए गए ऐरे को सॉर्ट करने के लिए एक फ़ंक्शन लिखें।,"def shell_sort(my_list):
    gap = len(my_list) // 2
    while gap > 0:
        for i in range(gap, len(my_list)):
            current_item = my_list[i]
            j = i
            while j >= gap and my_list[j - gap] > current_item:
                my_list[j] = my_list[j - gap]
                j -= gap
            my_list[j] = current_item
        gap //= 2

    return my_list",[],"['assert shell_sort([12, 23, 4, 5, 3, 2, 12, 81, 56, 95]) == [2, 3, 4, 5, 12, 12, 23, 56, 81, 95]', 'assert shell_sort([24, 22, 39, 34, 87, 73, 68]) == [22, 24, 34, 39, 68, 73, 87]', 'assert shell_sort([32, 30, 16, 96, 82, 83, 74]) == [16, 30, 32, 74, 82, 83, 96]']","शेल सॉर्ट एक उन्नत वर्गीकरण तकनीक है जिसे डोनाल्ड शेल ने विकसित किया था। यह एक विशेष प्रकार का इंसर्शन सॉर्ट है जो दूरी के बजाय एक बार में एक ही तत्व पर काम करता है। यहां एक फ़ंक्शन है जो शेल सॉर्ट का उपयोग करके एक ऐरे को सॉर्ट करता है:

```python
def shellSort(arr):
    n = len(arr)
    gap = n//2

    while gap > 0:
        for i in range(gap,n):
            temp = arr[i]
            j = i
            while  j >= gap and arr[j-gap] >temp:
                arr[j] = arr[j-gap]
                j -= gap
            arr[j] = temp
        gap //= 2

    return arr
```

इस फ़ंक्शन का उपयोग करने के लिए, आपको बस इसे निम्नलिखित तरीके से कॉल करना होगा:

```python
arr = [12, 34, 54, 2, 3]
print(shellSort(arr))
```

यह आपको सॉर्ट किए गए ऐरे को प्रिंट करेगा।"
charlessutton@: Benchmark Questions Verification V2.ipynb,429,दिए गए दो टुपल्स से तत्ववार और टुपल्स निकालने के लिए एक फ़ंक्शन लिखें।,"def and_tuples(test_tup1, test_tup2):
  res = tuple(ele1 & ele2 for ele1, ele2 in zip(test_tup1, test_tup2))
  return (res) ",[],"['assert and_tuples((10, 4, 6, 9), (5, 2, 3, 3)) == (0, 0, 2, 1)', 'assert and_tuples((1, 2, 3, 4), (5, 6, 7, 8)) == (1, 2, 3, 0)', 'assert and_tuples((8, 9, 11, 12), (7, 13, 14, 17)) == (0, 9, 10, 0)']","आप निम्नलिखित तरीके से एक फ़ंक्शन लिख सकते हैं:

```python
def extract_elements(tup1, tup2):
    # दोनों टुपल्स को एक साथ जोड़ने के लिए
    combined = tup1 + tup2
    
    # तत्ववार निकालने के लिए
    for i in combined:
        print(i)
    
    # टुपल्स निकालने के लिए
    return combined
```

इस फ़ंक्शन का उपयोग करने के लिए, आप निम्नलिखित तरीके से कर सकते हैं:

```python
tup1 = (1, 2, 3)
tup2 = (4, 5, 6)
print(extract_elements(tup1, tup2))
```

यह फ़ंक्शन पहले दोनों टुपल्स को एक साथ जोड़ता है, फिर उसके हर तत्व को प्रिंट करता है, और अंत में जोड़े गए टुपल्स को वापस लौटाता है।"
charlessutton@: Benchmark Questions Verification V2.ipynb,430,परवलय की नियता ज्ञात करने के लिए एक फ़ंक्शन लिखें।,"def parabola_directrix(a, b, c): 
  directrix=((int)(c - ((b * b) + 1) * 4 * a ))
  return directrix",[],"['assert parabola_directrix(5,3,2)==-198', 'assert parabola_directrix(9,8,4)==-2336', 'assert parabola_directrix(2,4,6)==-130']","यहां एक सरल फ़ंक्शन है जो एक संख्या की परवलयता की गणना करता है। परवलयता की गणना करने के लिए, हमें दो बिंदुओं के बीच की दूरी की गणना करनी होती है। यह फ़ंक्शन दो बिंदुओं को इनपुट के रूप में लेता है और उनके बीच की दूरी की गणना करता है।

```python
import math

def calculate_parvalayta(point1, point2):
    distance = math.sqrt((point2[0] - point1[0])**2 + (point2[1] - point1[1])**2)
    return distance

# उदाहरण के लिए, यदि हमें बिंदु (1, 2) और (3, 4) के बीच की परवलयता ज्ञात करनी हो तो हम निम्नलिखित तरीके से कॉल कर सकते हैं:
print(calculate_parvalayta((1, 2), (3, 4)))
```

कृपया ध्यान दें कि यह फ़ंक्शन दो बिंदुओं के बीच की यूक्लिडी दूरी की गणना करता है, जो दो बिंदुओं के बीच की ""सीधी रेखा"" दूरी होती है। यदि आपको दो बिंदुओं के बीच की मानक दूरी (जैसे मैनहटन दूरी) या किसी अन्य प्रकार की दूरी की आवश्यकता है, तो आपको इस फ़ंक्शन को अनुकूलित करना होगा।"
charlessutton@: Benchmark Questions Verification V2.ipynb,431,एक फ़ंक्शन लिखें जो दो सूचियाँ लेता है और यदि उनमें कम से कम एक सामान्य तत्व है तो सत्य लौटाता है।,"def common_element(list1, list2):
     result = False
     for x in list1:
         for y in list2:
             if x == y:
                 result = True
                 return result",[],"['assert common_element([1,2,3,4,5], [5,6,7,8,9])==True', 'assert common_element([1,2,3,4,5], [6,7,8,9])==None', ""assert common_element(['a','b','c'], ['d','b','e'])==True""]","आप निम्नलिखित फ़ंक्शन का उपयोग कर सकते हैं:

```python
def common_element(list1, list2):
    for i in list1:
        if i in list2:
            return True
    return False
```

इस फ़ंक्शन का उपयोग करके, आप दो सूचियों में कम से कम एक सामान्य तत्व होने की जांच कर सकते हैं। यदि ऐसा है, तो यह सत्य लौटाएगा, अन्यथा झूठ."
charlessutton@: Benchmark Questions Verification V2.ipynb,432,एक समलंब की औसत लंबाई ज्ञात करने के लिए एक फ़ंक्शन लिखें।,"def median_trapezium(base1,base2,height):
 median = 0.5 * (base1+ base2)
 return median",[],"['assert median_trapezium(15,25,35)==20', 'assert median_trapezium(10,20,30)==15', 'assert median_trapezium(6,9,4)==7.5']","एक समलंब की औसत लंबाई की गणना करने के लिए, हमें दोनों बाहुओं की लंबाई का औसत लेना होगा। यहां एक सरल Python फ़ंक्शन है जो यह करता है:

```python
def average_length_of_parallelogram(side1, side2):
    return (side1 + side2) / 2
```

इस फ़ंक्शन का उपयोग करने के लिए, आपको बस दोनों बाहुओं की लंबाई पास करनी होगी। उदाहरण के लिए:

```python
print(average_length_of_parallelogram(10, 20))
```

यह 15 प्रिंट करेगा, जो 10 और 20 का औसत है।"
charlessutton@: Benchmark Questions Verification V2.ipynb,433,यह जांचने के लिए एक फ़ंक्शन लिखें कि क्या दर्ज की गई संख्या दिए गए सरणी के तत्वों से अधिक है।,"def check_greater(arr, number):
  arr.sort()
  return number > arr[-1]",[],"['assert check_greater([1, 2, 3, 4, 5], 4) == False', 'assert check_greater([2, 3, 4, 5, 6], 8) == True', 'assert check_greater([9, 7, 4, 8, 6, 1], 11) == True']","यहां एक फ़ंक्शन है जो यह जांचता है कि क्या दर्ज की गई संख्या दिए गए सरणी के सभी तत्वों से अधिक है या नहीं।

```python
def is_greater_than_elements(n, lst):
    return all(n > x for x in lst)
```

इस फ़ंक्शन का उपयोग करने के लिए, आपको दर्ज करने की आवश्यकता है संख्या (`n`) और सरणी (`lst`). फ़ंक्शन `True` लौटाएगा यदि `n` सरणी के सभी तत्वों से अधिक है, अन्यथा `False`."
charlessutton@: Benchmark Questions Verification V2.ipynb,434,एक ऐसा फ़ंक्शन लिखें जो उस स्ट्रिंग से मेल खाता हो जिसमें a के बाद एक या अधिक b हो।,"import re
def text_match_one(text):
        patterns = 'ab+?'
        if re.search(patterns,  text):
                return True
        else:
                return False
",[],"['assert text_match_one(""ac"")==False', 'assert text_match_one(""dc"")==False', 'assert text_match_one(""abba"")==True']","आप रेगुलर एक्सप्रेशन का उपयोग करके इसे कर सकते हैं। यहां एक फ़ंक्शन है जो आपकी आवश्यकता को पूरा करता है:

```python
import re

def match_string(s):
    pattern = 'ab+'
    if re.fullmatch(pattern, s):
        return True
    else:
        return False
```

इस फ़ंक्शन का उपयोग करने के लिए, आप बस इसे एक स्ट्रिंग के साथ कॉल करें:

```python
print(match_string('ab'))  # Returns: True
print(match_string('abb'))  # Returns: True
print(match_string('a'))  # Returns: False
print(match_string('abc'))  # Returns: False
```

यह फ़ंक्शन 'ab+' पैटर्न के साथ मेल खाती है, जिसका अर्थ है 'a' के बाद एक या अधिक 'b'. यदि पूरी स्ट्रिंग इस पैटर्न से मेल खाती है, तो यह True लौटाती है, अन्यथा False."
charlessutton@: Benchmark Questions Verification V2.ipynb,435,किसी दी गई संख्या का अंतिम अंक ज्ञात करने के लिए एक पायथन फ़ंक्शन लिखें।,"def last_Digit(n) :
    return (n % 10) ",[],"['assert last_Digit(123) == 3', 'assert last_Digit(25) == 5', 'assert last_Digit(30) == 0']","आप निम्नलिखित पायथन फ़ंक्शन का उपयोग कर सकते हैं:

```python
def get_last_digit(num):
    return num % 10
```

इस फ़ंक्शन का उपयोग करने के लिए, आपको केवल अंतिम अंक ज्ञात करने के लिए संख्या पास करनी होगी। उदाहरण के लिए:

```python
print(get_last_digit(12345))  # यह 5 प्रिंट करेगा
```

यह फ़ंक्शन संख्या को 10 से विभाजित करता है और शेषफल को वापस लौटाता है, जो कि संख्या का अंतिम अंक होता है।"
charlessutton@: Benchmark Questions Verification V2.ipynb,436,किसी सूची में ऋणात्मक संख्याओं को लौटाने के लिए एक पायथन फ़ंक्शन लिखें।,"def neg_nos(list1):
  out = []
  for num in list1: 
    if num < 0: 
      out.append(num)
  return out ",[],"['assert neg_nos([-1,4,5,-6]) == [-1,-6]', 'assert neg_nos([-1,-2,3,4]) == [-1,-2]', 'assert neg_nos([-7,-6,8,9]) == [-7,-6]']","आप निम्नलिखित तरीके से एक पायथन फ़ंक्शन लिख सकते हैं जो किसी सूची में ऋणात्मक संख्याओं को लौटाता है:

```python
def find_negative_numbers(lst):
    return [num for num in lst if num < 0]
```

इस फ़ंक्शन का उपयोग करने के लिए, आप एक सूची पास करेंगे और यह उन सभी संख्याओं की एक सूची लौटाएगा जो ऋणात्मक हैं:

```python
print(find_negative_numbers([1, -2, 3, -4, 5, -6]))
```

आउटपुट:

```python
[-2, -4, -6]
```"
charlessutton@: Benchmark Questions Verification V2.ipynb,437,एक स्ट्रिंग में विषम वर्णों को हटाने के लिए एक फ़ंक्शन लिखें।,"def remove_odd(str1):
 str2 = ''
 for i in range(1, len(str1) + 1):
    if(i % 2 == 0):
        str2 = str2 + str1[i - 1]
 return str2",[],"['assert remove_odd(""python"")==(""yhn"")', 'assert remove_odd(""program"")==(""rga"")', 'assert remove_odd(""language"")==(""agae"")']","यहां एक फ़ंक्शन है जो एक स्ट्रिंग से सभी विषम वर्णों को हटा देता है। यह फ़ंक्शन इंडेक्स पर आधारित है, जिसका अर्थ है कि यह स्ट्रिंग में हर दूसरे वर्ण को हटा देता है, शुरुआत 0 से करते हुए।

```python
def remove_odd_chars(string):
    return ''.join(char for idx, char in enumerate(string) if idx % 2 == 0)
```

उदाहरण के लिए, यदि हम इसे ""हेल्लो"" पर लागू करते हैं, तो हमें ""हलो"" मिलेगा, क्योंकि 'े' और 'ल' विषम इंडेक्स पर हैं (1 और 3, क्रमशः)।

```python
print(remove_odd_chars(""हेल्लो""))  # हलो
```"
charlessutton@: Benchmark Questions Verification V2.ipynb,438,द्विदिशात्मक टपल जोड़े की गणना करने के लिए एक फ़ंक्शन लिखें।,"def count_bidirectional(test_list):
  res = 0
  for idx in range(0, len(test_list)):
    for iidx in range(idx + 1, len(test_list)):
      if test_list[iidx][0] == test_list[idx][1] and test_list[idx][1] == test_list[iidx][0]:
        res += 1
  return res",[],"['assert count_bidirectional([(5, 6), (1, 2), (6, 5), (9, 1), (6, 5), (2, 1)] ) == 3', 'assert count_bidirectional([(5, 6), (1, 3), (6, 5), (9, 1), (6, 5), (2, 1)] ) == 2', 'assert count_bidirectional([(5, 6), (1, 2), (6, 5), (9, 2), (6, 5), (2, 1)] ) == 4']","आप निम्नलिखित तरीके से एक फ़ंक्शन लिख सकते हैं:

```python
def count_pairs(lst):
    return len(lst) // 2
```

यह फ़ंक्शन एक सूची को इनपुट के रूप में लेता है और उसमें द्विदिशात्मक टपल जोड़े की संख्या की गणना करता है। यह धारणा करता है कि सूची में सभी तत्व द्विदिशात्मक टपल हैं। यदि आपको यह सुनिश्चित करना है कि सभी तत्व वास्तव में द्विदिशात्मक टपल हैं, तो आप निम्नलिखित तरीके से फ़ंक्शन को अद्यतित कर सकते हैं:

```python
def count_pairs(lst):
    count = 0
    for item in lst:
        if isinstance(item, tuple) and len(item) == 2:
            count += 1
    return count
```

यह फ़ंक्शन अब सूची के प्रत्येक तत्व के लिए जांचता है कि क्या वह एक टपल है और क्या उसकी लंबाई 2 है। यदि हां, तो यह गणना बढ़ाता है।"
charlessutton@: Benchmark Questions Verification V2.ipynb,439,एकाधिक पूर्णांकों की सूची को एक पूर्णांक में जोड़ने के लिए एक फ़ंक्शन लिखें।,"def multiple_to_single(L):
  x = int("""".join(map(str, L)))
  return x",[],"['assert multiple_to_single([11, 33, 50])==113350', 'assert multiple_to_single([-1,2,3,4,5,6])==-123456', 'assert multiple_to_single([10,15,20,25])==10152025']","आप निम्नलिखित फ़ंक्शन का उपयोग कर सकते हैं:

```python
def sum_integers(integer_list):
    return sum(integer_list)
```

इस फ़ंक्शन का उपयोग करने के लिए, आपको बस एक सूची पास करनी होगी। उदाहरण के लिए:

```python
print(sum_integers([1, 2, 3, 4, 5]))  # Output: 15
```"
charlessutton@: Benchmark Questions Verification V2.ipynb,440,किसी दिए गए वाक्य में पहला क्रियाविशेषण और उनका स्थान खोजने के लिए एक फ़ंक्शन लिखें।,"import re
def find_adverb_position(text):
 for m in re.finditer(r""\w+ly"", text):
    return (m.start(), m.end(), m.group(0))",[],"['assert find_adverb_position(""clearly!! we can see the sky"")==(0, 7, \'clearly\')', 'assert find_adverb_position(""seriously!! there are many roses"")==(0, 9, \'seriously\')', 'assert find_adverb_position(""unfortunately!! sita is going to home"")==(0, 13, \'unfortunately\')']","यहां एक फ़ंक्शन है जो एक वाक्य में पहले क्रियाविशेषण को खोजता है और उसका स्थान देता है। इस फ़ंक्शन का उपयोग करने के लिए, आपको एक वाक्य और एक क्रियाविशेषणों की सूची प्रदान करनी होगी। यह फ़ंक्शन वाक्य में पहले क्रियाविशेषण का स्थान देगा, यदि कोई होता है।

```python
def find_first_adverb_and_position(sentence, adverbs):
    words = sentence.split()
    for i in range(len(words)):
        if words[i] in adverbs:
            return words[i], i
    return None, None

# उदाहरण के लिए
sentence = ""वह धीरे धीरे चलता है""
adverbs = [""धीरे"", ""तेजी"", ""अचानक""]
adverb, position = find_first_adverb_and_position(sentence, adverbs)
print(f""पहला क्रियाविशेषण: {adverb}, स्थान: {position}"")
```

यह फ़ंक्शन वाक्य में पहले क्रियाविशेषण को खोजता है और उसका स्थान देता है। यदि कोई क्रियाविशेषण नहीं मिलता, तो यह None, None लौटाता है।"
charlessutton@: Benchmark Questions Verification V2.ipynb,441,किसी दिए गए आकार के घन का पृष्ठीय क्षेत्रफल ज्ञात करने के लिए एक फ़ंक्शन लिखें।,"def surfacearea_cube(l):
  surfacearea= 6*l*l
  return surfacearea",[],"['assert surfacearea_cube(5)==150', 'assert surfacearea_cube(3)==54', 'assert surfacearea_cube(10)==600']","घन का पृष्ठीय क्षेत्रफल निम्न सूत्र से ज्ञात किया जा सकता है:

पृष्ठीय क्षेत्रफल = 6 * (बीकाणों की लंबाई)^2

इसे Python में इस प्रकार लिखा जा सकता है:

```python
def surface_area_of_cube(side_length):
    return 6 * (side_length ** 2)
```

इस फ़ंक्शन का उपयोग निम्न प्रकार से किया जा सकता है:

```python
print(surface_area_of_cube(5))  # यह 150 प्रिंट करेगा
```"
charlessutton@: Benchmark Questions Verification V2.ipynb,442,पूर्णांकों की किसी सारणी में धनात्मक संख्याओं का अनुपात ज्ञात करने के लिए एक फ़ंक्शन लिखें।,"from array import array
def positive_count(nums):
    n = len(nums)
    n1 = 0
    for x in nums:
        if x > 0:
            n1 += 1
        else:
          None
    return round(n1/n,2)",[],"['assert positive_count([0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8])==0.54', 'assert positive_count([2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8])==0.69', 'assert positive_count([2, 4, -6, -9, 11, -12, 14, -5, 17])==0.56']","आप निम्नलिखित फ़ंक्शन का उपयोग कर सकते हैं:

```python
def positive_ratio(numbers):
    positive_numbers = [num for num in numbers if num > 0]
    return len(positive_numbers) / len(numbers)
```

यह फ़ंक्शन एक सूची को इनपुट के रूप में लेता है और धनात्मक संख्याओं का अनुपात लौटाता है। यदि सूची में कोई संख्या नहीं है, तो यह एक त्रुटि उत्पन्न करेगा। आप इसे निम्नलिखित तरीके से उपयोग कर सकते हैं:

```python
numbers = [1, -2, 3, -4, 5]
print(positive_ratio(numbers))
```

यह `0.6` प्रिंट करेगा, क्योंकि सूची में 5 संख्याएँ हैं, जिनमें से 3 धनात्मक हैं, इसलिए अनुपात 3/5 या 0.6 है।"
charlessutton@: Benchmark Questions Verification V2.ipynb,443,दी गई सूची से सबसे बड़ी ऋणात्मक संख्या ज्ञात करने के लिए एक पायथन फ़ंक्शन लिखें।,"def largest_neg(list1): 
    max = list1[0] 
    for x in list1: 
        if x < max : 
             max = x  
    return max",[],"['assert largest_neg([1,2,3,-4,-6]) == -6', 'assert largest_neg([1,2,3,-8,-9]) == -9', 'assert largest_neg([1,2,3,4,-1]) == -1']","आप निम्नलिखित पायथन फ़ंक्शन का उपयोग कर सकते हैं:

```python
def max_negative_number(lst):
    negative_numbers = [i for i in lst if i < 0]
    return max(negative_numbers) if negative_numbers else None
```

यह फ़ंक्शन एक सूची लेता है और सूची में सबसे बड़ी ऋणात्मक संख्या लौटाता है। यदि सूची में कोई ऋणात्मक संख्या नहीं है, तो यह None लौटाता है।"
charlessutton@: Benchmark Questions Verification V2.ipynb,444,दी गई टुपल सूची में प्रत्येक टुपल को k से ट्रिम करने के लिए एक फ़ंक्शन लिखें।,"def trim_tuple(test_list, K):
  res = []
  for ele in test_list:
    N = len(ele)
    res.append(tuple(list(ele)[K: N - K]))
  return (str(res)) ",[],"[""assert trim_tuple([(5, 3, 2, 1, 4), (3, 4, 9, 2, 1),(9, 1, 2, 3, 5), (4, 8, 2, 1, 7)], 2) == '[(2,), (9,), (2,), (2,)]'"", ""assert trim_tuple([(5, 3, 2, 1, 4), (3, 4, 9, 2, 1), (9, 1, 2, 3, 5), (4, 8, 2, 1, 7)], 1) == '[(3, 2, 1), (4, 9, 2), (1, 2, 3), (8, 2, 1)]'"", ""assert trim_tuple([(7, 8, 4, 9), (11, 8, 12, 4),(4, 1, 7, 8), (3, 6, 9, 7)], 1) == '[(8, 4), (8, 12), (1, 7), (6, 9)]'""]","यहां एक फ़ंक्शन है जो दी गई टुपल सूची में प्रत्येक टुपल को k से ट्रिम करता है:

```python
def trim_tuples(tuple_list, k):
    return [tup[:k] for tup in tuple_list]
```

इस फ़ंक्शन का उपयोग करने के लिए, आप इसे निम्नलिखित तरीके से कॉल कर सकते हैं:

```python
tuple_list = [(1, 2, 3), (4, 5, 6), (7, 8, 9)]
k = 2
print(trim_tuples(tuple_list, k))
```

यह `(1, 2)` और `(4, 5)` और `(7, 8)` की एक सूची प्रिंट करेगा, क्योंकि हमने प्रत्येक टुपल को 2 तत्वों तक ट्रिम किया है।"
charlessutton@: Benchmark Questions Verification V2.ipynb,445,दिए गए दो टुपल्स में टुपल तत्वों का सूचकांकवार गुणन करने के लिए एक फ़ंक्शन लिखें।,"def index_multiplication(test_tup1, test_tup2):
  res = tuple(tuple(a * b for a, b in zip(tup1, tup2))
   for tup1, tup2 in zip(test_tup1, test_tup2))
  return (res) ",[],"['assert index_multiplication(((1, 3), (4, 5), (2, 9), (1, 10)),((6, 7), (3, 9), (1, 1), (7, 3)) ) == ((6, 21), (12, 45), (2, 9), (7, 30))', 'assert index_multiplication(((2, 4), (5, 6), (3, 10), (2, 11)),((7, 8), (4, 10), (2, 2), (8, 4)) ) == ((14, 32), (20, 60), (6, 20), (16, 44))', 'assert index_multiplication(((3, 5), (6, 7), (4, 11), (3, 12)),((8, 9), (5, 11), (3, 3), (9, 5)) ) == ((24, 45), (30, 77), (12, 33), (27, 60))']","आप निम्नलिखित फ़ंक्शन का उपयोग कर सकते हैं:

```python
def multiply_tuples(t1, t2):
    return tuple(a*b for a, b in zip(t1, t2))
```

यह फ़ंक्शन `zip` फ़ंक्शन का उपयोग करके दो टुपल्स के समान सूचकांक वाले तत्वों को एक साथ लेता है, और फिर उन्हें गुणा करता है। इसका परिणाम एक नया टुपल होता है जिसमें गुणन के परिणाम होते हैं।

उदाहरण के लिए:

```python
t1 = (1, 2, 3)
t2 = (4, 5, 6)
print(multiply_tuples(t1, t2))  # Output: (4, 10, 18)
```"
charlessutton@: Benchmark Questions Verification V2.ipynb,446,टुपल में सूची के सभी तत्वों की घटना को गिनने के लिए एक पायथन फ़ंक्शन लिखें।,"from collections import Counter 
def count_Occurrence(tup, lst): 
    count = 0
    for item in tup: 
        if item in lst: 
            count+= 1 
    return count  ",[],"[""assert count_Occurrence(('a', 'a', 'c', 'b', 'd'),['a', 'b'] ) == 3"", 'assert count_Occurrence((1, 2, 3, 1, 4, 6, 7, 1, 4),[1, 4, 7]) == 6', 'assert count_Occurrence((1,2,3,4,5,6),[1,2]) == 2']","आप निम्नलिखित तरीके से एक फ़ंक्शन लिख सकते हैं जो एक टुपल में सूची के सभी तत्वों की घटना को गिनता है:

```python
def count_elements_in_tuple(tup, lst):
    count = 0
    for i in lst:
        count += tup.count(i)
    return count

# उदाहरण के लिए
tup = (1, 2, 3, 2, 1, 3, 2, 1, 2, 3, 1, 2, 3)
lst = [1, 2]
print(count_elements_in_tuple(tup, lst))  # यह 8 प्रिंट करेगा
```

इस फ़ंक्शन में, हम पहले एक `count` चर को 0 के साथ आरंभ करते हैं। फिर हम सूची के प्रत्येक तत्व के लिए, हम टुपल में उस तत्व की संख्या को `count` में जोड़ते हैं। अंत में, हम `count` को वापस लौटाते हैं, जो सूची के सभी तत्वों की कुल संख्या होती है जो टुपल में मौजूद होती हैं।"
charlessutton@: Benchmark Questions Verification V2.ipynb,447,किसी सूची में अलग-अलग तत्वों के घन खोजने के लिए एक फ़ंक्शन लिखें।,"def cube_nums(nums):
 cube_nums = list(map(lambda x: x ** 3, nums))
 return cube_nums",[],"['assert cube_nums([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])==[1, 8, 27, 64, 125, 216, 343, 512, 729, 1000]', 'assert cube_nums([10,20,30])==([1000, 8000, 27000])', 'assert cube_nums([12,15])==([1728, 3375])']","आप निम्नलिखित तरीके से एक फ़ंक्शन लिख सकते हैं:

```python
def find_cubes(lst):
    return [i**3 for i in lst]
```

इस फ़ंक्शन का उपयोग करके, आप किसी सूची के सभी तत्वों के घन खोज सकते हैं। उदाहरण के लिए:

```python
print(find_cubes([1, 2, 3, 4, 5]))
```

यह `[1, 8, 27, 64, 125]` प्रिंट करेगा, जो 1 से 5 तक के संख्याओं के घन हैं।"
charlessutton@: Benchmark Questions Verification V2.ipynb,448,पेरिन संख्याओं के योग की गणना करने के लिए एक फ़ंक्शन लिखें।,"def cal_sum(n): 
	a = 3
	b = 0
	c = 2
	if (n == 0): 
		return 3
	if (n == 1): 
		return 3
	if (n == 2): 
		return 5
	sum = 5
	while (n > 2): 
		d = a + b 
		sum = sum + d 
		a = b 
		b = c 
		c = d 
		n = n-1
	return sum",[],"['assert cal_sum(9) == 49', 'assert cal_sum(10) == 66', 'assert cal_sum(11) == 88']","पेरिन संख्याएं एक संख्या श्रृंखला हैं जिसमें प्रत्येक संख्या पिछली दो संख्याओं के योग से बनती है, लेकिन यह फिबोनाची संख्याओं की तरह नहीं होती है, इसकी शुरुआत 3, 0, 2, 3, 2, 5, 5, 7, 10, 12, 17, 22, 29 से होती है।

यहां पेरिन संख्याओं के योग की गणना करने के लिए एक फ़ंक्शन है:

```python
def perin_numbers_sum(n):
    if n == 0:
        return 0
    elif n == 1:
        return 3
    elif n == 2:
        return 3
    else:
        a, b, c = 3, 0, 2
        sum = a + b + c
        for _ in range(3, n):
            a, b, c = b, c, a + b
            sum += c
        return sum
```

इस फ़ंक्शन का उपयोग करके, आप पहले n पेरिन संख्याओं का योग ज्ञात कर सकते हैं। उदाहरण के लिए, `perin_numbers_sum(5)` का परिणाम 13 होगा, क्योंकि 3 + 0 + 2 + 3 + 2 = 13।"
charlessutton@: Benchmark Questions Verification V2.ipynb,450,स्ट्रिंग मानों की दी गई सूची से स्ट्रिंग के निर्दिष्ट आकार को निकालने के लिए एक फ़ंक्शन लिखें।,"def extract_string(str, l):
    result = [e for e in str if len(e) == l] 
    return result",[],"[""assert extract_string(['Python', 'list', 'exercises', 'practice', 'solution'] ,8)==['practice', 'solution']"", ""assert extract_string(['Python', 'list', 'exercises', 'practice', 'solution'] ,6)==['Python']"", ""assert extract_string(['Python', 'list', 'exercises', 'practice', 'solution'] ,9)==['exercises']""]","आप निम्नलिखित तरीके से एक फ़ंक्शन लिख सकते हैं:

```python
def remove_strings_of_length(n, string_list):
    return [s for s in string_list if len(s) != n]
```

इस फ़ंक्शन का उपयोग करने के लिए, आप निम्नलिखित तरीके से कर सकते हैं:

```python
string_list = ['apple', 'banana', 'cherry', 'date', 'elderberry']
n = 5
print(remove_strings_of_length(n, string_list))
```

यह 'apple' और 'date' को हटा देगा, क्योंकि वे दोनों 5 अक्षरों के हैं। बाकी की स्ट्रिंग्स को वापस करेगा।"
charlessutton@: Benchmark Questions Verification V2.ipynb,451,दी गई स्ट्रिंग से सभी रिक्त स्थान हटाने के लिए एक फ़ंक्शन लिखें।,"import re
def remove_whitespaces(text1):
  return (re.sub(r'\s+', '',text1))",[],"[""assert remove_whitespaces(' Google    Flutter ') == 'GoogleFlutter'"", ""assert remove_whitespaces(' Google    Dart ') == 'GoogleDart'"", ""assert remove_whitespaces(' iOS    Swift ') == 'iOSSwift'""]","आप निम्नलिखित फ़ंक्शन का उपयोग कर सकते हैं:

```python
def remove_spaces(string):
    return string.replace("" "", """")
```

इस फ़ंक्शन का उपयोग करने के लिए, आपको बस इसे निम्नलिखित तरीके से कॉल करना होगा:

```python
print(remove_spaces(""Hello World""))
```

यह ""HelloWorld"" प्रिंट करेगा, जिसमें कोई रिक्त स्थान नहीं होगा."
charlessutton@: Benchmark Questions Verification V2.ipynb,452,एक फ़ंक्शन लिखें जो बिक्री पर हानि की राशि देता है यदि दी गई राशि में हानि है अन्यथा 0 लौटाएं।,"def loss_amount(actual_cost,sale_amount): 
  if(sale_amount > actual_cost):
    amount = sale_amount - actual_cost
    return amount
  else:
    return 0",[],"['assert loss_amount(1500,1200)==0', 'assert loss_amount(100,200)==100', 'assert loss_amount(2000,5000)==3000']","यहां एक फ़ंक्शन है जो खरीदी गई राशि और बिक्री राशि के बीच की अंतर की गणना करता है। यदि अंतर नकारात्मक है (अर्थात बिक्री राशि खरीदी गई राशि से कम है), तो यह फ़ंक्शन हानि की राशि लौटाता है। यदि अंतर धनात्मक या 0 है, तो यह फ़ंक्शन 0 लौटाता है।

```python
def calculate_loss(purchase_price, sale_price):
    difference = sale_price - purchase_price
    if difference < 0:
        return -difference
    else:
        return 0
```

इस फ़ंक्शन का उपयोग निम्नलिखित तरीके से किया जा सकता है:

```python
print(calculate_loss(100, 80))  # यह 20 प्रिंट करेगा
print(calculate_loss(100, 120))  # यह 0 प्रिंट करेगा
```"
charlessutton@: Benchmark Questions Verification V2.ipynb,453,किसी संख्या के सम गुणनखंडों का योग ज्ञात करने के लिए एक पायथन फ़ंक्शन लिखें।,"import math 
def sumofFactors(n) : 
    if (n % 2 != 0) : 
        return 0
    res = 1
    for i in range(2, (int)(math.sqrt(n)) + 1) :    
        count = 0
        curr_sum = 1
        curr_term = 1
        while (n % i == 0) : 
            count= count + 1
            n = n // i 
            if (i == 2 and count == 1) : 
                curr_sum = 0
            curr_term = curr_term * i 
            curr_sum = curr_sum + curr_term 
        res = res * curr_sum  
    if (n >= 2) : 
        res = res * (1 + n) 
    return res",[],"['assert sumofFactors(18) == 26', 'assert sumofFactors(30) == 48', 'assert sumofFactors(6) == 8']","आप निम्नलिखित पायथन फ़ंक्शन का उपयोग कर सकते हैं:

```python
def sum_of_factors(n):
    factors = []
    for i in range(1, n + 1):
        if n % i == 0:
            factors.append(i)
    return sum(factors)
```

इस फ़ंक्शन का उपयोग करने के लिए, आपको बस इसे निम्नलिखित तरीके से कॉल करना होगा:

```python
print(sum_of_factors(12))  # उदाहरण के लिए
```

यह फ़ंक्शन संख्या के सभी गुणनखंडों को खोजता है (यानी, सभी संख्याएं जिनके द्वारा दी गई संख्या निःशेष विभाजित होती है), उन्हें एक सूची में जोड़ता है, और फिर उन सभी का योग लौटाता है."
charlessutton@: Benchmark Questions Verification V2.ipynb,454,एक फ़ंक्शन लिखें जो &#39;z&#39; वाले शब्द से मेल खाता हो।,"import re
def text_match_wordz(text):
        patterns = '\w*z.\w*'
        if re.search(patterns,  text):
                return True
        else:
                return False",[],"['assert text_match_wordz(""pythonz."")==True', 'assert text_match_wordz(""xyz."")==True', 'assert text_match_wordz(""  lang  ."")==False']","आप निम्नलिखित तरीके से एक फ़ंक्शन लिख सकते हैं जो 'z' वाले शब्द से मेल खाता है:

```python
def match_words(words):
    # शब्दों की सूची में से प्रत्येक शब्द के लिए चेक करें
    matched_words = [word for word in words if 'z' in word]
    return matched_words

# उदाहरण के लिए
words = ['zebra', 'dog', 'cat', 'lion', 'buzz']
print(match_words(words))  # ['zebra', 'buzz']
```

इस फ़ंक्शन का उपयोग करके, आप किसी भी शब्द सूची को इनपुट के रूप में पास कर सकते हैं और यह उन सभी शब्दों की सूची देगा जिनमें 'z' होता है।"
charlessutton@: Benchmark Questions Verification V2.ipynb,455,यह जाँचने के लिए एक फ़ंक्शन लिखें कि दी गई माह संख्या में 31 दिन हैं या नहीं।,"def check_monthnumb_number(monthnum2):
  if(monthnum2==1 or monthnum2==3 or monthnum2==5 or monthnum2==7 or monthnum2==8 or monthnum2==10 or monthnum2==12):
    return True
  else:
    return False",[],"['assert check_monthnumb_number(5)==True', 'assert check_monthnumb_number(2)==False', 'assert check_monthnumb_number(6)==False']","आप निम्नलिखित फ़ंक्शन का उपयोग कर सकते हैं:

```python
def has_31_days(month_number):
    # माह जिनमें 31 दिन होते हैं
    months_with_31_days = [1, 3, 5, 7, 8, 10, 12]

    # यदि माह संख्या months_with_31_days सूची में है, तो True लौटें, अन्यथा False
    return month_number in months_with_31_days
```

इस फ़ंक्शन का उपयोग करने के लिए, आप माह की संख्या पास करें और यह जांचेगा कि क्या वह माह 31 दिनों वाला है या नहीं। उदाहरण के लिए:

```python
print(has_31_days(1))  # जनवरी, जिसमें 31 दिन होते हैं, इसलिए यह True लौटाता है
print(has_31_days(2))  # फ़रवरी, जिसमें 28 या 29 दिन होते हैं, इसलिए यह False लौटाता है
```"
charlessutton@: Benchmark Questions Verification V2.ipynb,456,स्ट्रिंग मानों की दी गई सूची में प्रत्येक स्ट्रिंग को उलटने के लिए एक फ़ंक्शन लिखें।,"def reverse_string_list(stringlist):
    result = [x[::-1] for x in stringlist]
    return result",[],"[""assert reverse_string_list(['Red', 'Green', 'Blue', 'White', 'Black'])==['deR', 'neerG', 'eulB', 'etihW', 'kcalB']"", ""assert reverse_string_list(['john','amal','joel','george'])==['nhoj','lama','leoj','egroeg']"", ""assert reverse_string_list(['jack','john','mary'])==['kcaj','nhoj','yram']""]","आप निम्नलिखित तरीके से एक फ़ंक्शन लिख सकते हैं:

```python
def reverse_strings(list_of_strings):
    return [s[::-1] for s in list_of_strings]
```

इस फ़ंक्शन का उपयोग करने के लिए, आप एक सूची पास कर सकते हैं:

```python
print(reverse_strings([""hello"", ""world""]))
```

यह ""olleh"" और ""dlrow"" की एक सूची देगा, जो ""hello"" और ""world"" के उलट हैं।"
charlessutton@: Benchmark Questions Verification V2.ipynb,457,न्यूनतम लंबाई वाली उपसूची ढूंढने के लिए एक पायथन फ़ंक्शन लिखें।,"def Find_Min(lst): 
    return min(lst, key=len) ",[],"['assert Find_Min([[1],[1,2],[1,2,3]]) == [1]', 'assert Find_Min([[1,1],[1,1,1],[1,2,7,8]]) == [1,1]', ""assert Find_Min([['x'],['x','y'],['x','y','z']]) == ['x']""]","यहां एक संभावित पायथन फ़ंक्शन है जो एक सूची की सूची में सबसे छोटी लंबाई वाली सूची को वापस करता है:

```python
def find_min_length_sublist(lst):
    return min(lst, key=len)
```

इस फ़ंक्शन का उपयोग करने के लिए, आप इसे निम्नलिखित तरीके से कॉल कर सकते हैं:

```python
lst = [[1, 2, 3], [4, 5], [6], [7, 8, 9, 10]]
print(find_min_length_sublist(lst))  # Output: [6]
```

यह फ़ंक्शन `min` फ़ंक्शन का उपयोग करता है जिसका `key` पैरामीटर `len` फ़ंक्शन को निर्दिष्ट करता है, जिसका अर्थ है कि यह उन सूचियों में से छोटी वाली को चुनेगा जिनकी लंबाई सबसे कम होती है।"
charlessutton@: Benchmark Questions Verification V2.ipynb,458,एक आयत का क्षेत्रफल ज्ञात करने के लिए एक फ़ंक्शन लिखें।,"def rectangle_area(l,b):
  area=l*b
  return area",[],"['assert rectangle_area(10,20)==200', 'assert rectangle_area(10,5)==50', 'assert rectangle_area(4,2)==8']","आयत का क्षेत्रफल लंबाई और चौड़ाई का गुणनफल होता है। इसे Python में निम्नलिखित तरीके से लिखा जा सकता है:

```python
def rectangle_area(length, width):
    return length * width
```

इस फ़ंक्शन का उपयोग निम्नलिखित तरीके से किया जा सकता है:

```python
print(rectangle_area(5, 4))  # Output: 20
```

यहां, 5 और 4 आयत की लंबाई और चौड़ाई हैं, और फ़ंक्शन का परिणाम 20 है, जो क्षेत्रफल है।"
charlessutton@: Benchmark Questions Verification V2.ipynb,459,किसी दिए गए स्ट्रिंग से अपरकेस सबस्ट्रिंग को हटाने के लिए एक फ़ंक्शन लिखें।,"import re
def remove_uppercase(str1):
  return re.sub('[A-Z]', '', str1)",[],"[""assert remove_uppercase('cAstyoUrFavoRitETVshoWs') == 'cstyoravoitshos'"", ""assert remove_uppercase('wAtchTheinTernEtrAdIo') == 'wtchheinerntrdo'"", ""assert remove_uppercase('VoicESeaRchAndreComMendaTionS') == 'oiceachndreomendaion'""]","आप निम्नलिखित फ़ंक्शन का उपयोग कर सकते हैं:

```python
def remove_uppercase_substring(s):
    return ''.join(c for c in s if not c.isupper())
```

यह फ़ंक्शन एक स्ट्रिंग `s` लेता है और स्ट्रिंग के हर वर्ण के लिए चेक करता है कि क्या वह अपरकेस है। यदि वह अपरकेस है, तो वह उसे छोड़ देता है। अन्यथा, वह उसे नई स्ट्रिंग में जोड़ता है। अंत में, यह फ़ंक्शन नई स्ट्रिंग को वापस करता है, जिसमें कोई भी अपरकेस सबस्ट्रिंग नहीं होता है।"
charlessutton@: Benchmark Questions Verification V2.ipynb,460,प्रत्येक उपसूची का पहला तत्व प्राप्त करने के लिए एक पायथन फ़ंक्शन लिखें।,"def Extract(lst): 
    return [item[0] for item in lst] ",[],"['assert Extract([[1, 2], [3, 4, 5], [6, 7, 8, 9]]) == [1, 3, 6]', 'assert Extract([[1,2,3],[4, 5]]) == [1,4]', 'assert Extract([[9,8,1],[1,2]]) == [9,1]']","आप निम्नलिखित तरीके से एक पायथन फ़ंक्शन लिख सकते हैं:

```python
def get_first_elements(lists):
    return [lst[0] for lst in lists if lst]
```

यह फ़ंक्शन एक सूची की सूची को इनपुट के रूप में लेता है और प्रत्येक उपसूची का पहला तत्व एक नई सूची में जोड़ता है। यदि कोई उपसूची खाली है, तो यह उसे छोड़ देता है।"
charlessutton@: Benchmark Questions Verification V2.ipynb,461,किसी दिए गए स्ट्रिंग में अपर केस वर्णों को गिनने के लिए एक पायथन फ़ंक्शन लिखें।,"def upper_ctr(str):
    upper_ctr = 0
    for i in range(len(str)):
          if str[i] >= 'A' and str[i] <= 'Z': upper_ctr += 1
          return upper_ctr",[],"[""assert upper_ctr('PYthon') == 1"", ""assert upper_ctr('BigData') == 1"", ""assert upper_ctr('program') == 0""]","आप निम्नलिखित पायथन फ़ंक्शन का उपयोग कर सकते हैं:

```python
def count_uppercase_letters(string):
    count = 0
    for char in string:
        if char.isupper():
            count += 1
    return count
```

इस फ़ंक्शन का उपयोग करने के लिए, आप बस इसे निम्नलिखित तरीके से कॉल करें:

```python
print(count_uppercase_letters(""Hello World""))
```

यह ""Hello World"" में अपर केस वर्णों की संख्या प्रिंट करेगा, जो 2 है।"
charlessutton@: Benchmark Questions Verification V2.ipynb,462,किसी दी गई सूची के तत्वों के सभी संभावित संयोजनों को खोजने के लिए एक फ़ंक्शन लिखें।,"def combinations_list(list1):
    if len(list1) == 0:
        return [[]]
    result = []
    for el in combinations_list(list1[1:]):
        result += [el, el+[list1[0]]]
    return result",[],"[""assert combinations_list(['orange', 'red', 'green', 'blue'])==[[], ['orange'], ['red'], ['red', 'orange'], ['green'], ['green', 'orange'], ['green', 'red'], ['green', 'red', 'orange'], ['blue'], ['blue', 'orange'], ['blue', 'red'], ['blue', 'red', 'orange'], ['blue', 'green'], ['blue', 'green', 'orange'], ['blue', 'green', 'red'], ['blue', 'green', 'red', 'orange']]"", ""assert combinations_list(['red', 'green', 'blue', 'white', 'black', 'orange'])==[[], ['red'], ['green'], ['green', 'red'], ['blue'], ['blue', 'red'], ['blue', 'green'], ['blue', 'green', 'red'], ['white'], ['white', 'red'], ['white', 'green'], ['white', 'green', 'red'], ['white', 'blue'], ['white', 'blue', 'red'], ['white', 'blue', 'green'], ['white', 'blue', 'green', 'red'], ['black'], ['black', 'red'], ['black', 'green'], ['black', 'green', 'red'], ['black', 'blue'], ['black', 'blue', 'red'], ['black', 'blue', 'green'], ['black', 'blue', 'green', 'red'], ['black', 'white'], ['black', 'white', 'red'], ['black', 'white', 'green'], ['black', 'white', 'green', 'red'], ['black', 'white', 'blue'], ['black', 'white', 'blue', 'red'], ['black', 'white', 'blue', 'green'], ['black', 'white', 'blue', 'green', 'red'], ['orange'], ['orange', 'red'], ['orange', 'green'], ['orange', 'green', 'red'], ['orange', 'blue'], ['orange', 'blue', 'red'], ['orange', 'blue', 'green'], ['orange', 'blue', 'green', 'red'], ['orange', 'white'], ['orange', 'white', 'red'], ['orange', 'white', 'green'], ['orange', 'white', 'green', 'red'], ['orange', 'white', 'blue'], ['orange', 'white', 'blue', 'red'], ['orange', 'white', 'blue', 'green'], ['orange', 'white', 'blue', 'green', 'red'], ['orange', 'black'], ['orange', 'black', 'red'], ['orange', 'black', 'green'], ['orange', 'black', 'green', 'red'], ['orange', 'black', 'blue'], ['orange', 'black', 'blue', 'red'], ['orange', 'black', 'blue', 'green'], ['orange', 'black', 'blue', 'green', 'red'], ['orange', 'black', 'white'], ['orange', 'black', 'white', 'red'], ['orange', 'black', 'white', 'green'], ['orange', 'black', 'white', 'green', 'red'], ['orange', 'black', 'white', 'blue'], ['orange', 'black', 'white', 'blue', 'red'], ['orange', 'black', 'white', 'blue', 'green'], ['orange', 'black', 'white', 'blue', 'green', 'red']]"", ""assert combinations_list(['red', 'green', 'black', 'orange'])==[[], ['red'], ['green'], ['green', 'red'], ['black'], ['black', 'red'], ['black', 'green'], ['black', 'green', 'red'], ['orange'], ['orange', 'red'], ['orange', 'green'], ['orange', 'green', 'red'], ['orange', 'black'], ['orange', 'black', 'red'], ['orange', 'black', 'green'], ['orange', 'black', 'green', 'red']]""]","आप itertools मॉड्यूल का उपयोग करके सभी संभावित संयोजनों को खोज सकते हैं। यहां एक फ़ंक्शन है जो ऐसा करता है:

```python
from itertools import combinations

def find_combinations(lst):
    # सभी संभावित संयोजनों की सूची को संग्रहित करने के लिए एक खाली सूची बनाएं
    all_combinations = []
    
    # सूची के हर तत्व के लिए
    for r in range(len(lst) + 1):
        # itertools.combinations का उपयोग करके सभी संभावित संयोजनों की सूची बनाएं
        combinations_object = combinations(lst, r)
        combinations_list = list(combinations_object)
        all_combinations += combinations_list
    
    return all_combinations
```

उदाहरण के लिए, यदि आप इसे [1, 2, 3] के साथ चलाते हैं, तो यह निम्नलिखित सभी संभावित संयोजनों की सूची देगा:

```python
print(find_combinations([1, 2, 3]))
```

आउटपुट:

```python
[(), (1,), (2,), (3,), (1, 2), (1, 3), (2, 3), (1, 2, 3)]
```"
charlessutton@: Benchmark Questions Verification V2.ipynb,463,दिए गए सरणी का अधिकतम उत्पाद उपसरणी खोजने के लिए एक फ़ंक्शन लिखें।,"def max_subarray_product(arr):
	n = len(arr)
	max_ending_here = 1
	min_ending_here = 1
	max_so_far = 0
	flag = 0
	for i in range(0, n):
		if arr[i] > 0:
			max_ending_here = max_ending_here * arr[i]
			min_ending_here = min (min_ending_here * arr[i], 1)
			flag = 1
		elif arr[i] == 0:
			max_ending_here = 1
			min_ending_here = 1
		else:
			temp = max_ending_here
			max_ending_here = max (min_ending_here * arr[i], 1)
			min_ending_here = temp * arr[i]
		if (max_so_far < max_ending_here):
			max_so_far = max_ending_here
	if flag == 0 and max_so_far == 0:
		return 0
	return max_so_far",[],"['assert max_subarray_product([1, -2, -3, 0, 7, -8, -2]) == 112', 'assert max_subarray_product([6, -3, -10, 0, 2]) == 180', 'assert max_subarray_product([-2, -40, 0, -2, -3]) == 80']","यहां एक फ़ंक्शन है जो एक सूची में उपसूचियों का अधिकतम उत्पाद खोजता है। यह फ़ंक्शन एक सूची को इनपुट के रूप में लेता है और उसके सभी उपसूचियों का उत्पाद खोजता है, और फिर उनमें से सबसे बड़े उत्पाद को वापस करता है।

```python
from functools import reduce
import operator

def max_product(lst):
    return max(reduce(operator.mul, sub_lst) for sub_lst in lst)
```

इस फ़ंक्शन का उपयोग निम्नलिखित तरीके से किया जा सकता है:

```python
print(max_product([[1, 2, 3], [4, 5, 6], [7, 8, 9]]))  # Output: 504
```

इस उदाहरण में, फ़ंक्शन को तीन उपसूचियाँ दी गई हैं: [1, 2, 3], [4, 5, 6] और [7, 8, 9]। इनमें से प्रत्येक का उत्पाद क्रमशः 6, 120 और 504 है, इसलिए फ़ंक्शन 504 वापस करता है, जो सबसे बड़ा उत्पाद है।"
charlessutton@: Benchmark Questions Verification V2.ipynb,464,यह जांचने के लिए एक फ़ंक्शन लिखें कि शब्दकोश में सभी मान समान हैं या नहीं।,"def check_value(dict, n):
    result = all(x == n for x in dict.values()) 
    return result",[],"[""assert check_value({'Cierra Vega': 12, 'Alden Cantrell': 12, 'Kierra Gentry': 12, 'Pierre Cox': 12},10)==False"", ""assert check_value({'Cierra Vega': 12, 'Alden Cantrell': 12, 'Kierra Gentry': 12, 'Pierre Cox': 12},12)==True"", ""assert check_value({'Cierra Vega': 12, 'Alden Cantrell': 12, 'Kierra Gentry': 12, 'Pierre Cox': 12},5)==False""]","आप निम्नलिखित फ़ंक्शन का उपयोग कर सकते हैं:

```python
def check_values_equal(dictionary):
    return len(set(dictionary.values())) == 1
```

यह फ़ंक्शन शब्दकोश के सभी मानों को एक सेट में बदलता है (जिसमें प्रत्येक मान केवल एक बार आता है), और फिर जांचता है कि इसकी लंबाई 1 है या नहीं। यदि लंबाई 1 है, तो सभी मान समान हैं; यदि नहीं, तो सभी मान समान नहीं हैं।"
charlessutton@: Benchmark Questions Verification V2.ipynb,465,किसी दिए गए शब्दकोश से खाली आइटम हटाने के लिए एक फ़ंक्शन लिखें।,"def drop_empty(dict1):
  dict1 = {key:value for (key, value) in dict1.items() if value is not None}
  return dict1",[],"[""assert drop_empty({'c1': 'Red', 'c2': 'Green', 'c3':None})=={'c1': 'Red', 'c2': 'Green'}"", ""assert drop_empty({'c1': 'Red', 'c2': None, 'c3':None})=={'c1': 'Red'}"", ""assert drop_empty({'c1': None, 'c2': 'Green', 'c3':None})=={ 'c2': 'Green'}""]","आप निम्नलिखित फ़ंक्शन का उपयोग कर सकते हैं:

```python
def remove_empty_items(dictionary):
    return {k: v for k, v in dictionary.items() if v}
```

यह फ़ंक्शन एक शब्दकोश को इनपुट के रूप में लेता है और एक नया शब्दकोश वापस करता है जिसमें केवल वही आइटम होते हैं जिनका मान खाली नहीं है। यदि आइटम का मान खाली है (जैसे कि एक खाली स्ट्रिंग, खाली सूची, खाली टपल, खाली डिक्शनरी, या `None`), तो वह आइटम नई डिक्शनरी से हटा दिया जाता है।"
charlessutton@: Benchmark Questions Verification V2.ipynb,468,उस सरणी के बढ़ते क्रम की संख्याओं को गुणा करके बनने वाले अधिकतम उत्पाद को खोजने के लिए एक फ़ंक्शन लिखें।,"def max_product(arr):   
  n = len(arr)
  mpis = arr[:]
  for i in range(n): 
    current_prod = arr[i]
    j = i + 1
    while j < n:
      if arr[j-1] > arr[j]: 
        break
      current_prod *= arr[j]
      if current_prod > mpis[j]:
        mpis[j] = current_prod 
      j = j + 1
  return max(mpis)",[],"['assert max_product([3, 100, 4, 5, 150, 6]) == 3000', 'assert max_product([4, 42, 55, 68, 80]) == 50265600', 'assert max_product([10, 22, 9, 33, 21, 50, 41, 60]) == 2460']","यहां एक फ़ंक्शन है जो एक सूची की संख्याओं को बढ़ते क्रम में लेता है और उनका अधिकतम उत्पाद लौटाता है:

```python
def max_product(lst):
    lst.sort()
    return lst[-1] * lst[-2]
```

यह फ़ंक्शन सूची को बढ़ते क्रम में सॉर्ट करता है, और फिर अंतिम दो संख्याओं (जो सबसे बड़ी होंगी) का उत्पाद लौटाता है। यह मानते हुए कि सूची में कम से कम दो संख्याएं होंगी।

यदि सूची में केवल एक संख्या हो, तो यह फ़ंक्शन एक त्रुटि उत्पन्न करेगा। इसे हटाने के लिए, हम एक जांच जोड़ सकते हैं:

```python
def max_product(lst):
    if len(lst) < 2:
        return None
    lst.sort()
    return lst[-1] * lst[-2]
```

अब, यदि सूची में केवल एक संख्या हो, तो फ़ंक्शन None लौटाएगा।"
charlessutton@: Benchmark Questions Verification V2.ipynb,470,दिए गए टपल के पड़ोसी तत्वों का जोड़ीवार योग ज्ञात करने के लिए एक फ़ंक्शन लिखें।,"def add_pairwise(test_tup):
  res = tuple(i + j for i, j in zip(test_tup, test_tup[1:]))
  return (res) ",[],"['assert add_pairwise((1, 5, 7, 8, 10)) == (6, 12, 15, 18)', 'assert add_pairwise((2, 6, 8, 9, 11)) == (8, 14, 17, 20)', 'assert add_pairwise((3, 7, 9, 10, 12)) == (10, 16, 19, 22)']","आप निम्नलिखित फ़ंक्शन का उपयोग कर सकते हैं:

```python
def sum_of_pairs(my_tuple):
    return [my_tuple[i] + my_tuple[i+1] for i in range(len(my_tuple)-1)]

# उदाहरण के लिए:
my_tuple = (1, 2, 3, 4, 5)
print(sum_of_pairs(my_tuple))  # आउटपुट: [3, 5, 7, 9]
```

यह फ़ंक्शन टपल के हर दो पड़ोसी तत्वों का योग करता है और उनके योगों की एक सूची वापस करता है। ध्यान दें कि यह फ़ंक्शन टपल के अंतिम तत्व को छोड़ देता है, क्योंकि उसका कोई पड़ोसी तत्व नहीं होता है।"
charlessutton@: Benchmark Questions Verification V2.ipynb,471,सरणी गुणन मॉड्यूलो एन के उत्पाद को खोजने के लिए एक पायथन फ़ंक्शन लिखें।,"def find_remainder(arr, n): 
    mul = 1
    for i in range(len(arr)):  
        mul = (mul * (arr[i] % n)) % n 
    return mul % n ",[],"['assert find_remainder([ 100, 10, 5, 25, 35, 14 ],11) ==9', 'assert find_remainder([1,1,1],1) == 0', 'assert find_remainder([1,2,1],2) == 0']","आप निम्नलिखित पायथन फ़ंक्शन का उपयोग कर सकते हैं:

```python
def product_modulo_n(series, n):
    product = 1
    for num in series:
        product = (product * num) % n
    return product
```

इस फ़ंक्शन का उपयोग करने के लिए, आपको सरणी (संख्याओं की एक सूची) और मॉड्यूलो एन (एक पूर्णांक) प्रदान करना होगा। फ़ंक्शन सरणी में सभी संख्याओं का उत्पाद लेता है, और फिर उस उत्पाद को एन से मॉड्यूलो लेता है। यह उत्पाद मॉड्यूलो एन वापस देता है।"
charlessutton@: Benchmark Questions Verification V2.ipynb,472,यह जांचने के लिए एक पायथन फ़ंक्शन लिखें कि दी गई सूची में लगातार संख्याएं हैं या नहीं।,"def check_Consecutive(l): 
    return sorted(l) == list(range(min(l),max(l)+1)) ",[],"['assert check_Consecutive([1,2,3,4,5]) == True', 'assert check_Consecutive([1,2,3,5,6]) == False', 'assert check_Consecutive([1,2,1]) == False']","यहां एक संभावित पायथन फ़ंक्शन है जो यह जांचता है कि सूची में लगातार संख्याएं हैं या नहीं:

```python
def are_numbers_consecutive(lst):
    return sorted(lst) == list(range(min(lst), max(lst)+1))

# उदाहरण
print(are_numbers_consecutive([1, 2, 3, 4, 5]))  # True
print(are_numbers_consecutive([1, 2, 4, 5]))  # False
```

यह फ़ंक्शन `are_numbers_consecutive` नामक एक फ़ंक्शन है जो एक सूची `lst` को इनपुट के रूप में लेता है। यह फ़ंक्शन `sorted(lst)` का उपयोग करके सूची को क्रमबद्ध करता है, और फिर इसे `list(range(min(lst), max(lst)+1))` के साथ तुलना करता है, जो `min(lst)` से `max(lst)+1` तक की सभी संख्याओं की एक सूची बनाता है। यदि ये दोनों सूचियाँ समान हैं, तो सूची में संख्याएं लगातार हैं, और फ़ंक्शन `True` लौटाता है। यदि नहीं, तो फ़ंक्शन `False` लौटाता है।"
charlessutton@: Benchmark Questions Verification V2.ipynb,473,दी गई टुपल सूची में तत्वों के क्रम की परवाह किए बिना उनके टुपल प्रतिच्छेदन को खोजने के लिए एक फ़ंक्शन लिखें।,"def tuple_intersection(test_list1, test_list2):
  res = set([tuple(sorted(ele)) for ele in test_list1]) & set([tuple(sorted(ele)) for ele in test_list2])
  return (res)",[],"['assert tuple_intersection([(3, 4), (5, 6), (9, 10), (4, 5)] , [(5, 4), (3, 4), (6, 5), (9, 11)]) == {(4, 5), (3, 4), (5, 6)}', 'assert tuple_intersection([(4, 1), (7, 4), (11, 13), (17, 14)] , [(1, 4), (7, 4), (16, 12), (10, 13)]) == {(4, 7), (1, 4)}', 'assert tuple_intersection([(2, 1), (3, 2), (1, 3), (1, 4)] , [(11, 2), (2, 3), (6, 2), (1, 3)]) == {(1, 3), (2, 3)}']","आप इसे निम्नलिखित तरीके से कर सकते हैं:

```python
def find_duplicates_in_tuples(lst):
    seen = set()
    duplicates = set()
    for tup in lst:
        for item in tup:
            if item in seen:
                duplicates.add(tup)
            seen.add(item)
    return duplicates
```

इस फ़ंक्शन का उपयोग करने के लिए, आप इसे निम्नलिखित तरीके से कॉल कर सकते हैं:

```python
lst = [(1, 2), (3, 4), (1, 2), (5, 6), (7, 8), (1, 2), (3, 4), (3, 4), (7, 8), (9, 10)]
print(find_duplicates_in_tuples(lst))
```

यह उन सभी टुपलों को प्रिंट करेगा जिनमें दोहराव है।"
charlessutton@: Benchmark Questions Verification V2.ipynb,474,किसी स्ट्रिंग में वर्णों को बदलने के लिए एक फ़ंक्शन लिखें।,"def replace_char(str1,ch,newch):
 str2 = str1.replace(ch, newch)
 return str2",[],"['assert replace_char(""polygon"",\'y\',\'l\')==(""pollgon"")', 'assert replace_char(""character"",\'c\',\'a\')==(""aharaater"")', 'assert replace_char(""python"",\'l\',\'a\')==(""python"")']","आप निम्नलिखित तरीके से एक स्ट्रिंग में वर्णों को बदलने के लिए एक फ़ंक्शन लिख सकते हैं:

```python
def replace_chars(my_string, old_char, new_char):
    return my_string.replace(old_char, new_char)
```

इस फ़ंक्शन का उपयोग करने के लिए, आपको बस उस स्ट्रिंग को पास करना होगा जिसमें आप वर्णों को बदलना चाहते हैं, फिर वह वर्ण जिसे आप बदलना चाहते हैं, और अंत में वह वर्ण जिसे आप नये वर्ण के रूप में जोड़ना चाहते हैं।

उदाहरण के लिए:

```python
print(replace_chars(""hello world"", ""o"", ""a""))
```

यह ""hello world"" स्ट्रिंग में सभी ""o"" वर्णों को ""a"" से बदल देगा, और ""hella warld"" प्रिंट करेगा।"
charlessutton@: Benchmark Questions Verification V2.ipynb,475,किसी शब्दकोश को मूल्य के आधार पर क्रमबद्ध करने के लिए एक फ़ंक्शन लिखें।,"from collections import Counter
def sort_counter(dict1):
 x = Counter(dict1)
 sort_counter=x.most_common()
 return sort_counter",[],"[""assert sort_counter({'Math':81, 'Physics':83, 'Chemistry':87})==[('Chemistry', 87), ('Physics', 83), ('Math', 81)]"", ""assert sort_counter({'Math':400, 'Physics':300, 'Chemistry':250})==[('Math', 400), ('Physics', 300), ('Chemistry', 250)]"", ""assert sort_counter({'Math':900, 'Physics':1000, 'Chemistry':1250})==[('Chemistry', 1250), ('Physics', 1000), ('Math', 900)]""]","आप निम्नलिखित फ़ंक्शन का उपयोग कर सकते हैं:

```python
def sort_dict_by_value(d):
    return {k: v for k, v in sorted(d.items(), key=lambda item: item[1])}
```

यह फ़ंक्शन एक शब्दकोश को इनपुट के रूप में लेता है और मूल्यों के आधार पर उसे क्रमबद्ध करता है। यह एक नया शब्दकोश वापस करता है जिसमें वस्तुएँ मूल्य के आधार पर क्रमबद्ध होती हैं।

उदाहरण के लिए:

```python
d = {'apple': 18, 'banana': 5, 'cherry': 12}
print(sort_dict_by_value(d))
```

आउटपुट:

```python
{'banana': 5, 'cherry': 12, 'apple': 18}
```

यहां 'banana', 'cherry' और 'apple' क्रमशः 5, 12 और 18 मूल्यों के आधार पर क्रमबद्ध हैं।"
charlessutton@: Benchmark Questions Verification V2.ipynb,476,किसी दिए गए सरणी में सबसे बड़े और सबसे छोटे मान का योग ज्ञात करने के लिए एक पायथन फ़ंक्शन लिखें।,"def big_sum(nums):
      sum= max(nums)+min(nums)
      return sum",[],"['assert big_sum([1,2,3]) == 4', 'assert big_sum([-1,2,3,4]) == 3', 'assert big_sum([2,3,6]) == 8']","आप निम्नलिखित पायथन फ़ंक्शन का उपयोग कर सकते हैं:

```python
def min_max_sum(lst):
    return min(lst) + max(lst)
```

इस फ़ंक्शन का उपयोग करने के लिए, आपको बस एक सूची पास करनी होगी। उदाहरण के लिए:

```python
print(min_max_sum([1, 2, 3, 4, 5]))  # यह 6 प्रिंट करेगा (1 + 5)
```"
charlessutton@: Benchmark Questions Verification V2.ipynb,477,दी गई स्ट्रिंग को लोअर केस में बदलने के लिए एक पायथन फ़ंक्शन लिखें।,"def is_lower(string):
  return (string.lower())",[],"['assert is_lower(""InValid"") == ""invalid""', 'assert is_lower(""TruE"") == ""true""', 'assert is_lower(""SenTenCE"") == ""sentence""']","आप निम्नलिखित तरीके से एक स्ट्रिंग को लोअर केस में बदलने के लिए पायथन फ़ंक्शन लिख सकते हैं:

```python
def convert_to_lowercase(input_string):
    return input_string.lower()
```

इस फ़ंक्शन का उपयोग करने के लिए, आप निम्नलिखित तरीके से कॉल कर सकते हैं:

```python
print(convert_to_lowercase(""HELLO WORLD""))
```

यह ""hello world"" प्रिंट करेगा, जो इनपुट स्ट्रिंग का लोअरकेस वर्जन है।"
charlessutton@: Benchmark Questions Verification V2.ipynb,478,किसी दिए गए स्ट्रिंग से लोअरकेस सबस्ट्रिंग को हटाने के लिए एक फ़ंक्शन लिखें।,"import re
def remove_lowercase(str1):
 return re.sub('[a-z]', '', str1)",[],"['assert remove_lowercase(""PYTHon"")==(\'PYTH\')', 'assert remove_lowercase(""FInD"")==(\'FID\')', 'assert remove_lowercase(""STRinG"")==(\'STRG\')']","यहां एक फ़ंक्शन है जो एक स्ट्रिंग से सभी लोअरकेस सबस्ट्रिंग को हटा देगा:

```python
def remove_lowercase_substrings(s):
    return ''.join(c for c in s if not c.islower())
```

इस फ़ंक्शन का उपयोग करने के लिए, आप बस इसे निम्नलिखित तरीके से कॉल करें:

```python
print(remove_lowercase_substrings(""Hello World""))
```

यह ""HW"" प्रिंट करेगा, क्योंकि यह सभी लोअरकेस अक्षरों को हटा देता है।"
charlessutton@: Benchmark Questions Verification V2.ipynb,479,किसी दी गई संख्या का पहला अंक ज्ञात करने के लिए एक पायथन फ़ंक्शन लिखें।,"def first_Digit(n) :  
    while n >= 10:  
        n = n / 10 
    return int(n) ",[],"['assert first_Digit(123) == 1', 'assert first_Digit(456) == 4', 'assert first_Digit(12) == 1']","आप निम्नलिखित पायथन फ़ंक्शन का उपयोग कर सकते हैं:

```python
def get_first_digit(n):
    while n >= 10:  # जब तक संख्या 10 से बड़ी है
        n = n // 10  # संख्या को 10 से भाग दें
    return n  # पहला अंक लौटाएं
```

इस फ़ंक्शन का उपयोग करने के लिए, आप बस इसे निम्नलिखित तरीके से कॉल करें:

```python
print(get_first_digit(12345))  # यह 1 प्रिंट करेगा
```"
